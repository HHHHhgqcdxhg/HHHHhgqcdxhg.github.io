<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shader入门精要-Unity Shader 基础]]></title>
    <url>%2Fshader-r-unity-shader%2F</url>
    <content type="text"><![CDATA[UnityShader概述unity中的shaderStandard Surface Shader会产生一个包含了标准光照模型(使用了Unity5中新添加的基于物理的渲染方法,详见第18章)的表面着色器模板 Unlit Shader会产生一个不含光照(单包含雾化效果)的基本顶点/片段着色器 ImageEffect Shader为我们实现各种屏幕文件.这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算,而不在这本书的讨论范围内(草) UnityShader的结构SubShaderSubshader中定义了一系列的Pass一级可选的状态和标签的设置. 每个Pass定义了一次完整的渲染流程,但如果pass的数目过多,往往会造成渲染性能的下降.因此,我们应尽量使用小数目的Pass. 状态和标签同样可以在Pass声明.不同的是,SubShader中的一些标签设定是特定的.也就是说,这些标签设置和Pass中使用的标签是不一样的.而对于状态设置来说,其使用的语法是相同的.但是,如果我们在SubShader中进行了这些设置,那么将会用于所有Pass 状态设置ShaderLab提供了一系列渲染状态的设置指令,这些指令可以设置显卡的各种状态.例如是否开启混合/深度测试等. 状态名称 设置指令 解释 Cull Cull Back/Front/Off 设置剔除模式.剔除背面/正面/关闭剔除 ZTest ZTest Less Greater/LEqual/GEqual/NotEqual/Always 设置深度测试时使用的函数 Zwrite ZWrite On/Off 开启/关闭深度测试 Blend Blend SrcFactor DstFactor 开启并设置混合模式 当在SubShader块中设置了这些渲染状态时,将会应用到所有Pass,如果我们不想这样,可以在Pass语义块中单独进行上面的设置. SubShader标签SubShader的标签是一个键值对,他的键和值都是字符串类型.标签结构如下: 1Tags &#123; &quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; &#125; 标签类型 说明 例子 Queue 控制渲染顺序,指定该物体属于哪一个渲染队列,通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染(详见第8章).我们也可以自定义使用的渲染队列来控制物体的渲染顺序 Tags { “Queue” = “Transparent” } RenderType 对着色器进行分类,例如这是一个不透明的着色器,或是一个透明的着色器.这可以用于着色器替换功能(啥玩意) Tags { “RenderType” = “Opaque” } DisableBatching 一些SubShader在使用Unity批处理功能时会出现问题,例如使用了模型空间下的坐标进行顶点动画(详见第11.3节).这时可以通过该标签来指明是否对该SubShader使用批处理. Tags { “DisableBatching” = “True” } ForceNoShadowCasting 控制使用该SubShader的物体是否会投射阴影(详见8.4)节 Tags { “ForceNoShadowCasting” = “True” } IgnoreProjector 如果该标签设置为True,那么使用该SubShader的物体不会受到projector的影响.通常用于半透明物体. Tags { “IgnoreProjector” = “True” } CanUseSpriteAtlas 当该SubShader是用于精灵时,将该标签设为False Tags { “CanUseSpriteAtlas” = “False” } PreviewType 指名材质面板将如何预览该材质.默认情况下,材质将显示为一个球形.我们可以通过将该标签的值设为”Plane” “SkyBox”来改变预览类型. Tags { “PreviewType” = “Plane” } Pass语义块Pass语义块包含的语义如下 12345Pass &#123; [Name] [Tags] // Other Code&#125; 首先,我们可以在Pass中定义该Pass的名称,例如 1Name &quot;MyPassName&quot; 通过这个名称,我们可以使用Shader的UsePass命令来直接使用其他UnityShader中的Pass.例如: 1UsePass &quot;MyShader/MYPASSNAME&quot; 这样可以提高代码的复用性.需要注意的是,由于Unity内部会把所有Pass的名字转换成大写字母的表示,因此在使用UsePass命令时必须使用大写的名字. Pass同样可以设置标签,但它的标签不同于SubShader标签.这些标签也是告诉渲染引擎我们希望怎么来渲染该物体. 标签类型 说明 例子 LightMode 定义该Pass在Unity的渲染管线中的角色 Tags { “LightMode” = “ForwardBase” } RequiresOptions 用于指定当满足某些条件时才渲染该Pass,它的值是一个由空格分隔的字符串.目前,Unity支持的选项有: SoftVegetation. 在后面的版本中,可能会增加更多的选项. Tags{ “RequireOption” = “SoftVegetation” } 除了上面的普通Pass定义外,Unity Shader还支持一些特殊的Pass, 以便进行代码复用或实现更复杂的效果. UsePass 如之前所说,可以引入其他Unity Shader中的Pass. GrabPass 负责抓取屏幕并将结果存储在一张纹理中,以用于后续的Pass处理(详见10.2.2节)FallBack 1234FallBack &quot;name&quot;FallBack OffFallBack &quot;VertexLit&quot; 事实上,FallBack还会影响阴影的投射.在渲染阴影纹理时,Unity会在每个UnityShader中寻找一个阴影投射的Pass.通常情况下,我们不用自己专门实现一个阴影投射的Pass,这是因为FallBack使用内置Shader中包含了这样一个通用Pass. 因此,为每个UnityShader设置正确的FallBack是非常重要的. UnityShader的形式尽管UnityShader可以做的事情非常多(如设置渲染状态等),但其最重要的任务还是指定各种着色器所需的代码.这些着色器代码可以写在Shader语义块中(表面着色器的做法),也可以写在Pass语义块中(顶点/片元着色器和固定函数着色器的做法). 表面着色器Surface Shader是Unity自己创造的一种着色器代码类型.它需要的代码量很少,Unity在背后做了很多工作,单渲染代价比较大.当给Unity提供一个表面着色器的时候,它在背后仍旧会将它转换成对应飞顶点/片元着色器. 它存在的价值在于,Unity为我们处理了很多光照细节,使得我们不需要再操心这些烦人的事情.一个非常简单的表面着色器示例代码: 12345678910111213141516Shader &quot;Custom/sur&quot;&#123; SubShader&#123; Tags &#123;&quot;RenderType&quot; = &quot;Opaque&quot;&#125; CGPROGRAM #pragma surface surf Lambert struct Input &#123; float4 color:COLOR; &#125;; void surf(Input In, inout SurfaceOutput o) &#123; o.Albedo = 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 上述程序可以看出,表面着色器被定义在SubShader语义块(而非Pass语义块)中的CGPROGRAM和ENDCG之间.原因是,表面着色器不需要关心开发者使用多少个Pass,每个Pass如何渲染等问题,Unity会在背后去帮我们做好这些事情.我们要做的只是告诉它,”用这些纹理去填充颜色,用这个法线纹理去填充法线,使用Lambert光照模型” CGPROGRAM和ENDCG之间的代码是使用Cg/HLSL编写的,也就是说,我们需要把Cg/HLSL语言嵌套在ShaderLab中.值得注意的是,这里的Cg/HLSL是Unity经过封装后提供的,它的标准语法和标准的Cg/HLSL几乎一样,但还是有细微不同.例如有些原生的函数和用法Unity并没有提供支持. 顶点/片元着色器**Vertex/Fragment Shader更加复杂,但灵活性更高. 123456789101112131415161718192021Shader &quot;Custom/vertexfragment&quot;&#123; SubShader&#123; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v : position) : SV_POSITION&#123; return mul(UNITY_MATRIX_MVP, v); &#125; float4 frag() : SV_Target&#123; return fixed4(1.0,0.0,0.0,1.0); &#125; ENDCG &#125; &#125;&#125; 和表面着色器类似,顶点/片元着色器的代码也需要定义在CGPROGRAM和ENDCG中间.但不同的是,顶点/片元着色器是写在Pass语义块中的,而非SubShader语义块内.原因是我们需要自己定义每个Pass需要使用的Shader代码.虽然我们可能需要编写更多的代码,但带来的好处是灵活性很高.更重要的是,我们可以控制渲染的实现细节. 固定函数着色器Fixed Function Shader弃子,现在不怎么用的着色器上面两种着色器都是用了可编程管线.而对于一些较旧的设备,它们不支持可编程管线着色器,因此,我们就需要使用固定函数着色器.这些着色器往往只能完成一些非常简单的效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[shader入门精要-流水线部分]]></title>
    <url>%2Fshader-r-lsx%2F</url>
    <content type="text"><![CDATA[逐片元操作片元通过模板测试和深度测试后会进行合并合并是指,每个像素的信息会被存储在颜色缓冲,因此,当我们本次渲染时,要考虑新来的颜色和旧的颜色的混合]]></content>
  </entry>
  <entry>
    <title><![CDATA[bili-api]]></title>
    <url>%2Fbili-api%2F</url>
    <content type="text"><![CDATA[url 描述 https://api.bilibili.com/x/relation/stat?vmid={uid} up粉丝数 https://api.bilibili.com/x/space/upstat?mid={uid} 观看量 https://api.bilibili.com/x/space/navnum?mid={uid} 投稿数量 https://api.bilibili.com/x/space/acc/info?mid={uid} 基本信息 https://api.bilibili.com/x/space/masterpiece?vmid={uid} 代表作]]></content>
  </entry>
  <entry>
    <title><![CDATA[shader入门精要-数学部分]]></title>
    <url>%2Fshader-r-math%2F</url>
    <content type="text"><![CDATA[数学(?) 点和矢量点积(内积)和叉积(外积)内积Shader代码中使用dot(a,b)来进行矢量的点积运算. 1a·b = (a x , a y , a z ) ·(b x , b y , b z ) = a x b x + a y b y + a z b z 满足交换律和结合律.使用: 投影 单位矢量a,和一个长度不限制的矢量b,dot(a,b)得到b在a方向上带有符号的投影 外积外积的结果时矢量,并非标量. 1a X b = (a x , a y , a z ) X (b x , b y , b z ) = (a y b z - a z b y , a z b x - a x b z , a x b y - a y b x ) 例如:(1, 2, 3) X (−2, −1, 4) = ((2)(4) − (3)(−1), (3)(−2) − (1)(4), (1)(−1) − (2)(−2))= (8 − (−3), (−6) − 4, (−1) − (−4)) = (11, −10, 3)外积不满足交换律,即a X b不等于b X a.然而外积满足反交换律,即a X b = -(b X a)外积不满足结合律. 矩阵(matrix)矩阵运算矩阵乘法 矩阵乘法不满足交换律 AB不等于BA 矩阵乘法满足结合律 (AB)C = A(BC) shader中主要使用4x4矩阵来运算. 特殊矩阵方块矩阵(方阵)行和列数目相等的矩阵.三维渲染里,用的最多的是3x3和4x4的方阵 单位矩阵用In来表示.比如I3是3x3的单位矩阵. 转置矩阵(transposed matrix)转置矩阵实际是对原矩阵的一种运算,即转置运算.给定一个rXc的矩阵M,他的转置可以表示为MT(T为上标)(辣鸡MD).数学公式是:例如: 转置矩阵性质: 转置矩阵的转置等于原矩阵(废话) 矩阵的串接转置等于反向串接各个矩阵的转置 即: 逆矩阵给定一个矩阵M,用M-1(-1为上标)表示M的逆矩阵.MM-1为单位矩阵 矩阵可逆的条件: 矩阵为方块矩阵 矩阵的行列式不为零 虽说在学数学…但是也是shader开发里的数学…还是不去回忆具体怎么求逆矩阵了,交给程序去做=v= 逆矩阵的性质 逆矩阵的逆矩阵等于原矩阵 单位矩阵的逆矩阵是其本身 转置矩阵的逆矩阵等于逆矩阵的转置 即: 矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵 即: 正交矩阵蒸饺正交是矩阵的一种属性.如果一个方阵M和它的转置矩阵的乘积是单位矩阵的话,我们说这个矩阵是正交的即: 行矩阵or列矩阵?书上p64这里不说过程了.结论是,unity中习惯把矢量转换成列矩阵,并放在矩阵的右侧进行计算. 矩阵的几何意义: 变换变换的类型线性变换可以保留矢量加和标量乘的变换.用数学公式表达即是:上面的式子很抽象.缩放就是一种线性变换.如f(x) = 2x,可以表示一个大小为2的统一缩放.旋转也是一种线性变换 对于线性变换来说,仅仅使用3X3矩阵可以表示三维坐标下的所有线性变换.线性变换除了包括旋转和缩放外,还包括错切,镜像,正交投影等. 仿射变换仅有线性变换是不够的,要考虑平移交换.如,f(x) = x + (1,0,0)这个变换就不是一个线性变换.三维坐标下,我们不能用一个3x3的矩阵来表示一个平移变换.这样,就有了仿射变换.仿射变换是合并了线性变换和平移变换的变换类型.三维空间下的仿射变换可以用一个4x4的矩阵来表示.为此,我们需要把矢量扩展到四维空间下,这就是齐 次 坐 标 空 间(homogeneous space).不知道是什么鸡儿玩意单好像以后有用的表 齐次坐标因为3X3矩阵不能表示平移,所以我们用4x4矩阵.为此,我们还需要把原来的三维矢量转换成四维矢量,也就是齐次坐标(homogeneous coordinate).对于一个点,从三维坐标转换为齐次坐标是将其w分量设为1,而对于方向矢量而言,需要把其w分量设为0.这样的设置会导致,用一个4x4矩阵对一个点进行变换的时候,平移,缩放,旋转都会被施加于该点.但是如果用于变换一个方向矢量,平移的效果就会被忽略. 分解基础变换矩阵我们可以把一个基础变换矩阵分解成4个组成部分.其中,左上角的M是一个用于旋转和缩放的三维矩阵.t表示平移.最后一行是固定的[0 0 0 1] 平移矩阵M为单位矩阵时,整个4x4矩阵只代表平移.平移矩阵的逆矩阵就是反向平移的矩阵. 缩放矩阵如果缩放系数kx = ky = kz,我们把这样的缩放称为统一缩放否则称为非统一缩放.直观上看,统一缩放就是等比缩放模型,而非统一缩放会拉伸或挤压模型.统一缩放不会改变角度和比例信息,非统一缩放会改变模型相关的角度和比例.在进行法线变换时,如果存在非统一缩放,直接用于变换顶点的变换矩阵的话,就会得到错误的结果.(正确的方法见4.7节(还没发货哦草)) 旋转矩阵按x轴旋转: 按y轴旋转 按z轴旋转 复合变换我们可以把平移,旋转,缩放结合起来,组成一个复杂的变换过程.例如,可以对一个模型先进行大小为(2, 2, 2)的缩放,再绕y轴旋转30度,最后向z轴平移4个单位.复合矩阵可以通过矩阵的串联来实现.如:需要注意的是,因为矩阵的乘法不满足交换律,变换的结果是依赖于变换顺序的.绝大多数情况下,我们约定变换的顺序是,先缩放,再旋转,最后平移.]]></content>
  </entry>
  <entry>
    <title><![CDATA[win10-Insider-Preview]]></title>
    <url>%2Fwin10-Insider-Preview%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[博客上放上live2d]]></title>
    <url>%2Fblog-live2d%2F</url>
    <content type="text"><![CDATA[很久前就看到在网站上挂个live2d,也有想法了,然而从昨晚才开始折腾.想在博客上放个舰b的live2d,结果试了好久,版本二到版本三,从民间到官方的web sdk都试了,就没有支持舰b的live2d的T_T最后妥协了下,选了有前车之鉴的药水制作师的live2d.最喜欢之前拿红宝石买来的樱花校服装了. 阿黑颜pio 参考: 猫与向日葵的博客 Cubism WebGL SDK]]></content>
      <tags>
        <tag>live2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shader学习]]></title>
    <url>%2Fshader-learning%2F</url>
    <content type="text"><![CDATA[资料 Shader编程教程-蛮牛 Unity User Manual 第一课 图形硬件简史与可编程管线课时总结 2003年开始正式进入可编程GPU阶段 GPU的并行处理能力强于CPU 目前GPU无法代替CPU 第二课 shader和渲染管线 GPU前段模块-&gt;图源装配:过去只有集成在硬件当中的顶点着色器,现在可编程 光栅化:把计算机显卡当中运算的数据进行一个细分用于适配屏幕上具体的每一个像素的显示 像素运算:光栅化不等同于像素运算.像素运算最终反映的是颜色,光栅化过后得到的结果是帧缓存.这个过程中可以加入片段着色器. Vertex Processor顶点处理程序,运算的结果将会交给像素处理器 Frame Buffer帧缓冲中容纳了是计算机依次显示所要使用的数据,但不只是屏幕上用语显示的颜色的信息,可能还有其他的附加信息.比如深度值 Transform, TexGen, Lighting Transform 模型的空间变换(针对顶点的空间几何变换) Texture Generator 纹理坐标的生成,主要用于在顶点当中取得纹理坐标,纹理坐标转化为uv取值的范围 Lighting 光照 Vertex Shader 改变上个模块的光照,变换,纹理生成等 Culling Depth Test Culling 裁剪.物体在镜头面前展示,背对摄像头的面看不到,可能就会被裁剪,不处理看不到的面的顶点数据. Depth Test 深度测试.范围超过摄像头最近或最远的渲染范围之后,也会被剔除 Texturing Fog 纹理采样.进入光栅化阶段.从纹理当中找到纹理中对应的一个点 Fragmen Shader 远处的物体可能需要雾化处理.处于片段shader的可编程范围 Alpha Test 绘制半透明或全透明物体 Blending 混合最终的图像 可编程能力是两个部分,一部分是变换和光照,使用顶点shader编写顶点着色器如何采样,计算颜色以及雾化处理等等,这部分放到片段着色器 unity当中,优化主要部分是减少游戏调用gpu渲染的调度次数.CPU搜集数据,产生GPU调度数据.这个过程是昂贵的. shader和材质,贴图的关系shader实际上是一小段程序.负责将输入的顶点数据以指定的方式和输入的贴图或者颜色组合起来然后输出.绘图单元可以依据这个输出将图像绘制到屏幕上.输入的贴图或者颜色等,加上对应的shader,以及对shader]d特定的参数设置,将这些内容(shader及输入参数)打包存储在一起.得到的就是一个Material(材质).之后我们便可以将材质赋予三维物体来渲染(输出)了. 材质好比引擎最终的商品,shader是生产这种商品的加工方法,而贴图是原材料. 课时总结 Shader是图形可编程方案的程序片段 渲染管线是一种计算机从数据到最终图形成像的形象描述 材质是商品,shader是方法,贴图是材料 第三课 shader的三大主流高级编程语言 HLSL 基于DirectX的High Level Shading Language GLSL 基于OpenGL的OpenGL Shading Language CG NVIDIA公司的C for Graphic 第四课 Unity Shader的组织形式 surface shader unity推荐和鼓励的shader.图形管线能够用于识别的,就是vertex and fragment shader.surface shader是对vertex and fragment shader的一种包装.unity最终会把surface shader编译成能被硬件识别和调用的vertex and fragment shader vertex and fragment shader fixed function shaders 固定管线的shader.Shaderlab 语法基本结构 12345678910111213141516Shader &quot;MyShader&quot; &#123; Properties &#123; _MyTexture (&quot;My Texture&quot;, 2D) = &quot;white&quot; &#123; &#125; // place other properties here, such as colors or vectors. &#125; SubShader &#123; // place the shader code here for your: // - surface shader, // - vertex and program shader, or // - fixed function shader &#125; SubShader &#123; // a simpler version of the subshader above goes here. // this version is for supporting older graphics cards. &#125;&#125; unity自带shader Unlit 不发光 VertexLit 顶点光照 Diffuse 漫反射.不仅仅在顶点上进行光照计算,在片段上进行光照计算 Normal Mapped 法线贴图.用的比较多.通过一张贴图进行采样.贴图是关于法向量存储的贴图.把这张图采样出的数据作为法向量再进行光照计算.主要目的是当几何模型面片数量,顶点数量不太多,为表达丰富的细节. Specular 高光.玻璃等 Normal Mapped Specular 高光法线贴图.较昂贵 Parallax Normal mapped 视差法线贴图 Parallax Normal mapped Specular 高光视差法线贴图 Fixed function shader固定功能的shader.功能有限但是性能很好 Surface ShaderSurface Shader无需编写pass通道]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[夏目友人帐观影]]></title>
    <url>%2Fnazume-film%2F</url>
    <content type="text"><![CDATA[听说到容莉枝不管好事还是坏事都要去那个祠堂参拜的时候,就心想着那是个树洞,结果还真是个真实树洞233 前半那个笹田演讲的时候放的BGM就是那首熟悉的ふるさとの匂い,直接掉泪 容莉枝阿姨在儿子死后的八年间没有很痛苦是很好的,穗之影做得好.真正可怜的是穗之影啊草. 看之前的剧情以为名取对夏目图谋不轨来着,这次看名取的心理活动,还是个好人.]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习unity]]></title>
    <url>%2Funity-learning%2F</url>
    <content type="text"><![CDATA[unity官方教程https://unity3d.com/cn/learn/tutorials现在在看一个beagining教程roll a ball 起步material初探新建material,选择颜色后,将material拖到gameObject上,gameObject就会变成对应的颜色 Update方法 Update方法在渲染每帧前被调用 FixedUpdate方法只有在执行有关物理计算之前才被调用 LateUpdate方法在所有Update方法执行完执行完之后执行 静态和动态GameObject静态碰撞体unity会计算场景内所有静态碰撞体的体积,并将信息保存在缓存内.因为静态碰撞体不需要移动,可以避免每帧重新计算这些信息,所以这是对的每当静态碰撞体移动 旋转或缩放时,unity会重新计算这些静态碰撞体,然后更新静态碰撞体的缓存数据 动态碰撞体重新计算缓存会耗费系统资源,但我们可以随意移动移动,旋转或缩放动态碰撞体,而且unity不会缓存他们的数据.unity会预测动态碰撞体的移动,所以在移动碰撞体之前,需要告诉unity它们是动态的.可以使用刚体组件来实现这种效果. 任何带有碰撞体和刚体组件的GameObject都会被认为是动态的.任何带有碰撞体却没有刚体组件的GameObject则被视为是静态的.刚体选中”Is Kinematic”可以将刚体变成仅受脚本控制的刚体.kinematic刚体不受无力作用力的影响,但可以播放动画或通过Transform组件移动 几何图元绘制顺序Sorting LayerSorting Layer序号越大的层越后绘制,因而会覆盖掉前面序号小的层上的几何图元表示指定层在Tags and Layers视图Sorting Layers中的顺序各层的绘制顺序是Default -&gt; Background -&gt; Character -&gt; Foreground -&gt; UI Order in layer在同一层调整几何图元的绘制深度.同样是序号大的覆盖序号小的 spirit Render组件中SortingLayer属性控制的是不同层之间的绘制顺序,而Order in Layer控制的是同层中物体的绘制顺序 spine可算知道瓜游的小人都是什么了一开始下的spine3.7,然后于是又下了3.6.卸载旧版本插件好像是直接在project里把对应的删掉目力俾斯麦蛮好玩的 U!P!D!A!T!E!写unity程序跟平常写其他程序一个很不一样的思想就是unity的每帧都会执行的update.平时写程序如果遇到时间相关的,就要考虑sleep,然后就要考虑阻塞,考虑协程或多线程.而unity不一样.利用unity的update机制可以很轻易的管理时间. Shader12345678910111213141516171819Shader "Unlit/Tutorial_Shader"&#123; // 属性块 Properties&#123; // 在属性块中，我们可以传递一些自定义数据。我们在这里声明的数据将被显示在Unity Editor面板中，在Editor中更改也会驱动脚本更改。 // 感觉类似于C#脚本里的public声明变量 &#125; SubShader&#123; // 每一个shader有一个或者多个subshaders,如果你的应用将被部署到多种平台（移动、PC、主机）,添加多个Subshader是非常有用的。例如：你可能想要写为PC/Desktop写一个高质量的Subshader,为移动端写一个低质量,但速度更快的Subshader. // 每个Subshader至少有一个pass语句块，它实际上是对象渲染的位置。一些特效要求有多个pass语句块，目前，我们仅仅专注于一个。 pass&#123; CGPROGRAM // 我们实际写的所有Shader代码都在CGPROGRAM和ENDCG中 ENDCG &#125; &#125;&#125; 蛋疼md写shader真蛋疼,啥时候需要分号啥时候不需要啊草草草]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试笔记]]></title>
    <url>%2Fnote-interview%2F</url>
    <content type="text"><![CDATA[位运算可以节约传输和储存的空间 unity，c#，lua，opengl，渲染]]></content>
  </entry>
  <entry>
    <title><![CDATA[加了几个音乐收藏夹]]></title>
    <url>%2FmusicFavorites%2F</url>
    <content type="text"><![CDATA[想着给把最喜欢,最常听的几首歌按风格分类,造了这么几个歌单 治愈 爱 静谧 朝气蓬勃 优美忧伤 对这些歌写点东西治愈urar很美好. 蝴蝶泉边同样很美好很温馨,更加了点回忆的感觉 Growing!就是让人撒娇的歌 爱Letter动画HandShaker的BGM中听到的.前面一段代表书信的常规内容,后面深深的感情喷涌而出.不像小情侣之间的爱,像是老夫老妻或者亲情的爱这封Letter不像情书而是像家书 LuvLetter情书.写情书和纠结要不要将情书送出去的过程,理解的是纠结着很痛苦然后没能送出去.中间有纠结的痛苦,也有想象的美好结局. 恋日推给我的,高潮部分很好听 愛唄当初看一个高木同学的AMV注意到的,很真情实感 小小恋歌同样是高木同学ed收录的当初觉得高桥李依版本的好听,比较甜美来着,后来还是觉得新垣结衣唱的好听,捎带沙哑点的声音很温柔很知性 さよならの夏啊 静谧Mountain stream高中时候学校就经常放的 陽だまり道とれんちょん悠哉日常大王的BGM ふるさとの匂い夏目友人帐的BGM 朝气蓬勃RYDEEN朝气蓬勃 优美忧伤おうちに帰りたいちいさな冒険者素晴的ed. Arrietty’s Song借东西的小人阿莉埃蒂的主题曲 春よ、来い看了一个潮学视频知道的…着实很好听 この感情は使命island的曲子 さよならの夏啊]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python多重继承init的问题]]></title>
    <url>%2Fpython-mult-inherit-init%2F</url>
    <content type="text"><![CDATA[继承的时候,init父类时,平时用ide写代码习惯了这样写,因为敲一个super再回车就有了这么一行1super(C, self).__init__() 12345678910111213141516class A: def __init__(self): self.a = "a" class B: def __init__(self): self.b = "b"class C(A,B): def __init__(self): super(C, self).__init__()if __name__ == '__main__': c = C() print(c.__dict__) # &gt;&gt;&gt; &#123;'a': 'a'&#125; 可以看出问题了,C类只init了A类,并没有init B类下面是我瞎摸出来的解决方法 1234567891011121314151617181920class A: def __init__(self): self.a = "a"class B: def __init__(self): self.b = "b"class C(A, B): def __init__(self): A.__init__(self) B.__init__(self)if __name__ == '__main__': c = C() print(c.__dict__) # &gt;&gt;&gt; &#123;'a': 'a', 'b': 'b'&#125;]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome插件踩坑]]></title>
    <url>%2Fchrome-crx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[自动玩瓜游连连看的脚本]]></title>
    <url>%2Fazurlane-llk%2F</url>
    <content type="text"><![CDATA[做了个自动玩连连看的脚本.github : https://github.com/HHHHhgqcdxhg/azurlane-linkup 图片整理将原图整理成以下格式 原图: 整理出: 1234567[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 16. 2. 4. 1. 3. 1. 2. 17. 3. 0.] [ 0. 8. 7. 14. 4. 10. 12. 18. 5. 5. 0.] [ 0. 6. 6. 9. 15. 7. 11. 8. 9. 10. 0.] [ 0. 11. 12. 13. 13. 14. 15. 16. 17. 18. 0.] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] #这个二维数组是抽象的连连看"地图",将原连连看相同的图片换成同样的数字,在在周围填充0表示通路 和12[[1, 6], [1, 4], [1, 7], [1, 2], [1, 9], [1, 5], [2, 4], [1, 3], [2, 9], [2, 8], [3, 2], [3, 1], [3, 5], [2, 2], [3, 7], [2, 1], [3, 8], [3, 3], [3, 9], [2, 5], [4, 1], [3, 6], [4, 2], [2, 6], [4, 4], [4, 3], [4, 5], [2, 3], [4, 6], [3, 4], [4, 7], [1, 1], [4, 8], [1, 8], [4, 9], [2, 7]]# 这个数组每一项表示一组坐标,并且第 2 * i 个元素代表的图片和第 2 * i + 1 个元素代表的图片相同 求解算法广度优先暴搜,搜索所有可以到达的图片块,判断目标是否在其中.代码在源码中的findLineFetch方法和pointSearch方法,注释还写的蛮详细的,这里不再解释. 实行点击:跟上次的翻牌游戏脚本差不多 结果7.80s视频: av450629917.80s留了视频,有一个7.27s的没录好…追求极致的话应该能跑进7秒内,说不定能跑进6秒内,我做不到一定是因为我太菜了 时间浪费 截图耗时 因为开局前截图会有数字遮挡,所以等数字消完,再进行截图.因为有一些IO操作,所以就很慢… 算法耗时 嘛,我这个算法是广度优先暴搜,应该比较慢. 点击间隔不统一 ↑这个形容不是很准确.好像,当两个有效的点被点击时,如果距离比较近,下次可以点击的时间间隔就比较短,反之亦然.只是推测,不太确定.因为试的时候,经常前面好多都没事,最后两三组点的时候出错,怀疑是排到最后的组一般距离比较远导致的结果.]]></content>
      <tags>
        <tag>碧蓝航线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plus Ultra!]]></title>
    <url>%2Fbokuhiro-movie%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>动漫</tag>
        <tag>我的英雄学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线翻牌小游戏复现]]></title>
    <url>%2Fblhx-fanpai%2F</url>
    <content type="text"><![CDATA[git repo:https://github.com/HHHHhgqcdxhg/azurlane-fanpai已部署在:https://blog.purecucumber.club/azurlane-fanpai/dist/index.html 一下午撸出来的web复现的碧蓝航线翻牌小游戏.一路写下来没遇到坑,但也没考虑性能.]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩游戏 还愿]]></title>
    <url>%2Fdevotion%2F</url>
    <content type="text"><![CDATA[真的吓人…变写博客边玩吧. 游戏过程 小女孩透过墙洞看爸爸撕写的字…想了想,以后写代码错到恼羞成怒了也只注释不删 弹珠迷宫真是绝了 被老婆追杀那里吓坏了.用手挡住屏幕看不到主要画面,然后一直都不知道要转头跑…回头翻了别人的视频才知道要跑… 拔舌头那里真心不敢看…依旧拿手遮屏幕 评价第一次玩恐怖游戏来着,因为跟风就去玩了,吓得不轻.还是不喜欢这种,为恐怖而恐怖的游戏.里面的一些价值观也不认同. 凉凉2019年2月23日更新自断财路的傻逼玩意]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win32按键码]]></title>
    <url>%2Fvkcode%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147VK_CODE = &#123; 'backspace': 0x08, 'tab': 0x09, 'clear': 0x0C, 'enter': 0x0D, 'shift': 0x10, 'ctrl': 0x11, 'alt': 0x12, 'pause': 0x13, 'caps_lock': 0x14, 'esc': 0x1B, 'spacebar': 0x20, 'page_up': 0x21, 'page_down': 0x22, 'end': 0x23, 'home': 0x24, 'left_arrow': 0x25, 'up_arrow': 0x26, 'right_arrow': 0x27, 'down_arrow': 0x28, 'select': 0x29, 'print': 0x2A, 'execute': 0x2B, 'print_screen': 0x2C, 'ins': 0x2D, 'del': 0x2E, 'help': 0x2F, '0': 0x30, '1': 0x31, '2': 0x32, '3': 0x33, '4': 0x34, '5': 0x35, '6': 0x36, '7': 0x37, '8': 0x38, '9': 0x39, 'a': 0x41, 'b': 0x42, 'c': 0x43, 'd': 0x44, 'e': 0x45, 'f': 0x46, 'g': 0x47, 'h': 0x48, 'i': 0x49, 'j': 0x4A, 'k': 0x4B, 'l': 0x4C, 'm': 0x4D, 'n': 0x4E, 'o': 0x4F, 'p': 0x50, 'q': 0x51, 'r': 0x52, 's': 0x53, 't': 0x54, 'u': 0x55, 'v': 0x56, 'w': 0x57, 'x': 0x58, 'y': 0x59, 'z': 0x5A, 'numpad_0': 0x60, 'numpad_1': 0x61, 'numpad_2': 0x62, 'numpad_3': 0x63, 'numpad_4': 0x64, 'numpad_5': 0x65, 'numpad_6': 0x66, 'numpad_7': 0x67, 'numpad_8': 0x68, 'numpad_9': 0x69, 'multiply_key': 0x6A, 'add_key': 0x6B, 'separator_key': 0x6C, 'subtract_key': 0x6D, 'decimal_key': 0x6E, 'divide_key': 0x6F, 'F1': 0x70, 'F2': 0x71, 'F3': 0x72, 'F4': 0x73, 'F5': 0x74, 'F6': 0x75, 'F7': 0x76, 'F8': 0x77, 'F9': 0x78, 'F10': 0x79, 'F11': 0x7A, 'F12': 0x7B, 'F13': 0x7C, 'F14': 0x7D, 'F15': 0x7E, 'F16': 0x7F, 'F17': 0x80, 'F18': 0x81, 'F19': 0x82, 'F20': 0x83, 'F21': 0x84, 'F22': 0x85, 'F23': 0x86, 'F24': 0x87, 'num_lock': 0x90, 'scroll_lock': 0x91, 'left_shift': 0xA0, 'right_shift ': 0xA1, 'left_control': 0xA2, 'right_control': 0xA3, 'left_menu': 0xA4, 'right_menu': 0xA5, 'browser_back': 0xA6, 'browser_forward': 0xA7, 'browser_refresh': 0xA8, 'browser_stop': 0xA9, 'browser_search': 0xAA, 'browser_favorites': 0xAB, 'browser_start_and_home': 0xAC, 'volume_mute': 0xAD, 'volume_Down': 0xAE, 'volume_up': 0xAF, 'next_track': 0xB0, 'previous_track': 0xB1, 'stop_media': 0xB2, 'play/pause_media': 0xB3, 'start_mail': 0xB4, 'select_media': 0xB5, 'start_application_1': 0xB6, 'start_application_2': 0xB7, 'attn_key': 0xF6, 'crsel_key': 0xF7, 'exsel_key': 0xF8, 'play_key': 0xFA, 'zoom_key': 0xFB, 'clear_key': 0xFE, '+': 0xBB, ',': 0xBC, '-': 0xBD, '.': 0xBE, '/': 0xBF, ';': 0xBA, '[': 0xDB, '\\': 0xDC, ']': 0xDD, "'": 0xDE, "`": 0xC0&#125; win32按键码.留着一份省着每次再找了]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线翻牌游戏脚本]]></title>
    <url>%2Fblhx-fanpai4-45%2F</url>
    <content type="text"><![CDATA[匹配相同的牌时是裁下每张牌后,直接对比每张图片的数组是否相同翻牌的时候想要同时点两张牌,但是查了下adb好像没有支持mult touch,然后想到在模拟器上给每个牌的位置设置快捷键,翻牌的时候调用win32api点击对应的快捷键来翻牌.最终成绩4.45秒.b站视频:https://www.bilibili.com/video/av44287472/ 下面是完整代码.其中vkcode.VK_CODE是win32按键码映射表,在这篇博客有82~89行那些几个sleep的参数是试出来的,再小就容易出错了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#! /usr/bin/env python# -*- coding: utf-8 -*-import timeimport osimport cv2import numpy as npimport win32apiimport win32confrom vkcode import VK_CODEclass Blhx: def __init__(self, adbPATH, sharedPATH): self.adb = adbPATH self.sharedPATH = sharedPATH def getScreen(self, filePath="/sdcard/Pictures/tmp.png"): os.system(f"&#123;self.adb&#125; -e shell screencap -p &#123;filePath&#125;") time.sleep(0.5) return cv2.imread(f"&#123;self.sharedPATH&#125;\\tmp.png") def tap(self, X, Y): os.system(f"&#123;self.adb&#125; -e shell input tap &#123;X&#125; &#123;Y&#125;") def cutEvery(self, img): ims = [] matched = [] for y in range(3): for x in range(6): startX = 148 * x + 238 startY = 162 * y + 179 endX = startX + 90 endY = startY + 129 im = img[startY:endY, startX:endX, :] thisImInfo = (y, x, im) hasmatch = False for i, imgInfo in enumerate(ims): difference = cv2.subtract(im, imgInfo[2]) result = not np.any(difference) if result: hasmatch = True matched.append(imgInfo[:2]) matched.append(thisImInfo[:2]) del ims[i] continue if not hasmatch: ims.append(thisImInfo) return matchedkeyboardsMap = [ "QWERTY".lower(), "ASDFGH".lower(), "ZXCVBN".lower()]def mian(): blhx = Blhx(r"E:\programfiles\adb\adb.exe", "J:\ldmnqshare") blhx.tap(800, 485) time.sleep(1.1) print("jietu") im = blhx.getScreen() pos = blhx.cutEvery(im) ks = [] for i, p in enumerate(pos): k = keyboardsMap[p[0]][p[1]] ks.append(k) kl = ks.__len__() if not kl == 18: print("没匹配好") return time.sleep(1) for x in range(9): k0 = 2 * x k1 = k0 + 1 kNode0 = ks[k0] kNode1 = ks[k1] win32api.keybd_event(VK_CODE[kNode0], 0, 0, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode1], 0, 0, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode0], 0, win32con.KEYEVENTF_KEYUP, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode1], 0, win32con.KEYEVENTF_KEYUP, 0) print("tap") time.sleep(0.375)if __name__ == '__main__': mian()]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cuclasses]]></title>
    <url>%2FCuclasses%2F</url>
    <content type="text"><![CDATA[介绍Cuclasses是我正在写的python库,内容是集合了一些常用的类和方法 项目地址pypi(少有更新):https://pypi.org/project/cuclasses/github:https://github.com/HHHHhgqcdxhg/cuclasses 模块cuclasses.DottableDict顾名思义,能用 “.” 访问的dict.因为喜欢js访问对象属性的方式,可以用下标,也可以用点. cuclasses.singleton装饰器.被装饰的类为单例模式 cuclasses.CallableDict可以调用的dict,调用时返回自身. cuclasses.StrKeyDict在查询时把非字符串键转换为字符串的dict cuclasses.headerCopy2Dict因为在复制chrome开发者工具network里请求的header时很不方便,就弄了这个…把chrome里的headers复制进去,会转换成字典 123456789101112headerStr = """Accept: application/json, text/plain, */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-aliveCookie: l=v; buvid3=08DBF55E-086D-4BE2-9FCB-4B60BFA5F05A140254infocHost: message.bilibili.comOrigin: https://www.bilibili.comReferer: https://www.bilibili.com/video/av9912938/?p=11User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"""a = headerCopy2Dict(headerStr)print(a)#&gt;&gt;&gt; &#123;'Accept': 'application/json, text/plain, */*', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Host': 'message.bilibili.com', 'Origin': 'https://www.bilibili.com', 'Referer': 'https://www.bilibili.com/video/av9912938/?p=11', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125; cuclasses.timePrint上下文管理器.带时间戳的print.随时可指定时间格式 12345678910111213141516with timePrint() as print: print(0) # &gt;&gt;&gt; [2019-02-10 16:23:35] 0 print(1, strf="[%Y-%m-%d %H:%M:%S]1") # &gt;&gt;&gt; [2019-02-10 16:23:35]1 1with timePrint("[%Y-%m-%d %H:%M:%S]2") as print: print(2) # &gt;&gt;&gt; [2019-02-10 16:23:35]2 2 print(3, strf="[%Y-%m-%d %H:%M:%S]3") # &gt;&gt;&gt; [2019-02-10 16:23:35]3 3print(4)# &gt;&gt;&gt; 4 cuclasses.timeCount装饰器.接受两个参数.被装饰的函数将在执行后打印执行时间 12:param enable: 设为False则不计时,直接执行函数:param method: 可选择的计时所用的获取时间的函数.默认time.perf_counter,或者也可以选填time.time,python3.7可以按需选用time.perf_counter_ns 1234567@timeCount()def bar(): print(&#123;"a": "c"&#125;)bar()#&gt;&gt;&gt; &#123;'a': 'c'&#125;#&gt;&gt;&gt; func bar excuted in : 6.044444444444444e-05 cuclasses.Downloader下载器. 1234:param directory:下载到的目录:param urls:需要下载的资源目录:param threads:并行下载的线程数:param headers:请求头,默认为&#123;&quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;&#125; with open("xx.json","r") as f: data = json.load(f) d = Downloader(directory=r"E:\ACG\comic\general\どうして私が美術科に",urls=data) d.downloadAll()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站的搭建]]></title>
    <url>%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[依赖本博客基于Hexo生成,选用Next.Mixins作为主题 正文主题不是很喜欢黑黑的颜色,就把css里颜色改了改,改成了蓝色的主题 写作工具VSC + MPE写md不要太爽(atom,sublime应该一样) 图床图床用的是七牛云上传图片至图床的工具是PicGo,同样不要太爽现在是vs-picgo了,爽上加爽 deploy不是很清楚hexo clean和hexo generate的关系,索性每次deploy的时候都先hexo clean再hexo g再hexo d.因为很麻烦,就写了段C++做成个exe int main() { system("hexo clean"); system("hexo g"); system("hexo d"); return 0; } 之后就把编译出来的exe命名为d.exe放到项目根目录,之后每次deploy就./d就完事了 评论之前选用的livere,现在换成了Valine]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ｆｔｐ 三 次 握 手]]></title>
    <url>%2FsomeFTP%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>无厘头</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[azurlane-painting开发笔记]]></title>
    <url>%2Fazurlane-painting%2F</url>
    <content type="text"><![CDATA[dalao的开发过程 我的开发过程 repo : https://github.com/HHHHhgqcdxhg/azurlane-painting图片处理过程: 将图片缩小 -&gt; 将图片色彩聚类到16色 -&gt; 将聚类后的16色归到舰b指定的8色 -&gt; 合成画板图片]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bilibili机器人更新日志]]></title>
    <url>%2Fbili-bot-release-log%2F</url>
    <content type="text"><![CDATA[19/02/18 取消对以关键字”【お知らせ”开头的推特的图片打水印(那个图太小了) 19/02/07 取消对以关键字”【接続障害”开头的推特的转推(即日服服务器故障和故障修复的推文) 19/01/27 增加图片水印 18/12/24 修复IOS端点开大图一直正在加载的问题 18/12/21 自动在回复中发送机翻 18/12/20 取消对以关键字”【メンテナンス”开头的推特的转推(即日服维护说明) 18/12/19 䒕黃苽机器人开始运行]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>bot</tag>
        <tag>bilibot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[䒕黃苽B博碧蓝航线日推转发机器人README]]></title>
    <url>%2Fbili-bot-help%2F</url>
    <content type="text"><![CDATA[00010100101还什么都没有哦~]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>bot</tag>
        <tag>bilibot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小黄瓜机器人使用指南]]></title>
    <url>%2Fbot-help%2F</url>
    <content type="text"><![CDATA[介绍小黄瓜机器人QQ:2482513293想要自己的群拥有小黄瓜的话不用打招呼,直接拉就好哦小黄瓜详细功能列表见下文所有可能烦人的功能都是可以群管理发送指令开启/关闭的想要做一个跟小黄瓜类似的机器人,可以跳转至技术相关 加群准则因为加群太多会使服务器负担太大,所以会控制加群数量.不乐意加入的群: 人数比较少的群.因为百十个人及以下的群难以保证管理和群员的素质 不感兴趣的群.舰b群和kirara fantasia群以外的邀请不出意外应该不会接受 功能列表:1. 无指令功能:点击功能跳转到对应位置 功能 机器人需要管理权限 控制开关 转发推特功能 否 !tweetConfig指令 复读机随机禁言功能 ==是== !fuduBanConfig指令 新人入群提醒功能 否 !welcomeConfig指令 2. 指令功能:指令功能是通过发送以感叹号开始的指令触发的功能,中文或英文感叹号均可,无视大小写.点击功能跳转到对应位置 指令 功能 机器人需要管理权限 限管理可用 控制开关 !help 帮助功能 否 否 无 !fuck 众裁功能 ==是== 否 指令 !sleep 金质睡眠功能 ==是== 否 指令 !del 定时撤回消息功能 ==是== 否 指令 !recipe 获取一份假的食谱功能 否 否 指令 !build 碧蓝航线建造模拟器 否 否 指令 !tweetConfig 设置转发推特的功能 否 ==是== 无 !enable 开启功能的功能 否 ==是== 无 !disable 关闭功能的功能 否 ==是== 无 !report 联系主人功能 否 ==是== 无 功能详情新人入群提醒功能!welcomeConfig指令限管理可用 有新人入群时,小黄瓜机器人将@新人,发送入群提醒管理可通过发送 !welcomeConfig + 内容 来指定入群提醒内容如:12!welcomeConfig欢迎加入善良可爱小海豹保护者协会群!请先阅读群置顶公告哦! 注: 设置的入群提醒不宜太长,避免刷屏.建议提醒阅读群公告,内容写在群公告即可 设置的入群提醒中的图片将被忽略 !welcomeConfig后不跟内容,将取消入群提醒 复读功能通过指令开/关功能 小黄瓜检测到有人在复读,就会跟着复读因不堪网络暴力机器人发消息太多会被腾讯制裁,本功能停止使用 复读机随机禁言功能!fuduBanConfig指令限管理可用 | 机器人需要管理权限 管理可通过发送类似下面的消息,更改禁言复读机配置1234567!fuduBanConfig&#123; &quot;banLen&quot;: 2, &quot;banMult&quot;: 10, &quot;banRebel&quot;: false, &quot;randMemberMode&quot;: 2, &quot;randTimeMode&quot;: 3&#125; 对配置的解释如下: 字段名描述可选值对应效果banLen触发复读禁言条数&gt;= 2复读条数(算上 被复读的那一条) 大于等于 这个值时,触发复读禁言banMult禁言力度&gt;= 1控制禁言时长的力度banRebel是否开启禁言复读机叛徒true此时,如果是参与复读的人打断复读,则不再进行复读机随机抽取,而是直接抽中这名复读机叛徒false正常进行复读机抽取randMemberMode抽取复读机的模式0关闭本功能,不再禁言复读机1随机抽取一名复读机2正态分布随机抽取一名复读机3取倒数第二个复读机randTimeMode抽取禁言时长的模式1经典随机,禁言时间为 (1~本轮复读条数 之间的随机数) banMult2复读总长相关,禁言时间为 本轮复读条数 banMult3固定时长,禁言时长为 banMult4按座位,被抽到的复读机在本轮复读中是倒数第n个,时长就为 n * banMult 众裁功能本功能为指令功能,通过发送 !fuck + @一名群员 触发 通过指令开/关功能 | 机器人需要管理权限 在一人通过该指令开启对一名群员A的众裁之后,将开始三分钟的计时,统计三分钟内通过该指令参与对群员A的众裁的人数,于三分钟后对群员A进行制裁(禁言)禁言时长: 参与本轮众裁人数 禁言时长(分钟) &lt;= 2 不禁言 3 5 4 10 >= 5 每多一人,时长加2 注: !fuck后面跟上@一名群员,这个@必须是能@到人的,复制粘贴的不管用 不要重复参与众裁,否则会被禁言1分钟 不要再众裁群主管理辣! 不要欺负人哦,拿来制裁海豹正适合 定时撤回消息功能本功能为指令功能,通过发送 !del + 时长 + 空格 + 消息 触发 通过指令开/关功能 | 机器人需要管理权限 示例:1!del 10 这条消息将在10秒后被撤回 注: 如 !del 后不加时长,直接跟消息,则默认撤回时长为5秒 如设置时长,记得时长数字和后面消息中间用空格分隔 设置时长最大为600,超过这个值将改为5 本功能为限 非管理群员 使用 金质睡眠功能本功能为指令功能,通过发送 !sleep 触发 通过指令开/关功能 | 机器人需要管理权限 22:00~次日03:59发送指令,发送者将被禁言6小时 食谱功能本功能为指令功能,通过发送 !recipe 或 !gbf触发 通过指令开/关功能 | 消耗黄瓜片 : 20 发送一份分享,标题和图片为随机食谱的标题和图片,点开却是granbluefantasy.jp 碧蓝航线建造模拟器本功能为指令功能,通过发送 !build 触发 通过指令开/关功能 | 消耗黄瓜片 : 40 !build可接受最多两个正整数参数,用逗号分隔(中英文标点均可) 指令 效果 !build 抽取1池10次 !build x 抽取x池10次,x可为1,2,3 !build x,y 抽取x池y次,y为1~10 注: 概率保证按照官方给出的概率 卡池信息来自碧蓝航线wiki建造模拟器 不准备做限时建造的卡池,想玩的请移步碧蓝航线wiki限时建造模拟器 本功能需要生成图片发送图片,对服务器资源消耗过大,不要玩太过分哦 转发推特功能!tweetConfig指令限管理可用小黄瓜会实时(Real Time)转发指定推特用户发送的新推特至qq群新加的群是不会转发推特的,需要经过设置后,可转发指定推特设置方法:发送类似如下的消息,可添加或修改推特转发: 12345678910111213!tweetConfig&#123; &quot;follow&quot;:&#123; &quot;name&quot;:&quot;@azurlane_staff&quot;, &quot;nickName&quot;:&quot;碧蓝航线日服推特&quot; &#125;, &quot;groupInfo&quot;: &#123; &quot;nickName&quot;: &quot;在这里填写群名&quot;, &quot;trans&quot;: false, &quot;sendRT&quot;: false, &quot;mediaOnly&quot;:false, &quot;follow&quot;: true &#125;&#125; 以下为对上面配置的解释:12345678910111213!tweetConfig&#123; &quot;follow&quot;:&#123; &quot;name&quot;:&quot;这里填入需要关注的人的推特Id,以@开头&quot;, &quot;nickName&quot;:&quot;这里填入关注的人的称呼&quot; &#125;, &quot;groupInfo&quot;: &#123; &quot;nickName&quot;: &quot;群名&quot;, //在这里填写群名,理论上随便填,主要目的是让作者辨识出是哪个群 &quot;trans&quot;: true, //是否需要发送一遍将经过百度翻译的推文,把true改成false将不翻译 &quot;sendRT&quot;: false, //是否需要发送 转发和回复别人的推特,建议关闭,打开很烦人的,把false改成true打开 &quot;mediaOnly&quot;: false, //将false改成true,将只发有图片内容的推特,纯文字推特将忽略,适合关注画师 &quot;follow&quot;: true //将true改为false,将不转发此人的推特 &#125;&#125; 注意: 这条消息除开头的!tweetConfig以外,全部大小写敏感且必须用半角标点符号(即英文标点) 大括号,冒号,逗号,引号都不能漏 不要将true打成ture,false打成flase… 若出现”查找用户信息失败”提示,请确定关注的人的id以@符号开头,确认无误后稍后再试 小黄瓜机器人定时每周四取消对 只有一个群关注的推特 的关注 附录中给出了些常用推特供参考 开启功能的功能本功能为指令功能,通过发送 !enable + 其他功能指令 触发 限管理可用 指令 功能 !enable !sleep 开启金质睡眠功能 !enable !fuck 开启众裁功能 !enable !recipe 开启食谱功能 !enable !build 开启碧蓝航线建造模拟器 !enable !del 关闭定时撤回消息功能 注:无视所有感叹号全/半角,不区分大小写 关闭功能的功能本功能为指令功能,通过发送 !disable + 其他功能指令 触发 限管理可用 指令 功能 !disable !sleep 关闭金质睡眠功能 !disable !fuck 关闭众裁功能 !disable !recipe 关闭食谱功能 !disable !build 关闭碧蓝航线建造模拟器 !disable !del 关闭定时撤回消息功能 注:无视所有感叹号全/半角,不区分大小写 联系主人功能本功能为指令功能,通过发送 !report 触发 !report指令限管理可用机器人接收到以!report开头的消息,会发送给主人看到注: 乱玩此功能会打扰到主人的,请不要乱玩 机器人功能相关请先仔细阅读本篇文档对应部分 在群里直接@小黄瓜机器人,主人一般情况下看不到的 私聊小黄瓜机器人,主人一般情况下看不到 使用!report指令的消息,主人会看到,并尽量及时回应 按照下面联系方式联系主人,是比较有效的联系方式 有事请直接说事,免掉”在吗”之类的打招呼内容 谢绝无事骚扰 &nbsp;&nbsp;&nbsp;ex. 不过如果你有色图,请务必私发给䒕黃苽机器人 主人QQ:2894700792 加好友的认证信息请认真填写 黄瓜片系统出于目的: 防止功能滥用对小黄瓜服务器造成太大负担 防止某些功能造成刷屏 防止被tx限制 现在实装黄瓜片系统,某些功能需要消耗黄瓜片(黄瓜片就是类似体力的东西啦) 获得黄瓜片小黄瓜机器人会在每天凌晨04:30,中午13:30,晚上19:30将所有群友的黄瓜片置为40点.即,黄瓜片不可积攒,每个时间段40点 消耗黄瓜片消耗黄瓜片的功能 功能 消耗黄瓜片数/次 碧蓝航线建造模拟器 40 食谱功能 20 其他小黄瓜机器人的管理权限给小黄瓜管理权限后,机器人并不能马上意识到自己是管理,需要重启插件,这时通过联系主人功能告知重启 限管理可用功能本文中的”管理”,皆指 管理or群主把部分功能做成仅限管理可用,目的是过滤掉没素质的人,希望身为管理能意识到自己的一份素质,不要闲来无事report玩,或者凭一己之见关注一些奇怪或无聊的推特 idea相关有觉得好玩的机器人的玩法的想法,可以联系主人哦 技术相关因为小黄瓜机器人项目中有很多小黄瓜的apikey和OAuth认证信息,开源很麻烦,所以闭源小黄瓜机器人项目代码是使用python编写,通过richardchien/coolq-http-api和richardchien/python-aiocqhttp控制酷Q实现的,监听新推特是通过tweepy.StreamListener实现酷Q只能跑在windows或有图形界面的linux服务器上,本人使用的服务器是阿里云服务器的学生机 其他的䒕黃苽 䒕黃苽bilibili机器人:@碧蓝航线转推姬会将碧蓝航线新日推转发到B站动态,并在评论区附上翻译䒕黃苽B博机器人介绍 䒕黃苽微博机器人:@碧蓝航线转推姬(和B站的同名哦)会将碧蓝航线新日推转发到微博 其他相关希望群友们素质聊天 投喂喜欢小黄瓜机器人的话可以支付宝投喂哦 免费红包哦 打赏¥1 打赏¥3 打赏¥10 打赏一单 每天都能扫一次哦 老冰棍 快乐水 一餐饭 老婆 附录:常用推特id 推特id 备注 @korindo 博丽神主推特 @kirarafantasia 芳文社手游きららファンタジア官推 @azurlane_staff 碧蓝航线日服官推 @azurlanekorea 碧蓝航线韩服官推 @AzurLane_EN 碧蓝航线美服官推 @KanColle_STAFF 「艦これ」開発/運営 @fgoproject FGO官推 @granbluefantasy 学习资料]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>qqbot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python程序打包成exe]]></title>
    <url>%2Fpy2exe%2F</url>
    <content type="text"><![CDATA[前言用python写了个项目(在这)想发布出去给没有python环境的人用.试了pyinstaller,打包出来不能正常跑…于是心生淫技,将python环境跟项目放到一起,然后拿C++写几行程序,通过system call的方式调用python运行项目脚本,再将这个C++程序编译成exe… python环境的准备我首先试了拿虚拟环境,然后发现虚拟环境少了一堆dll…拿自己的python环境吧,一堆这个项目用不着的库,打包进去太大,挑出来太麻烦…索性另外装一个python.我本身环境是3.6.7版本的,又去另外装了个3.7.2版本.安装时注意把什么设置环境变量,向所有用户安装都取消了,留着pip就好,之后拿pip把包都装好,然后把整个python目录拷贝到项目根目录就完事了 准备一个exe这就比较野蛮…程序入口12345678910111213141516171819202122```C++#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;direct.h&gt; using namespace std;int main(int argc, char * argv[])&#123; string cwd = _getcwd(NULL, 0); string cmd = &quot;\\Python37-32\\python.exe __main__.py&quot;; cmd = cwd + cmd; for (int i = 1; i &lt; argc; i++) &#123; cmd += &quot; &quot;; cmd += argv[i]; &#125; const char *cmd_c_str = cmd.c_str(); // cout &lt;&lt; cmd_c_str&lt;&lt;endl; system(cmd_c_str); //system(&quot;pause&quot;); return 0;&#125; 编译好拿出来放到项目根目录就完事了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桌面追番助手]]></title>
    <url>%2FbangumiDesktopAssistant%2F</url>
    <content type="text"><![CDATA[本项目git仓库:https://dev.tencent.com/u/hhhhhg/p/bangumiDesktopAssistant尝试了打包成exe却做不到,所以应该只有装了python才能用了XDpython版本是3.6.4(因为用到了f前缀字符串,所以大概需要至少3.6版本),操作系统只试了windows 使用:1234git clone https://git.dev.tencent.com/hhhhhg/bangumiDesktopAssistant.gitcd bangumiDesktopAssistantpip install -r requirements.txtpython __main__.py 在任务栏找到图标(和项目头像是同一张图片),右键可进行追番编辑或者退出程序.追番编辑工具按要求填入信息,可生成一份番剧信息,保存在src/db/bangumisInfo中,如果填入得当,不发生意外,则可正常使用.遇到特殊情况(比如番剧停更)则需要手动改对应的json文件中的chapters部分… 有番剧更新时,会播放音频,为src/audio/alarm.wav透明度,配色等配置存在src/db/config.json中,可以轻易更改 配置好环境后,之后可以运行bangumi.bat来运行本工具,也可在注册表中将bangumi.bat设为开机自启运行截图: 1080p屏幕下unfocused状态表现 1080p屏幕下focused状态(鼠标悬停在之上时)表现 之前用tkinter写了两天了,察觉有点不好用,又换成了PyQt5.耗资源方面,平常在后台运行就占用十几二十M内存]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gui</tag>
        <tag>动漫</tag>
      </tags>
  </entry>
</search>
