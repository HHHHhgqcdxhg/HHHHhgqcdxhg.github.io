<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《shader入门精要》-第五章-开始Unity Shader学习之旅]]></title>
    <url>%2Fshader-r-start%2F</url>
    <content type="text"><![CDATA[最简单的顶点/片元着色器顶点/片元着色器的基本结构12345678910111213141516171819202122232425262728293031323334Shader "MyShaderName"&#123; Properties&#123; // 属性 &#125; SubShader&#123; // 针对显卡A的SubShader Pass&#123; // 设置渲染状态和标签 // 开始Cg代码片段 CGPROGRAM // 该代码片段的编译指令 #pragma vertex vert #pragma fragment frag // Cg代码写在这里 // 结束Cg代码段 ENDCG // 其他设置 &#125; // 其他需要的Pass &#125; SubShader&#123; // 针对显卡B的SubShader &#125; // 上面的SubShader都失败后用于回调的Unity Shader Fallback "VertexLit"&#125; 其中最重要的是Pass语义块.我们绝大多数的代码都是写在Pass语义块中的.下面是一个实际的最简单的顶点/片段着色器 12345678910111213141516171819202122Shader "Custom/myShader"&#123; SubShader&#123; Pass&#123; CGPROGRAM // 告诉unity,vert函数包含了顶点着色器代码,frag函数包含了片段着色器代码. #pragma vertex vert #pragma fragment frag float4 vert(float4 v : POSITION) : SV_POSITION &#123; return mul(UNITY_MATRIX_MVP, v); // MVP矩阵是: 当前的模型矩阵·观察矩阵·投影矩阵,用于将顶点/方向矢量从模型空间变换到剪裁空间 &#125; fixed4 frag() : SV_Target&#123; return fixed4(1.0, 1.0, 1.0, 1.0); &#125; ENDCG &#125; &#125;&#125; vert函数里的POSITION和SV_POSITION都是Cg/HLSL中的语义(semantics),是不可省略的,它们告诉系统用户需要哪些输入值,以及用户的输出是什么.例如这里:POSITION告诉Unity,把模型顶点坐标填充到参数vSV_POSITION告诉Unity,顶点着色器的输出是剪裁空间中的顶点坐标如果没有这些语义来限定输入和输出参数的话,渲染器就完全不知道用户的输入和输出是什么,因此会得到错误的结果. 本例中的frag函数没有任何输入,它的输出是一个fixed4类型的变量,并且使用了SV_Target语音进行限定.SV_Targrt也是HLSL中的一个系统语义,它等同于告诉渲染器,把用户的输出颜色存储到一个渲染目标(render target)中,这里将输出到默认的帧缓存中. 模型数据从哪来如想要得到更多的模型数据(如顶点的纹理坐标和法线方向),我们需要为顶点着色器定义一个结构体作为输入参数. 1234567891011121314151617181920212223242526272829303132333435Shader "Custom/MyShader"&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag // 使用一个结构体来定义顶点着色器的输入 struct a2v&#123; // POSITION语义告诉Unity, 用模型空间的顶点坐标填充vertex变量 float4 vertex : POSITION; // NORMAL语义告诉Unity, 用模型空间的法线方向填充normal变量 float3 normal : NORMAL; // TEXCOORD0语义告诉Unity, 用模型的第一套纹理坐标填充texcoord变量 float4 texcoord : TEXCOORD0; &#125;; float4 vert(a2v v) : SV_POSITION&#123; // 使用v.vertex来访问模型空间的顶点坐标 return mul(UNITY_MATRIX_MVP, v.vertex); &#125; fixed4 frag() : SV_Target&#123; return fixed4(1.0, 1.0, 1.0, 1.0); &#125; ENDCG &#125; &#125;&#125; 在上面的代码中,我们声明了一个新的结构体a2v,它包含了顶点着色器需要的模型数据.对于顶点着色器的输入,Unity支持的语义有: POSITION, TANGENT, NORMAL, TEXCOORD0, TEXCOORD1, TEXCOORD2, TEXCOORD3, COLOR 等. 为了新建一个结构体, 我们必须使用如下格式来定义它: 12345struct StructName&#123; Type Name : Semantic; Type Name : Semantic; ......&#125; 然后,我们又修改了vert函数的输入类型为a2v. a表示应用(application),v表示顶点着色器(vertex shader),a2v的意思就是把数据从应用阶段传递到顶点着色器中. 顶点着色器和片元着色器的通信]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第三章-Unity Shader 基础]]></title>
    <url>%2Fshader-r-unity-shader%2F</url>
    <content type="text"><![CDATA[UnityShader概述unity中的shaderStandard Surface Shader会产生一个包含了标准光照模型(使用了Unity5中新添加的基于物理的渲染方法,详见第18章)的表面着色器模板 Unlit Shader会产生一个不含光照(单包含雾化效果)的基本顶点/片段着色器 ImageEffect Shader为我们实现各种屏幕文件.这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算,而不在这本书的讨论范围内(草) UnityShader的结构SubShaderSubshader中定义了一系列的Pass一级可选的状态和标签的设置. 每个Pass定义了一次完整的渲染流程,但如果pass的数目过多,往往会造成渲染性能的下降.因此,我们应尽量使用小数目的Pass. 状态和标签同样可以在Pass声明.不同的是,SubShader中的一些标签设定是特定的.也就是说,这些标签设置和Pass中使用的标签是不一样的.而对于状态设置来说,其使用的语法是相同的.但是,如果我们在SubShader中进行了这些设置,那么将会用于所有Pass 状态设置ShaderLab提供了一系列渲染状态的设置指令,这些指令可以设置显卡的各种状态.例如是否开启混合/深度测试等. 状态名称 设置指令 解释 Cull Cull Back/Front/Off 设置剔除模式.剔除背面/正面/关闭剔除 ZTest ZTest Less Greater/LEqual/GEqual/NotEqual/Always 设置深度测试时使用的函数 Zwrite ZWrite On/Off 开启/关闭深度测试 Blend Blend SrcFactor DstFactor 开启并设置混合模式 当在SubShader块中设置了这些渲染状态时,将会应用到所有Pass,如果我们不想这样,可以在Pass语义块中单独进行上面的设置. SubShader标签SubShader的标签是一个键值对,他的键和值都是字符串类型.标签结构如下: 1Tags &#123; &quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; &#125; 标签类型 说明 例子 Queue 控制渲染顺序,指定该物体属于哪一个渲染队列,通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染(详见第8章).我们也可以自定义使用的渲染队列来控制物体的渲染顺序 Tags { “Queue” = “Transparent” } RenderType 对着色器进行分类,例如这是一个不透明的着色器,或是一个透明的着色器.这可以用于着色器替换功能(啥玩意) Tags { “RenderType” = “Opaque” } DisableBatching 一些SubShader在使用Unity批处理功能时会出现问题,例如使用了模型空间下的坐标进行顶点动画(详见第11.3节).这时可以通过该标签来指明是否对该SubShader使用批处理. Tags { “DisableBatching” = “True” } ForceNoShadowCasting 控制使用该SubShader的物体是否会投射阴影(详见8.4)节 Tags { “ForceNoShadowCasting” = “True” } IgnoreProjector 如果该标签设置为True,那么使用该SubShader的物体不会受到projector的影响.通常用于半透明物体. Tags { “IgnoreProjector” = “True” } CanUseSpriteAtlas 当该SubShader是用于精灵时,将该标签设为False Tags { “CanUseSpriteAtlas” = “False” } PreviewType 指名材质面板将如何预览该材质.默认情况下,材质将显示为一个球形.我们可以通过将该标签的值设为”Plane” “SkyBox”来改变预览类型. Tags { “PreviewType” = “Plane” } Pass语义块Pass语义块包含的语义如下 12345Pass &#123; [Name] [Tags] // Other Code&#125; 首先,我们可以在Pass中定义该Pass的名称,例如 1Name &quot;MyPassName&quot; 通过这个名称,我们可以使用Shader的UsePass命令来直接使用其他UnityShader中的Pass.例如: 1UsePass &quot;MyShader/MYPASSNAME&quot; 这样可以提高代码的复用性.需要注意的是,由于Unity内部会把所有Pass的名字转换成大写字母的表示,因此在使用UsePass命令时必须使用大写的名字. Pass同样可以设置标签,但它的标签不同于SubShader标签.这些标签也是告诉渲染引擎我们希望怎么来渲染该物体. 标签类型 说明 例子 LightMode 定义该Pass在Unity的渲染管线中的角色 Tags { “LightMode” = “ForwardBase” } RequiresOptions 用于指定当满足某些条件时才渲染该Pass,它的值是一个由空格分隔的字符串.目前,Unity支持的选项有: SoftVegetation. 在后面的版本中,可能会增加更多的选项. Tags{ “RequireOption” = “SoftVegetation” } 除了上面的普通Pass定义外,Unity Shader还支持一些特殊的Pass, 以便进行代码复用或实现更复杂的效果. UsePass 如之前所说,可以引入其他Unity Shader中的Pass. GrabPass 负责抓取屏幕并将结果存储在一张纹理中,以用于后续的Pass处理(详见10.2.2节)FallBack 1234FallBack &quot;name&quot;FallBack OffFallBack &quot;VertexLit&quot; 事实上,FallBack还会影响阴影的投射.在渲染阴影纹理时,Unity会在每个UnityShader中寻找一个阴影投射的Pass.通常情况下,我们不用自己专门实现一个阴影投射的Pass,这是因为FallBack使用内置Shader中包含了这样一个通用Pass. 因此,为每个UnityShader设置正确的FallBack是非常重要的. UnityShader的形式尽管UnityShader可以做的事情非常多(如设置渲染状态等),但其最重要的任务还是指定各种着色器所需的代码.这些着色器代码可以写在Shader语义块中(表面着色器的做法),也可以写在Pass语义块中(顶点/片元着色器和固定函数着色器的做法). 表面着色器Surface Shader是Unity自己创造的一种着色器代码类型.它需要的代码量很少,Unity在背后做了很多工作,单渲染代价比较大.当给Unity提供一个表面着色器的时候,它在背后仍旧会将它转换成对应飞顶点/片元着色器. 它存在的价值在于,Unity为我们处理了很多光照细节,使得我们不需要再操心这些烦人的事情.一个非常简单的表面着色器示例代码: 12345678910111213141516Shader &quot;Custom/sur&quot;&#123; SubShader&#123; Tags &#123;&quot;RenderType&quot; = &quot;Opaque&quot;&#125; CGPROGRAM #pragma surface surf Lambert struct Input &#123; float4 color:COLOR; &#125;; void surf(Input In, inout SurfaceOutput o) &#123; o.Albedo = 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 上述程序可以看出,表面着色器被定义在SubShader语义块(而非Pass语义块)中的CGPROGRAM和ENDCG之间.原因是,表面着色器不需要关心开发者使用多少个Pass,每个Pass如何渲染等问题,Unity会在背后去帮我们做好这些事情.我们要做的只是告诉它,”用这些纹理去填充颜色,用这个法线纹理去填充法线,使用Lambert光照模型” CGPROGRAM和ENDCG之间的代码是使用Cg/HLSL编写的,也就是说,我们需要把Cg/HLSL语言嵌套在ShaderLab中.值得注意的是,这里的Cg/HLSL是Unity经过封装后提供的,它的标准语法和标准的Cg/HLSL几乎一样,但还是有细微不同.例如有些原生的函数和用法Unity并没有提供支持. 顶点/片元着色器Vertex/Fragment Shader更加复杂,但灵活性更高. 123456789101112131415161718192021Shader &quot;Custom/vertexfragment&quot;&#123; SubShader&#123; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v : position) : SV_POSITION&#123; return mul(UNITY_MATRIX_MVP, v); &#125; float4 frag() : SV_Target&#123; return fixed4(1.0,0.0,0.0,1.0); &#125; ENDCG &#125; &#125;&#125; 和表面着色器类似,顶点/片元着色器的代码也需要定义在CGPROGRAM和ENDCG中间.但不同的是,顶点/片元着色器是写在Pass语义块中的,而非SubShader语义块内.原因是我们需要自己定义每个Pass需要使用的Shader代码.虽然我们可能需要编写更多的代码,但带来的好处是灵活性很高.更重要的是,我们可以控制渲染的实现细节. 固定函数着色器Fixed Function Shader弃子,现在不怎么用的着色器上面两种着色器都是用了可编程管线.而对于一些较旧的设备,它们不支持可编程管线着色器,因此,我们就需要使用固定函数着色器.这些着色器往往只能完成一些非常简单的效果]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第二章-渲染流水线]]></title>
    <url>%2Fshader-r-lsx%2F</url>
    <content type="text"><![CDATA[看完数学部分后再来写的 CPU流水线将数据加载到显存中 把渲染所需所有数据从硬盘加载到系统内存中 网格和纹理等数据又被加载到显存中设置渲染状态这些状态定义了场景中的网格是怎么被渲染的例如,使用哪个顶点着色器/片元着色器,光源属性,材质等.如果我们没有设置渲染状态,那么所有网格都将使用同一种渲染状态 调用DrawCallDraw Call是一个命令,发起方是CPU,接收方是GPU.这个命令仅仅会指向一个需要被渲染的图元的列表,而不再包含任何材质信息–因为已经在上个阶段完成了. 当给定一个Draw Call时,GPU会根据渲染状态(材质,纹理,着色器等)和所有输入的顶点数据来进行计算,最终输出到屏幕 GPU流水线顶点数据 -&gt; 顶点着色器 -&gt; 曲面细分着色器 -&gt; 几何着色器 -&gt; 裁剪 -&gt; 屏幕映射 -&gt; 三角形设置 -&gt; 三角形遍历 -&gt; 片元着色器 -&gt; 逐片元操作 -&gt; 屏幕图像 顶点着色器顶点无法销毁或创建顶点,也不可以获得顶点之间的联系.例如,我们无法判断两个顶点是否处于同一个网格.正是因为这样的相互独立性,GPU可以利用本身的特性并行化处理每一个顶点,这意味着这一阶段的处理速度会更快.顶点着色器需要完成的主要工作有:坐标变换和逐顶点光照当然除了这两个主要任务外,顶点着色器还可以输出后续阶段所需的数据. 坐标变换把顶点坐标从模型空间变换到齐次剪裁空间 剪裁摄像机的视野范围内很有可能不会覆盖场景中的所有物体.不在摄像机视野范围内的物体不需要处理.剪裁就是为了完成这个目标而被提出来的. 我们无法通过编程来控制剪裁的过程,而是硬件上的固定操作,但我们可以自定义一个剪裁操作来对这一步进行配置. 屏幕映射屏幕映射的任务是把每个图元的x,y坐标转换到屏幕坐标系. 三角形设置从这一步开始进入光栅化阶段.从上一个阶段输出的信息是屏幕坐标系下的顶点位置以及它们的额外信息,如深度值(z坐标),法线方向,视角方向等.光栅化阶段有两个最重要的目标:计算每个图元覆盖了哪些像素,以及为这些像素计算它们的颜色. 三角形设置阶段会计算光栅化一个三角网格所需的信息.具体来说,上个阶段输出的都是三角网格顶点.但如果要得到整个三角网格对像素覆盖的情况,我们就必须计算每条边上的像素坐标.为了能够计算边界像素的坐标信息,我们就需要得到三角形边界的表达方式.这样一个计算三角形网格表示数据的过程就叫做三角形设置.它的输出是为了给下一步做准备. 三角形遍历三角形遍历阶段会检查每个像素是否被一个三角网格所覆盖.如果被覆盖的话,就生成一个片元而这个找到哪些像素被三角网格覆盖的过程就是三角形遍历,这个阶段也被称为扫描变换. 三角形遍历会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素,并使用三角网格三个顶点的顶点信息对整个覆盖区域的像素进行插值. 这一步的输出就是得到一个片元序列.需要注意的是,一个片元并不是真正意义上的像素,而是包含了很多状态的集合,这些状态用于计算每个像素的最终颜色这些状态包括了(但不限于)它的屏幕坐标,深度信息,以及其他从几何阶段输出的顶点信息,如法线,纹理坐标等. 片元着色器前面的光栅化操作并不会影响屏幕上每个像素的颜色值,而是会产生一系列的数据信息,来描述一个三角网格是怎样覆盖每个像素的.而片元就是负责存储这样一系列数据.真正会对像素产生影响的是下一个阶段–逐片元操作 片元着色器的输入是上一个阶段对顶点信息插值得到的结果.更具体来说,是根据那些从顶点着色器中输出的数据差值得到的.它的输出是一个或多个颜色值. 这一阶段可以完成很多重要的渲染技术,其中最重要的技术之一是纹理采样.为了在片元着色器中进行纹理采样,我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标然后经过光栅化阶段对三角形网格的三个顶点对应的纹理坐标进行插值后,就可以得到其覆盖片元的纹理坐标了. 片元着色器的局限在于,它仅可影响单个片元.也就是说,在执行片元着色器时,它不可以将自己的任何结果发送给它的邻居们.有一个情况例外,就是片元着色器可以访问到导数信息(扩展阅读)(smjb) 逐片元操作也被称为输出合并阶段这一阶段的几个重要任务: 决定每个片元的可见性. 这涉及很多测试工作,如深度测试,模板测试等 合并 如果一个片元通过了所以测试,就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行混合 逐片元操作是高度可配置的.即我们可以设置每一步的操作细节.]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bili-api]]></title>
    <url>%2Fbili-api%2F</url>
    <content type="text"><![CDATA[url 描述 https://api.bilibili.com/x/relation/stat?vmid={uid} up粉丝数 https://api.bilibili.com/x/space/upstat?mid={uid} 观看量 https://api.bilibili.com/x/space/navnum?mid={uid} 投稿数量 https://api.bilibili.com/x/space/acc/info?mid={uid} 基本信息 https://api.bilibili.com/x/space/masterpiece?vmid={uid} 代表作]]></content>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第四章-数学基础]]></title>
    <url>%2Fshader-r-math%2F</url>
    <content type="text"><![CDATA[《shader入门精要》免费的第四章pdf 点和矢量点积(内积)和叉积(外积)内积Shader代码中使用dot(a,b)来进行矢量的点积运算. 1a·b = (a x , a y , a z ) ·(b x , b y , b z ) = a x b x + a y b y + a z b z 满足交换律和结合律.使用: 投影 单位矢量a,和一个长度不限制的矢量b,dot(a,b)得到b在a方向上带有符号的投影 外积外积的结果时矢量,并非标量. 1a X b = (a x , a y , a z ) X (b x , b y , b z ) = (a y b z - a z b y , a z b x - a x b z , a x b y - a y b x ) 例如:(1, 2, 3) X (−2, −1, 4) = ((2)(4) − (3)(−1), (3)(−2) − (1)(4), (1)(−1) − (2)(−2))= (8 − (−3), (−6) − 4, (−1) − (−4)) = (11, −10, 3)外积不满足交换律,即a X b不等于b X a.然而外积满足反交换律,即a X b = -(b X a)外积不满足结合律. 矩阵(matrix)矩阵运算矩阵乘法 矩阵乘法不满足交换律 AB不等于BA 矩阵乘法满足结合律 (AB)C = A(BC) shader中主要使用4x4矩阵来运算. 特殊矩阵方块矩阵(方阵)行和列数目相等的矩阵.三维渲染里,用的最多的是3x3和4x4的方阵 单位矩阵用In来表示.比如I3是3x3的单位矩阵. 转置矩阵transposed matrix转置矩阵实际是对原矩阵的一种运算,即转置运算.给定一个rXc的矩阵M,他的转置可以表示为MT(T为上标)(辣鸡MD).数学公式是:例如: 转置矩阵性质: 转置矩阵的转置等于原矩阵(废话) 矩阵的串接转置等于反向串接各个矩阵的转置 即: 逆矩阵给定一个矩阵M,用M-1(-1为上标)表示M的逆矩阵.MM-1为单位矩阵 矩阵可逆的条件: 矩阵为方块矩阵 矩阵的行列式不为零 虽说在学数学…但是也是shader开发里的数学…还是不去回忆具体怎么求逆矩阵了,交给程序去做=v= 逆矩阵的性质 逆矩阵的逆矩阵等于原矩阵 单位矩阵的逆矩阵是其本身 转置矩阵的逆矩阵等于逆矩阵的转置 即: 矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵 即: 正交矩阵蒸饺正交是矩阵的一种属性.如果一个方阵M和它的转置矩阵的乘积是单位矩阵的话,我们说这个矩阵是正交的即: 行矩阵or列矩阵?书上p64这里不说过程了.结论是,unity中习惯把矢量转换成列矩阵,并放在矩阵的右侧进行计算. 矩阵的几何意义: 变换变换的类型线性变换可以保留矢量加和标量乘的变换.用数学公式表达即是:上面的式子很抽象.缩放就是一种线性变换.如f(x) = 2x,可以表示一个大小为2的统一缩放.旋转也是一种线性变换 对于线性变换来说,仅仅使用3X3矩阵可以表示三维坐标下的所有线性变换.线性变换除了包括旋转和缩放外,还包括错切,镜像,正交投影等. 仿射变换仅有线性变换是不够的,要考虑平移交换.如,f(x) = x + (1,0,0)这个变换就不是一个线性变换.三维坐标下,我们不能用一个3x3的矩阵来表示一个平移变换.这样,就有了仿射变换.仿射变换是合并了线性变换和平移变换的变换类型.三维空间下的仿射变换可以用一个4x4的矩阵来表示.为此,我们需要把矢量扩展到四维空间下,这就是齐 次 坐 标 空 间(homogeneous space).不知道是什么鸡儿玩意单好像以后有用的表 齐次坐标因为3X3矩阵不能表示平移,所以我们用4x4矩阵.为此,我们还需要把原来的三维矢量转换成四维矢量,也就是齐次坐标(homogeneous coordinate).对于一个点,从三维坐标转换为齐次坐标是将其w分量设为1,而对于方向矢量而言,需要把其w分量设为0.这样的设置会导致,用一个4x4矩阵对一个点进行变换的时候,平移,缩放,旋转都会被施加于该点.但是如果用于变换一个方向矢量,平移的效果就会被忽略. 分解基础变换矩阵我们可以把一个基础变换矩阵分解成4个组成部分.其中,左上角的M是一个用于旋转和缩放的三维矩阵.t表示平移.最后一行是固定的[0 0 0 1] 平移矩阵M为单位矩阵时,整个4x4矩阵只代表平移.平移矩阵的逆矩阵就是反向平移的矩阵. 缩放矩阵如果缩放系数kx = ky = kz,我们把这样的缩放称为统一缩放否则称为非统一缩放.直观上看,统一缩放就是等比缩放模型,而非统一缩放会拉伸或挤压模型.统一缩放不会改变角度和比例信息,非统一缩放会改变模型相关的角度和比例.在进行法线变换时,如果存在非统一缩放,直接用于变换顶点的变换矩阵的话,就会得到错误的结果.(正确的方法见4.7节(还没发货哦草)) 旋转矩阵按x轴旋转: 按y轴旋转 按z轴旋转 复合变换我们可以把平移,旋转,缩放结合起来,组成一个复杂的变换过程.例如,可以对一个模型先进行大小为(2, 2, 2)的缩放,再绕y轴旋转30度,最后向z轴平移4个单位.复合矩阵可以通过矩阵的串联来实现.如:需要注意的是,因为矩阵的乘法不满足交换律,变换的结果是依赖于变换顺序的.绝大多数情况下,我们约定变换的顺序是,先缩放,再旋转,最后平移. 坐标空间模型空间也称对象空间或局部空间. 世界空间最外层的坐标空间 观察空间也称为摄像机空间Unity中观察空间的+x轴指右方,+y轴指向上方,+z轴指向摄像机的后方—-Unity在模型空间和世界空间选用的是左手坐标系,而观察者空间选用右手坐标系. 观察空间和屏幕空间是不同的.观察空间是一个三维空间,而屏幕空间是一个二维空间.从观察空间到屏幕空间需要一个投影(projection)转换. 顶点变换的第二步,就是将顶点坐标从世界空间变换到观察空间.这个变换通常叫做观察变换. 剪裁空间顶点接下来要从观察者空间转换到剪裁空间(clip space,也被称为齐次裁剪空间)中,这个用于变换的举证叫做裁剪矩阵(clip matrix),也被称为投影矩阵(projection matrix).剪裁空间的目标是能够方便地对渲染图元进行裁剪.完全位于这块空间内部的图元将会被保留,完全处于这块空间外部的图元将会被剔除,而与这块空间边界相交的图元就会被裁剪.这块空间是由视锥体(view frustum)决定的. 视锥体指的是空间中的一块区域,这块区域决定了摄像机可以看到的空间.视锥体由留个平面包围而成,这些平面被称为裁剪平面(clip planes).视锥体有两种类型,这涉及两种投影类型—-一种是正交投影(orthographic projection),一种是透视投影(perspective projection)透视投影会有远小近大. 在视锥体的6块裁剪平面中,有两块裁剪平面比较特殊,分别是近剪裁平面(near clip plane)和远剪裁平面(far clip plane).它们决定了摄像机可以看到的深度范围.我们通过一种通用,简洁的方式进行剪裁工作,这种方式是通过一个投影矩阵把顶点转换到一个剪裁空间中.投影矩阵有两个目的: 首先是为投影做准备.这是个迷惑点,虽然投影矩阵包含了投影二字,但是它并没有进行真正的投影工作,而是在为投影做准备.真正的投影发生在后面的齐次排除法(homogeneous division)过程中.而经过投影矩阵变换后,顶点的w分量将会具有特殊意义. 其次是对x,y,z分量进行缩放.经过投影矩阵的缩放以后,我们可以直接使用w分量作为一个范围值,如x,y,z都在这个范围内,就说明该顶点位于剪裁空间内. 1.透视投影视锥体的六个剪裁平面是由Camera组件中的参数和Game视图的横纵比共同决定的.如图所示,我们可以通过Camera组件的Field of View(简称FOV)属性来改变视锥体竖直张开的角度,而Cliping Planes中的Near和Far属性可以控制视锥体的近剪裁平面和远剪裁平面距离摄像机的远近.这样,我们可以求出视锥体近剪裁平面和远剪裁平面的高度.一个摄像机的横纵比由Game视图的横纵比和Viewport Rect中的W和H属性共同决定.假设,当前摄像机的横纵比是Aspect:现在,我们可以根据已知的Near,Far,FOV和Aspect的值来确定透视投影的投影矩阵.推导见本章的扩展阅读部分一个顶点和上面的投影矩阵相乘后,可以由观察者空间变换到剪裁空间.从结果可以看出来,投影矩阵的本质是对x,y,z分量做了不同的缩放(z分量还做了一个平移).缩放的目的是为了方便裁剪.可以注意到,此时顶点的w分量不再是1,而是原先z分量的取反.现在,我们就可以按如下不等式判断一个变换后的顶点是否位于视锥体内.如果一个顶点在视锥体内,那么它变换后的坐标必须满足: -w &lt;= x &lt;= w -w &lt;= y &lt;= w -w &lt;= z &lt;= w 任何不满足上述条件的图元都需要被剔除或者裁剪.通过此图还可以注意到,剪裁矩阵会改变空间的旋向性:空间从右手坐标系变换到了左手坐标系. 2. 正交投影和透视投影类似,在unity中,正交投影的六个人裁剪平面是由Camera组件中的参数和Game视图的横纵比共同决定的.由图看出,我们可以通过Camera组件的Size属性来改变视锥体竖直方向上的高度的一半,而Clipping Planes中的Near和Far参数可以控制视锥体的近剪裁平面和远剪裁平面距离摄像机的远近.这样,我们可以求出视锥体近剪裁平面和远剪裁平面的高度.即:同样,我们可以通过摄像机的横纵比得到横向信息.假设当前摄像机的横纵比为Aspect: 现在我们根据已知的Near,Far,Size和Aspect的值来确定正交投影的裁剪矩阵.如下:推导见本章的扩展阅读一个顶点和上述投影矩阵相乘后的结果如下:注意到,和透视投影不同,使用正交投影的投影矩阵对顶点变换后,其分量w依然为1.本质是因为投影矩阵最后一行的不同,透视投影的投影矩阵的最后一行是[0 0 -1 0],而正交投影的投影矩阵最后一行是[0 0 0 1].这样选择是为了为齐次除法做准备(具体在下面讲到) 判断一个变换后的顶点是否位于视锥体内使用的不等式和透视投影的一样. 同样,裁剪矩阵改变了空间的旋向性.可以注意到,经过正交投影变换后的顶点实际已经位于一个立方体内了. 屏幕空间经过了投影矩阵的变换后,我们可以进行剪裁工作.当完成了所有的剪裁工作后,就需要进行真正的投影了.也就是说,我们需要把视锥体投影到屏幕空间(screen space)中.经过这一步变换,我们会得到真正的像素位置,二非虚拟的三维坐标. 屏幕空间是一个二维空间,因此我们需要把顶点从剪裁空间投影到屏幕空间,来生成对应的2D坐标.这个过程分为两个步骤 首先,我们要进行标准齐次除法(homogeneous division),也被称为透视除法(perspective division).虽然这个步骤听起来陌生,但它实际上非常简单,就是用齐次坐标系的w分量去除以x,y,z分量.在OpenGL中,我们把这一步得到的坐标叫做归一化的设备坐标(Normalized Device Coordinate, NDC).经过这一步,我们可以把坐标从齐次剪裁坐标空间转换到NDC中.经过透视投影变换后的剪裁空间,经过齐次除法后会变换到一个立方体内. 对于透视投影 对于正交投影 经过齐次除法后,透视投影的剪裁空间会变换到一个立方体 对于正交投影来说,它的剪裁空间实际已经是一个立方体了,而且由于经过正交投影矩阵变换后的顶点的w分量是1,因此齐次除法并不会对顶点的x,y,z坐标产生影响 经过齐次除法后,透视投影和正交投影的视锥体都变换到一个相同的立方体内.现在,我们可以根据变换后的x,y坐标来映射输出窗口的对应像素坐标.这个映射的过程是一个缩放的过程.齐次除法和屏幕映射的过程可以用下面的公式总结:上面式子对x和y分量进行了处理,而z分量会被用于深度缓冲.一个传统的方式是把clip z / clip w的值直接存进深度缓冲中,但这不是必须的.通常驱动的生产商会根据硬件来选择最好的存储格式.此时clip w也并未抛弃,虽然它已经完成了它的主要工作–在齐次除法中作为分母来得到NDC,但它仍然会在后续的一些工作中起到重要作用.例如进行透视矫正差值(草,这又是什么玩意) 在Unity中,从剪裁空间到屏幕空间的转换是底层帮我们完成的.我们的顶点着色器只需要把顶点转换到剪裁空间即可. 总结以上就是一个顶点如何从模型空间最终转换到屏幕空间的全过程. 顶点着色器的最基本的任务是把顶点坐标从模型空间转换到剪裁空间中.这对应了上图中的前三个顶点变换过程.而在片元着色器中,我们通常也可以得到该片元在屏幕空间的像素信息.我们会在4.9.3节中看到如何得到这些像素位置. 在Unity中,坐标系的旋向性也随着发生了改变.只有在观察空间使用了右手坐标系. 需要注意的是,这里仅仅给出的是一些最重要的坐标空间.还有一些空间在实际开发中也会遇到,如切线空间(tangent space).切线空间通常用于法线映射. 法线变换法线(normal),也被称为法矢量(normal vector).在游戏中,模型的一个顶点往往会携带额外的信息,而顶点法线就是其中的一种信息.当我们变换一个模型的时候,不仅要变换它的顶点,还需要变换它的法线,以便在后续的处理(如片元着色器)中计算光照等.玛德这块数学公式太多了md不要表达,反正本来的这块内容就没多少去书上看吧. Unity Shader的内置变量(数学篇)变换矩阵这里是Unity5.2版本提供的所有内置变换矩阵.所有矩阵都是float4x4的. 变量名 描述 _Object2World 当前的模型矩阵,用于将顶点/方向矢量从模型空间变换到世界空间 _World2Object _Object2World的逆矩阵.用于将顶点/方向矢量从世界空间变换到模型空间 UNITY_MATRIX_V 当前的观察矩阵,用于将顶点/方向矢量从世界空间变换到观察空间 UNITY_MATRIX_P 当前的投影矩阵,用于将顶点/方向矢量从观察空间变换到剪裁空间 UNITY_MATRIX_MV 当前的模型矩阵·观察矩阵,用于将顶点/方向矢量从模型空间变换到观察空间 UNITY_MATRIX_VP 当前的观察矩阵·投影矩阵,用于将顶点/方向矢量从世界空间转换到剪裁空间 UNITY_MATRIX_MVP 当前的模型矩阵·观察矩阵·投影矩阵,用于将顶点/方向矢量从模型空间变换到剪裁空间 UNITY_MATRIX_T_MV UNITY_MATRIX_MV的转置矩阵 UNITY_MATRIX_IT_MV UNITY_MATRIX_MV的逆转置矩阵,用于将法线从模型空间变换到世界观察空间,也可用于得到UNITY_MATRIX_MV的逆矩阵 UNITY_MATRIX_T_MV这个矩阵比较特殊.对于正交矩阵来说,它的逆矩阵就是转置矩阵.因此,如果UNITY_MATRIX_MV是一个正交矩阵的话,那么UNITY_MATRIX_T_MV就是它的逆矩阵,也就是说,我们可以使用UNITY_MATRIX_T_MV将顶点/方向矢量从观察空间变换到模型空间 UNITY_MATRIX_IT_MV这个矩阵也要特殊说明一下.法线的变换需要使用原变换矩阵的逆转矩阵,因此UNITY_MATRIX_IT_MV可以把发现从模型空间变换到观察者空间.而且,只需要对它进行转置,就可以得到UNITY_MATRIX_MV的逆矩阵因此,为了把顶点或法线矢量从观察者空间变换到模型空间,我们可以使用以下代码: 12345// 方法一: 使用transpose函数对UNITY_MATRIX_IT_MV进行转置,得到UNITY_MATRIX_MV的逆矩阵,然后进行列矩阵乘法,把观察空间中的点或方向矢量变换到模型空间中 float4 modelPos = mul(transpose(UNITY_MATRIX_IT_MV), viewPos);// 方法二: 不直接使用转置函数transpose, 而是交换mul参数的位置,使用行矩阵乘法. 本质是一样的.float4 modelPos = mul(viewPos, UNITY_MATRIX_IT_MV); 摄像机和屏幕参数Unity提供了一些内置变量来让我们访问当前正在渲染的摄像机的参数信息.这些参数对应了摄像机上的Camera组件中的属性值. 变量名 类型 描述 _WorldSpaceCameraPos float3 该摄像机在世界空间中的位置 _ProjectionParams float4 x = 1.0(或-1.0, 如果正在使用一个翻转的投影矩阵进行渲染), y = Near, z = Far, w = 1.0 + 1.0/Far _ScreenParams float4 x = wodth, y = height, z = 1.0 + 1.0/width, w = 1.0 + 1.0/height _ZBufferParams float4 x = 1 - Far/Near, y = Far/Near, z = x/Far, w = y/Far, 该变量用于线性化Z缓存中的深度值(可参考13.1节) unity_OrthoParams float4 x = width, y = height,z没有定义,w = 1.0(该摄像机是正交摄像机),或w = 0.0(该摄像机是透视摄像机) unity_CameraProjectio float4x4 该摄像机的投影矩阵 unity_CameraInvProjection float4x4 该摄像机的投影矩阵的逆矩阵 unity_CameraWorldClipPlanes[6] float4 该摄像机的6个裁剪平面在世界空间下是等式.按如下顺序:左,右,下,上,近,远裁剪平面]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10-Insider-Preview]]></title>
    <url>%2Fwin10-Insider-Preview%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[博客上放上live2d]]></title>
    <url>%2Fblog-live2d%2F</url>
    <content type="text"><![CDATA[很久前就看到在网站上挂个live2d,也有想法了,然而从昨晚才开始折腾.想在博客上放个舰b的live2d,结果试了好久,版本二到版本三,从民间到官方的web sdk都试了,就没有支持舰b的live2d的T_T最后妥协了下,选了有前车之鉴的药水制作师的live2d.最喜欢之前拿红宝石买来的樱花校服装了. 阿黑颜pio 参考: 猫与向日葵的博客 Cubism WebGL SDK]]></content>
      <tags>
        <tag>live2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shader学习]]></title>
    <url>%2Fshader-learning%2F</url>
    <content type="text"><![CDATA[资料 Shader编程教程-蛮牛 Unity User Manual 第一课 图形硬件简史与可编程管线课时总结 2003年开始正式进入可编程GPU阶段 GPU的并行处理能力强于CPU 目前GPU无法代替CPU 第二课 shader和渲染管线 GPU前段模块-&gt;图源装配:过去只有集成在硬件当中的顶点着色器,现在可编程 光栅化:把计算机显卡当中运算的数据进行一个细分用于适配屏幕上具体的每一个像素的显示 像素运算:光栅化不等同于像素运算.像素运算最终反映的是颜色,光栅化过后得到的结果是帧缓存.这个过程中可以加入片段着色器. Vertex Processor顶点处理程序,运算的结果将会交给像素处理器 Frame Buffer帧缓冲中容纳了是计算机依次显示所要使用的数据,但不只是屏幕上用语显示的颜色的信息,可能还有其他的附加信息.比如深度值 Transform, TexGen, Lighting Transform 模型的空间变换(针对顶点的空间几何变换) Texture Generator 纹理坐标的生成,主要用于在顶点当中取得纹理坐标,纹理坐标转化为uv取值的范围 Lighting 光照 Vertex Shader 改变上个模块的光照,变换,纹理生成等 Culling Depth Test Culling 裁剪.物体在镜头面前展示,背对摄像头的面看不到,可能就会被裁剪,不处理看不到的面的顶点数据. Depth Test 深度测试.范围超过摄像头最近或最远的渲染范围之后,也会被剔除 Texturing Fog 纹理采样.进入光栅化阶段.从纹理当中找到纹理中对应的一个点 Fragmen Shader 远处的物体可能需要雾化处理.处于片段shader的可编程范围 Alpha Test 绘制半透明或全透明物体 Blending 混合最终的图像 可编程能力是两个部分,一部分是变换和光照,使用顶点shader编写顶点着色器如何采样,计算颜色以及雾化处理等等,这部分放到片段着色器 unity当中,优化主要部分是减少游戏调用gpu渲染的调度次数.CPU搜集数据,产生GPU调度数据.这个过程是昂贵的. shader和材质,贴图的关系shader实际上是一小段程序.负责将输入的顶点数据以指定的方式和输入的贴图或者颜色组合起来然后输出.绘图单元可以依据这个输出将图像绘制到屏幕上.输入的贴图或者颜色等,加上对应的shader,以及对shader]d特定的参数设置,将这些内容(shader及输入参数)打包存储在一起.得到的就是一个Material(材质).之后我们便可以将材质赋予三维物体来渲染(输出)了. 材质好比引擎最终的商品,shader是生产这种商品的加工方法,而贴图是原材料. 课时总结 Shader是图形可编程方案的程序片段 渲染管线是一种计算机从数据到最终图形成像的形象描述 材质是商品,shader是方法,贴图是材料 第三课 shader的三大主流高级编程语言 HLSL 基于DirectX的High Level Shading Language GLSL 基于OpenGL的OpenGL Shading Language CG NVIDIA公司的C for Graphic 第四课 Unity Shader的组织形式 surface shader unity推荐和鼓励的shader.图形管线能够用于识别的,就是vertex and fragment shader.surface shader是对vertex and fragment shader的一种包装.unity最终会把surface shader编译成能被硬件识别和调用的vertex and fragment shader vertex and fragment shader fixed function shaders 固定管线的shader.Shaderlab 语法基本结构 12345678910111213141516Shader &quot;MyShader&quot; &#123; Properties &#123; _MyTexture (&quot;My Texture&quot;, 2D) = &quot;white&quot; &#123; &#125; // place other properties here, such as colors or vectors. &#125; SubShader &#123; // place the shader code here for your: // - surface shader, // - vertex and program shader, or // - fixed function shader &#125; SubShader &#123; // a simpler version of the subshader above goes here. // this version is for supporting older graphics cards. &#125;&#125; unity自带shader Unlit 不发光 VertexLit 顶点光照 Diffuse 漫反射.不仅仅在顶点上进行光照计算,在片段上进行光照计算 Normal Mapped 法线贴图.用的比较多.通过一张贴图进行采样.贴图是关于法向量存储的贴图.把这张图采样出的数据作为法向量再进行光照计算.主要目的是当几何模型面片数量,顶点数量不太多,为表达丰富的细节. Specular 高光.玻璃等 Normal Mapped Specular 高光法线贴图.较昂贵 Parallax Normal mapped 视差法线贴图 Parallax Normal mapped Specular 高光视差法线贴图 Fixed function shader固定功能的shader.功能有限但是性能很好 Surface ShaderSurface Shader无需编写pass通道]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[夏目友人帐观影]]></title>
    <url>%2Fnazume-film%2F</url>
    <content type="text"><![CDATA[听说到容莉枝不管好事还是坏事都要去那个祠堂参拜的时候,就心想着那是个树洞,结果还真是个真实树洞233 前半那个笹田演讲的时候放的BGM就是那首熟悉的ふるさとの匂い,直接掉泪 容莉枝阿姨在儿子死后的八年间没有很痛苦是很好的,穗之影做得好.真正可怜的是穗之影啊草. 看之前的剧情以为名取对夏目图谋不轨来着,这次看名取的心理活动,还是个好人.]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习unity]]></title>
    <url>%2Funity-learning%2F</url>
    <content type="text"><![CDATA[unity官方教程https://unity3d.com/cn/learn/tutorials现在在看一个beagining教程roll a ball 起步material初探新建material,选择颜色后,将material拖到gameObject上,gameObject就会变成对应的颜色 Update方法 Update方法在渲染每帧前被调用 FixedUpdate方法只有在执行有关物理计算之前才被调用 LateUpdate方法在所有Update方法执行完执行完之后执行 静态和动态GameObject静态碰撞体unity会计算场景内所有静态碰撞体的体积,并将信息保存在缓存内.因为静态碰撞体不需要移动,可以避免每帧重新计算这些信息,所以这是对的每当静态碰撞体移动 旋转或缩放时,unity会重新计算这些静态碰撞体,然后更新静态碰撞体的缓存数据 动态碰撞体重新计算缓存会耗费系统资源,但我们可以随意移动移动,旋转或缩放动态碰撞体,而且unity不会缓存他们的数据.unity会预测动态碰撞体的移动,所以在移动碰撞体之前,需要告诉unity它们是动态的.可以使用刚体组件来实现这种效果. 任何带有碰撞体和刚体组件的GameObject都会被认为是动态的.任何带有碰撞体却没有刚体组件的GameObject则被视为是静态的.刚体选中”Is Kinematic”可以将刚体变成仅受脚本控制的刚体.kinematic刚体不受无力作用力的影响,但可以播放动画或通过Transform组件移动 几何图元绘制顺序Sorting LayerSorting Layer序号越大的层越后绘制,因而会覆盖掉前面序号小的层上的几何图元表示指定层在Tags and Layers视图Sorting Layers中的顺序各层的绘制顺序是Default -&gt; Background -&gt; Character -&gt; Foreground -&gt; UI Order in layer在同一层调整几何图元的绘制深度.同样是序号大的覆盖序号小的 spirit Render组件中SortingLayer属性控制的是不同层之间的绘制顺序,而Order in Layer控制的是同层中物体的绘制顺序 spine可算知道瓜游的小人都是什么了一开始下的spine3.7,然后于是又下了3.6.卸载旧版本插件好像是直接在project里把对应的删掉目力俾斯麦蛮好玩的 U!P!D!A!T!E!写unity程序跟平常写其他程序一个很不一样的思想就是unity的每帧都会执行的update.平时写程序如果遇到时间相关的,就要考虑sleep,然后就要考虑阻塞,考虑协程或多线程.而unity不一样.利用unity的update机制可以很轻易的管理时间. Shader12345678910111213141516171819Shader "Unlit/Tutorial_Shader"&#123; // 属性块 Properties&#123; // 在属性块中，我们可以传递一些自定义数据。我们在这里声明的数据将被显示在Unity Editor面板中，在Editor中更改也会驱动脚本更改。 // 感觉类似于C#脚本里的public声明变量 &#125; SubShader&#123; // 每一个shader有一个或者多个subshaders,如果你的应用将被部署到多种平台（移动、PC、主机）,添加多个Subshader是非常有用的。例如：你可能想要写为PC/Desktop写一个高质量的Subshader,为移动端写一个低质量,但速度更快的Subshader. // 每个Subshader至少有一个pass语句块，它实际上是对象渲染的位置。一些特效要求有多个pass语句块，目前，我们仅仅专注于一个。 pass&#123; CGPROGRAM // 我们实际写的所有Shader代码都在CGPROGRAM和ENDCG中 ENDCG &#125; &#125;&#125; 蛋疼md写shader真蛋疼,啥时候需要分号啥时候不需要啊草草草]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试笔记]]></title>
    <url>%2Fnote-interview%2F</url>
    <content type="text"><![CDATA[位运算可以节约传输和储存的空间 unity，c#，lua，opengl，渲染]]></content>
  </entry>
  <entry>
    <title><![CDATA[加了几个音乐收藏夹]]></title>
    <url>%2FmusicFavorites%2F</url>
    <content type="text"><![CDATA[想着给把最喜欢,最常听的几首歌按风格分类,造了这么几个歌单 治愈 爱 静谧 朝气蓬勃 优美忧伤 对这些歌写点东西治愈urar很美好. 蝴蝶泉边同样很美好很温馨,更加了点回忆的感觉 Growing!就是让人撒娇的歌 爱Letter动画HandShaker的BGM中听到的.前面一段代表书信的常规内容,后面深深的感情喷涌而出.不像小情侣之间的爱,像是老夫老妻或者亲情的爱这封Letter不像情书而是像家书 LuvLetter情书.写情书和纠结要不要将情书送出去的过程,理解的是纠结着很痛苦然后没能送出去.中间有纠结的痛苦,也有想象的美好结局. 恋日推给我的,高潮部分很好听 愛唄当初看一个高木同学的AMV注意到的,很真情实感 小小恋歌同样是高木同学ed收录的当初觉得高桥李依版本的好听,比较甜美来着,后来还是觉得新垣结衣唱的好听,捎带沙哑点的声音很温柔很知性 さよならの夏啊 静谧Mountain stream高中时候学校就经常放的 陽だまり道とれんちょん悠哉日常大王的BGM ふるさとの匂い夏目友人帐的BGM 朝气蓬勃RYDEEN朝气蓬勃 优美忧伤おうちに帰りたいちいさな冒険者素晴的ed. Arrietty’s Song借东西的小人阿莉埃蒂的主题曲 春よ、来い看了一个潮学视频知道的…着实很好听 この感情は使命island的曲子 さよならの夏啊]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python多重继承init的问题]]></title>
    <url>%2Fpython-mult-inherit-init%2F</url>
    <content type="text"><![CDATA[继承的时候,init父类时,平时用ide写代码习惯了这样写,因为敲一个super再回车就有了这么一行1super(C, self).__init__() 12345678910111213141516class A: def __init__(self): self.a = "a" class B: def __init__(self): self.b = "b"class C(A,B): def __init__(self): super(C, self).__init__()if __name__ == '__main__': c = C() print(c.__dict__) # &gt;&gt;&gt; &#123;'a': 'a'&#125; 可以看出问题了,C类只init了A类,并没有init B类下面是我瞎摸出来的解决方法 1234567891011121314151617181920class A: def __init__(self): self.a = "a"class B: def __init__(self): self.b = "b"class C(A, B): def __init__(self): A.__init__(self) B.__init__(self)if __name__ == '__main__': c = C() print(c.__dict__) # &gt;&gt;&gt; &#123;'a': 'a', 'b': 'b'&#125;]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome插件踩坑]]></title>
    <url>%2Fchrome-crx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[自动玩瓜游连连看的脚本]]></title>
    <url>%2Fazurlane-llk%2F</url>
    <content type="text"><![CDATA[做了个自动玩连连看的脚本.github : https://github.com/HHHHhgqcdxhg/azurlane-linkup 图片整理将原图整理成以下格式 原图: 整理出: 1234567[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 16. 2. 4. 1. 3. 1. 2. 17. 3. 0.] [ 0. 8. 7. 14. 4. 10. 12. 18. 5. 5. 0.] [ 0. 6. 6. 9. 15. 7. 11. 8. 9. 10. 0.] [ 0. 11. 12. 13. 13. 14. 15. 16. 17. 18. 0.] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] #这个二维数组是抽象的连连看"地图",将原连连看相同的图片换成同样的数字,在在周围填充0表示通路 和12[[1, 6], [1, 4], [1, 7], [1, 2], [1, 9], [1, 5], [2, 4], [1, 3], [2, 9], [2, 8], [3, 2], [3, 1], [3, 5], [2, 2], [3, 7], [2, 1], [3, 8], [3, 3], [3, 9], [2, 5], [4, 1], [3, 6], [4, 2], [2, 6], [4, 4], [4, 3], [4, 5], [2, 3], [4, 6], [3, 4], [4, 7], [1, 1], [4, 8], [1, 8], [4, 9], [2, 7]]# 这个数组每一项表示一组坐标,并且第 2 * i 个元素代表的图片和第 2 * i + 1 个元素代表的图片相同 求解算法广度优先暴搜,搜索所有可以到达的图片块,判断目标是否在其中.代码在源码中的findLineFetch方法和pointSearch方法,注释还写的蛮详细的,这里不再解释. 实行点击:跟上次的翻牌游戏脚本差不多 结果7.80s视频: av450629917.80s留了视频,有一个7.27s的没录好…追求极致的话应该能跑进7秒内,说不定能跑进6秒内,我做不到一定是因为我太菜了 时间浪费 截图耗时 因为开局前截图会有数字遮挡,所以等数字消完,再进行截图.因为有一些IO操作,所以就很慢… 算法耗时 嘛,我这个算法是广度优先暴搜,应该比较慢. 点击间隔不统一 ↑这个形容不是很准确.好像,当两个有效的点被点击时,如果距离比较近,下次可以点击的时间间隔就比较短,反之亦然.只是推测,不太确定.因为试的时候,经常前面好多都没事,最后两三组点的时候出错,怀疑是排到最后的组一般距离比较远导致的结果.]]></content>
      <tags>
        <tag>碧蓝航线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plus Ultra!]]></title>
    <url>%2Fbokuhiro-movie%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>动漫</tag>
        <tag>我的英雄学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线翻牌小游戏复现]]></title>
    <url>%2Fblhx-fanpai%2F</url>
    <content type="text"><![CDATA[git repo:https://github.com/HHHHhgqcdxhg/azurlane-fanpai已部署在:https://blog.purecucumber.club/azurlane-fanpai/dist/index.html 一下午撸出来的web复现的碧蓝航线翻牌小游戏.一路写下来没遇到坑,但也没考虑性能.]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩游戏 还愿]]></title>
    <url>%2Fdevotion%2F</url>
    <content type="text"><![CDATA[真的吓人…变写博客边玩吧. 游戏过程 小女孩透过墙洞看爸爸撕写的字…想了想,以后写代码错到恼羞成怒了也只注释不删 弹珠迷宫真是绝了 被老婆追杀那里吓坏了.用手挡住屏幕看不到主要画面,然后一直都不知道要转头跑…回头翻了别人的视频才知道要跑… 拔舌头那里真心不敢看…依旧拿手遮屏幕 评价第一次玩恐怖游戏来着,因为跟风就去玩了,吓得不轻.还是不喜欢这种,为恐怖而恐怖的游戏.里面的一些价值观也不认同. 凉凉2019年2月23日更新自断财路的傻逼玩意]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win32按键码]]></title>
    <url>%2Fvkcode%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147VK_CODE = &#123; 'backspace': 0x08, 'tab': 0x09, 'clear': 0x0C, 'enter': 0x0D, 'shift': 0x10, 'ctrl': 0x11, 'alt': 0x12, 'pause': 0x13, 'caps_lock': 0x14, 'esc': 0x1B, 'spacebar': 0x20, 'page_up': 0x21, 'page_down': 0x22, 'end': 0x23, 'home': 0x24, 'left_arrow': 0x25, 'up_arrow': 0x26, 'right_arrow': 0x27, 'down_arrow': 0x28, 'select': 0x29, 'print': 0x2A, 'execute': 0x2B, 'print_screen': 0x2C, 'ins': 0x2D, 'del': 0x2E, 'help': 0x2F, '0': 0x30, '1': 0x31, '2': 0x32, '3': 0x33, '4': 0x34, '5': 0x35, '6': 0x36, '7': 0x37, '8': 0x38, '9': 0x39, 'a': 0x41, 'b': 0x42, 'c': 0x43, 'd': 0x44, 'e': 0x45, 'f': 0x46, 'g': 0x47, 'h': 0x48, 'i': 0x49, 'j': 0x4A, 'k': 0x4B, 'l': 0x4C, 'm': 0x4D, 'n': 0x4E, 'o': 0x4F, 'p': 0x50, 'q': 0x51, 'r': 0x52, 's': 0x53, 't': 0x54, 'u': 0x55, 'v': 0x56, 'w': 0x57, 'x': 0x58, 'y': 0x59, 'z': 0x5A, 'numpad_0': 0x60, 'numpad_1': 0x61, 'numpad_2': 0x62, 'numpad_3': 0x63, 'numpad_4': 0x64, 'numpad_5': 0x65, 'numpad_6': 0x66, 'numpad_7': 0x67, 'numpad_8': 0x68, 'numpad_9': 0x69, 'multiply_key': 0x6A, 'add_key': 0x6B, 'separator_key': 0x6C, 'subtract_key': 0x6D, 'decimal_key': 0x6E, 'divide_key': 0x6F, 'F1': 0x70, 'F2': 0x71, 'F3': 0x72, 'F4': 0x73, 'F5': 0x74, 'F6': 0x75, 'F7': 0x76, 'F8': 0x77, 'F9': 0x78, 'F10': 0x79, 'F11': 0x7A, 'F12': 0x7B, 'F13': 0x7C, 'F14': 0x7D, 'F15': 0x7E, 'F16': 0x7F, 'F17': 0x80, 'F18': 0x81, 'F19': 0x82, 'F20': 0x83, 'F21': 0x84, 'F22': 0x85, 'F23': 0x86, 'F24': 0x87, 'num_lock': 0x90, 'scroll_lock': 0x91, 'left_shift': 0xA0, 'right_shift ': 0xA1, 'left_control': 0xA2, 'right_control': 0xA3, 'left_menu': 0xA4, 'right_menu': 0xA5, 'browser_back': 0xA6, 'browser_forward': 0xA7, 'browser_refresh': 0xA8, 'browser_stop': 0xA9, 'browser_search': 0xAA, 'browser_favorites': 0xAB, 'browser_start_and_home': 0xAC, 'volume_mute': 0xAD, 'volume_Down': 0xAE, 'volume_up': 0xAF, 'next_track': 0xB0, 'previous_track': 0xB1, 'stop_media': 0xB2, 'play/pause_media': 0xB3, 'start_mail': 0xB4, 'select_media': 0xB5, 'start_application_1': 0xB6, 'start_application_2': 0xB7, 'attn_key': 0xF6, 'crsel_key': 0xF7, 'exsel_key': 0xF8, 'play_key': 0xFA, 'zoom_key': 0xFB, 'clear_key': 0xFE, '+': 0xBB, ',': 0xBC, '-': 0xBD, '.': 0xBE, '/': 0xBF, ';': 0xBA, '[': 0xDB, '\\': 0xDC, ']': 0xDD, "'": 0xDE, "`": 0xC0&#125; win32按键码.留着一份省着每次再找了]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线翻牌游戏脚本]]></title>
    <url>%2Fblhx-fanpai4-45%2F</url>
    <content type="text"><![CDATA[匹配相同的牌时是裁下每张牌后,直接对比每张图片的数组是否相同翻牌的时候想要同时点两张牌,但是查了下adb好像没有支持mult touch,然后想到在模拟器上给每个牌的位置设置快捷键,翻牌的时候调用win32api点击对应的快捷键来翻牌.最终成绩4.45秒.b站视频:https://www.bilibili.com/video/av44287472/ 下面是完整代码.其中vkcode.VK_CODE是win32按键码映射表,在这篇博客有82~89行那些几个sleep的参数是试出来的,再小就容易出错了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#! /usr/bin/env python# -*- coding: utf-8 -*-import timeimport osimport cv2import numpy as npimport win32apiimport win32confrom vkcode import VK_CODEclass Blhx: def __init__(self, adbPATH, sharedPATH): self.adb = adbPATH self.sharedPATH = sharedPATH def getScreen(self, filePath="/sdcard/Pictures/tmp.png"): os.system(f"&#123;self.adb&#125; -e shell screencap -p &#123;filePath&#125;") time.sleep(0.5) return cv2.imread(f"&#123;self.sharedPATH&#125;\\tmp.png") def tap(self, X, Y): os.system(f"&#123;self.adb&#125; -e shell input tap &#123;X&#125; &#123;Y&#125;") def cutEvery(self, img): ims = [] matched = [] for y in range(3): for x in range(6): startX = 148 * x + 238 startY = 162 * y + 179 endX = startX + 90 endY = startY + 129 im = img[startY:endY, startX:endX, :] thisImInfo = (y, x, im) hasmatch = False for i, imgInfo in enumerate(ims): difference = cv2.subtract(im, imgInfo[2]) result = not np.any(difference) if result: hasmatch = True matched.append(imgInfo[:2]) matched.append(thisImInfo[:2]) del ims[i] continue if not hasmatch: ims.append(thisImInfo) return matchedkeyboardsMap = [ "QWERTY".lower(), "ASDFGH".lower(), "ZXCVBN".lower()]def mian(): blhx = Blhx(r"E:\programfiles\adb\adb.exe", "J:\ldmnqshare") blhx.tap(800, 485) time.sleep(1.1) print("jietu") im = blhx.getScreen() pos = blhx.cutEvery(im) ks = [] for i, p in enumerate(pos): k = keyboardsMap[p[0]][p[1]] ks.append(k) kl = ks.__len__() if not kl == 18: print("没匹配好") return time.sleep(1) for x in range(9): k0 = 2 * x k1 = k0 + 1 kNode0 = ks[k0] kNode1 = ks[k1] win32api.keybd_event(VK_CODE[kNode0], 0, 0, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode1], 0, 0, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode0], 0, win32con.KEYEVENTF_KEYUP, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode1], 0, win32con.KEYEVENTF_KEYUP, 0) print("tap") time.sleep(0.375)if __name__ == '__main__': mian()]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cuclasses]]></title>
    <url>%2FCuclasses%2F</url>
    <content type="text"><![CDATA[介绍Cuclasses是我正在写的python库,内容是集合了一些常用的类和方法 项目地址pypi(少有更新):https://pypi.org/project/cuclasses/github:https://github.com/HHHHhgqcdxhg/cuclasses 模块cuclasses.DottableDict顾名思义,能用 “.” 访问的dict.因为喜欢js访问对象属性的方式,可以用下标,也可以用点. cuclasses.singleton装饰器.被装饰的类为单例模式 cuclasses.CallableDict可以调用的dict,调用时返回自身. cuclasses.StrKeyDict在查询时把非字符串键转换为字符串的dict cuclasses.headerCopy2Dict因为在复制chrome开发者工具network里请求的header时很不方便,就弄了这个…把chrome里的headers复制进去,会转换成字典 123456789101112headerStr = """Accept: application/json, text/plain, */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-aliveCookie: l=v; buvid3=08DBF55E-086D-4BE2-9FCB-4B60BFA5F05A140254infocHost: message.bilibili.comOrigin: https://www.bilibili.comReferer: https://www.bilibili.com/video/av9912938/?p=11User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"""a = headerCopy2Dict(headerStr)print(a)#&gt;&gt;&gt; &#123;'Accept': 'application/json, text/plain, */*', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Host': 'message.bilibili.com', 'Origin': 'https://www.bilibili.com', 'Referer': 'https://www.bilibili.com/video/av9912938/?p=11', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125; cuclasses.timePrint上下文管理器.带时间戳的print.随时可指定时间格式 12345678910111213141516with timePrint() as print: print(0) # &gt;&gt;&gt; [2019-02-10 16:23:35] 0 print(1, strf="[%Y-%m-%d %H:%M:%S]1") # &gt;&gt;&gt; [2019-02-10 16:23:35]1 1with timePrint("[%Y-%m-%d %H:%M:%S]2") as print: print(2) # &gt;&gt;&gt; [2019-02-10 16:23:35]2 2 print(3, strf="[%Y-%m-%d %H:%M:%S]3") # &gt;&gt;&gt; [2019-02-10 16:23:35]3 3print(4)# &gt;&gt;&gt; 4 cuclasses.timeCount装饰器.接受两个参数.被装饰的函数将在执行后打印执行时间 12:param enable: 设为False则不计时,直接执行函数:param method: 可选择的计时所用的获取时间的函数.默认time.perf_counter,或者也可以选填time.time,python3.7可以按需选用time.perf_counter_ns 1234567@timeCount()def bar(): print(&#123;"a": "c"&#125;)bar()#&gt;&gt;&gt; &#123;'a': 'c'&#125;#&gt;&gt;&gt; func bar excuted in : 6.044444444444444e-05 cuclasses.Downloader下载器. 1234:param directory:下载到的目录:param urls:需要下载的资源目录:param threads:并行下载的线程数:param headers:请求头,默认为&#123;&quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;&#125; with open("xx.json","r") as f: data = json.load(f) d = Downloader(directory=r"E:\ACG\comic\general\どうして私が美術科に",urls=data) d.downloadAll()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站的搭建]]></title>
    <url>%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[依赖本博客基于Hexo生成,选用Next.Mixins作为主题 正文主题不是很喜欢黑黑的颜色,就把css里颜色改了改,改成了蓝色的主题 写作工具VSC + MPE写md不要太爽(atom,sublime应该一样) 图床图床用的是七牛云上传图片至图床的工具是PicGo,同样不要太爽现在是vs-picgo了,爽上加爽 deploy不是很清楚hexo clean和hexo generate的关系,索性每次deploy的时候都先hexo clean再hexo g再hexo d.因为很麻烦,就写了段C++做成个exe int main() { system("hexo clean"); system("hexo g"); system("hexo d"); return 0; } 之后就把编译出来的exe命名为d.exe放到项目根目录,之后每次deploy就./d就完事了 评论之前选用的livere,现在换成了Valine]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ｆｔｐ 三 次 握 手]]></title>
    <url>%2FsomeFTP%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>无厘头</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[azurlane-painting开发笔记]]></title>
    <url>%2Fazurlane-painting%2F</url>
    <content type="text"><![CDATA[dalao的开发过程 我的开发过程 repo : https://github.com/HHHHhgqcdxhg/azurlane-painting图片处理过程: 将图片缩小 -&gt; 将图片色彩聚类到16色 -&gt; 将聚类后的16色归到舰b指定的8色 -&gt; 合成画板图片]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bilibili机器人更新日志]]></title>
    <url>%2Fbili-bot-release-log%2F</url>
    <content type="text"><![CDATA[19/02/18 取消对以关键字”【お知らせ”开头的推特的图片打水印(那个图太小了) 19/02/07 取消对以关键字”【接続障害”开头的推特的转推(即日服服务器故障和故障修复的推文) 19/01/27 增加图片水印 18/12/24 修复IOS端点开大图一直正在加载的问题 18/12/21 自动在回复中发送机翻 18/12/20 取消对以关键字”【メンテナンス”开头的推特的转推(即日服维护说明) 18/12/19 䒕黃苽机器人开始运行]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>bot</tag>
        <tag>bilibot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[䒕黃苽B博碧蓝航线日推转发机器人README]]></title>
    <url>%2Fbili-bot-help%2F</url>
    <content type="text"><![CDATA[00010100101还什么都没有哦~]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>bot</tag>
        <tag>bilibot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小黄瓜机器人使用指南]]></title>
    <url>%2Fbot-help%2F</url>
    <content type="text"><![CDATA[介绍小黄瓜机器人QQ:2482513293想要自己的群拥有小黄瓜的话不用打招呼,直接拉就好哦小黄瓜详细功能列表见下文所有可能烦人的功能都是可以群管理发送指令开启/关闭的想要做一个跟小黄瓜类似的机器人,可以跳转至技术相关 加群准则因为加群太多会使服务器负担太大,所以会控制加群数量.不乐意加入的群: 人数比较少的群.因为百十个人及以下的群难以保证管理和群员的素质 不感兴趣的群.舰b群和kirara fantasia群以外的邀请不出意外应该不会接受 功能列表:1. 无指令功能:点击功能跳转到对应位置 功能 机器人需要管理权限 控制开关 转发推特功能 否 !tweetConfig指令 复读机随机禁言功能 ==是== !fuduBanConfig指令 新人入群提醒功能 否 !welcomeConfig指令 2. 指令功能:指令功能是通过发送以感叹号开始的指令触发的功能,中文或英文感叹号均可,无视大小写.点击功能跳转到对应位置 指令 功能 机器人需要管理权限 限管理可用 控制开关 !help 帮助功能 否 否 无 !fuck 众裁功能 ==是== 否 指令 !sleep 金质睡眠功能 ==是== 否 指令 !del 定时撤回消息功能 ==是== 否 指令 !recipe 获取一份假的食谱功能 否 否 指令 !build 碧蓝航线建造模拟器 否 否 指令 !tweetConfig 设置转发推特的功能 否 ==是== 无 !enable 开启功能的功能 否 ==是== 无 !disable 关闭功能的功能 否 ==是== 无 !report 联系主人功能 否 ==是== 无 功能详情新人入群提醒功能!welcomeConfig指令限管理可用 有新人入群时,小黄瓜机器人将@新人,发送入群提醒管理可通过发送 !welcomeConfig + 内容 来指定入群提醒内容如:12!welcomeConfig欢迎加入善良可爱小海豹保护者协会群!请先阅读群置顶公告哦! 注: 设置的入群提醒不宜太长,避免刷屏.建议提醒阅读群公告,内容写在群公告即可 设置的入群提醒中的图片将被忽略 !welcomeConfig后不跟内容,将取消入群提醒 复读功能通过指令开/关功能 小黄瓜检测到有人在复读,就会跟着复读因不堪网络暴力机器人发消息太多会被腾讯制裁,本功能停止使用 复读机随机禁言功能!fuduBanConfig指令限管理可用 | 机器人需要管理权限 管理可通过发送类似下面的消息,更改禁言复读机配置1234567!fuduBanConfig&#123; &quot;banLen&quot;: 2, &quot;banMult&quot;: 10, &quot;banRebel&quot;: false, &quot;randMemberMode&quot;: 2, &quot;randTimeMode&quot;: 3&#125; 对配置的解释如下: 字段名描述可选值对应效果banLen触发复读禁言条数&gt;= 2复读条数(算上 被复读的那一条) 大于等于 这个值时,触发复读禁言banMult禁言力度&gt;= 1控制禁言时长的力度banRebel是否开启禁言复读机叛徒true此时,如果是参与复读的人打断复读,则不再进行复读机随机抽取,而是直接抽中这名复读机叛徒false正常进行复读机抽取randMemberMode抽取复读机的模式0关闭本功能,不再禁言复读机1随机抽取一名复读机2正态分布随机抽取一名复读机3取倒数第二个复读机randTimeMode抽取禁言时长的模式1经典随机,禁言时间为 (1~本轮复读条数 之间的随机数) banMult2复读总长相关,禁言时间为 本轮复读条数 banMult3固定时长,禁言时长为 banMult4按座位,被抽到的复读机在本轮复读中是倒数第n个,时长就为 n * banMult 众裁功能本功能为指令功能,通过发送 !fuck + @一名群员 触发 通过指令开/关功能 | 机器人需要管理权限 在一人通过该指令开启对一名群员A的众裁之后,将开始三分钟的计时,统计三分钟内通过该指令参与对群员A的众裁的人数,于三分钟后对群员A进行制裁(禁言)禁言时长: 参与本轮众裁人数 禁言时长(分钟) &lt;= 2 不禁言 3 5 4 10 >= 5 每多一人,时长加2 注: !fuck后面跟上@一名群员,这个@必须是能@到人的,复制粘贴的不管用 不要重复参与众裁,否则会被禁言1分钟 不要再众裁群主管理辣! 不要欺负人哦,拿来制裁海豹正适合 定时撤回消息功能本功能为指令功能,通过发送 !del + 时长 + 空格 + 消息 触发 通过指令开/关功能 | 机器人需要管理权限 示例:1!del 10 这条消息将在10秒后被撤回 注: 如 !del 后不加时长,直接跟消息,则默认撤回时长为5秒 如设置时长,记得时长数字和后面消息中间用空格分隔 设置时长最大为600,超过这个值将改为5 本功能为限 非管理群员 使用 金质睡眠功能本功能为指令功能,通过发送 !sleep 触发 通过指令开/关功能 | 机器人需要管理权限 22:00~次日03:59发送指令,发送者将被禁言6小时 食谱功能本功能为指令功能,通过发送 !recipe 或 !gbf触发 通过指令开/关功能 | 消耗黄瓜片 : 20 发送一份分享,标题和图片为随机食谱的标题和图片,点开却是granbluefantasy.jp 碧蓝航线建造模拟器本功能为指令功能,通过发送 !build 触发 通过指令开/关功能 | 消耗黄瓜片 : 40 !build可接受最多两个正整数参数,用逗号分隔(中英文标点均可) 指令 效果 !build 抽取1池10次 !build x 抽取x池10次,x可为1,2,3 !build x,y 抽取x池y次,y为1~10 注: 概率保证按照官方给出的概率 卡池信息来自碧蓝航线wiki建造模拟器 不准备做限时建造的卡池,想玩的请移步碧蓝航线wiki限时建造模拟器 本功能需要生成图片发送图片,对服务器资源消耗过大,不要玩太过分哦 转发推特功能!tweetConfig指令限管理可用小黄瓜会实时(Real Time)转发指定推特用户发送的新推特至qq群新加的群是不会转发推特的,需要经过设置后,可转发指定推特设置方法:发送类似如下的消息,可添加或修改推特转发: 12345678910111213!tweetConfig&#123; &quot;follow&quot;:&#123; &quot;name&quot;:&quot;@azurlane_staff&quot;, &quot;nickName&quot;:&quot;碧蓝航线日服推特&quot; &#125;, &quot;groupInfo&quot;: &#123; &quot;nickName&quot;: &quot;在这里填写群名&quot;, &quot;trans&quot;: false, &quot;sendRT&quot;: false, &quot;mediaOnly&quot;:false, &quot;follow&quot;: true &#125;&#125; 以下为对上面配置的解释:12345678910111213!tweetConfig&#123; &quot;follow&quot;:&#123; &quot;name&quot;:&quot;这里填入需要关注的人的推特Id,以@开头&quot;, &quot;nickName&quot;:&quot;这里填入关注的人的称呼&quot; &#125;, &quot;groupInfo&quot;: &#123; &quot;nickName&quot;: &quot;群名&quot;, //在这里填写群名,理论上随便填,主要目的是让作者辨识出是哪个群 &quot;trans&quot;: true, //是否需要发送一遍将经过百度翻译的推文,把true改成false将不翻译 &quot;sendRT&quot;: false, //是否需要发送 转发和回复别人的推特,建议关闭,打开很烦人的,把false改成true打开 &quot;mediaOnly&quot;: false, //将false改成true,将只发有图片内容的推特,纯文字推特将忽略,适合关注画师 &quot;follow&quot;: true //将true改为false,将不转发此人的推特 &#125;&#125; 注意: 这条消息除开头的!tweetConfig以外,全部大小写敏感且必须用半角标点符号(即英文标点) 大括号,冒号,逗号,引号都不能漏 不要将true打成ture,false打成flase… 若出现”查找用户信息失败”提示,请确定关注的人的id以@符号开头,确认无误后稍后再试 小黄瓜机器人定时每周四取消对 只有一个群关注的推特 的关注 附录中给出了些常用推特供参考 开启功能的功能本功能为指令功能,通过发送 !enable + 其他功能指令 触发 限管理可用 指令 功能 !enable !sleep 开启金质睡眠功能 !enable !fuck 开启众裁功能 !enable !recipe 开启食谱功能 !enable !build 开启碧蓝航线建造模拟器 !enable !del 关闭定时撤回消息功能 注:无视所有感叹号全/半角,不区分大小写 关闭功能的功能本功能为指令功能,通过发送 !disable + 其他功能指令 触发 限管理可用 指令 功能 !disable !sleep 关闭金质睡眠功能 !disable !fuck 关闭众裁功能 !disable !recipe 关闭食谱功能 !disable !build 关闭碧蓝航线建造模拟器 !disable !del 关闭定时撤回消息功能 注:无视所有感叹号全/半角,不区分大小写 联系主人功能本功能为指令功能,通过发送 !report 触发 !report指令限管理可用机器人接收到以!report开头的消息,会发送给主人看到注: 乱玩此功能会打扰到主人的,请不要乱玩 机器人功能相关请先仔细阅读本篇文档对应部分 在群里直接@小黄瓜机器人,主人一般情况下看不到的 私聊小黄瓜机器人,主人一般情况下看不到 使用!report指令的消息,主人会看到,并尽量及时回应 按照下面联系方式联系主人,是比较有效的联系方式 有事请直接说事,免掉”在吗”之类的打招呼内容 谢绝无事骚扰 &nbsp;&nbsp;&nbsp;ex. 不过如果你有色图,请务必私发给䒕黃苽机器人 主人QQ:2894700792 加好友的认证信息请认真填写 黄瓜片系统出于目的: 防止功能滥用对小黄瓜服务器造成太大负担 防止某些功能造成刷屏 防止被tx限制 现在实装黄瓜片系统,某些功能需要消耗黄瓜片(黄瓜片就是类似体力的东西啦) 获得黄瓜片小黄瓜机器人会在每天凌晨04:30,中午13:30,晚上19:30将所有群友的黄瓜片置为40点.即,黄瓜片不可积攒,每个时间段40点 消耗黄瓜片消耗黄瓜片的功能 功能 消耗黄瓜片数/次 碧蓝航线建造模拟器 40 食谱功能 20 其他小黄瓜机器人的管理权限给小黄瓜管理权限后,机器人并不能马上意识到自己是管理,需要重启插件,这时通过联系主人功能告知重启 限管理可用功能本文中的”管理”,皆指 管理or群主把部分功能做成仅限管理可用,目的是过滤掉没素质的人,希望身为管理能意识到自己的一份素质,不要闲来无事report玩,或者凭一己之见关注一些奇怪或无聊的推特 idea相关有觉得好玩的机器人的玩法的想法,可以联系主人哦 技术相关因为小黄瓜机器人项目中有很多小黄瓜的apikey和OAuth认证信息,开源很麻烦,所以闭源小黄瓜机器人项目代码是使用python编写,通过richardchien/coolq-http-api和richardchien/python-aiocqhttp控制酷Q实现的,监听新推特是通过tweepy.StreamListener实现酷Q只能跑在windows或有图形界面的linux服务器上,本人使用的服务器是阿里云服务器的学生机 其他的䒕黃苽 䒕黃苽bilibili机器人:@碧蓝航线转推姬会将碧蓝航线新日推转发到B站动态,并在评论区附上翻译䒕黃苽B博机器人介绍 䒕黃苽微博机器人:@碧蓝航线转推姬(和B站的同名哦)会将碧蓝航线新日推转发到微博 其他相关希望群友们素质聊天 投喂喜欢小黄瓜机器人的话可以支付宝投喂哦 免费红包哦 打赏¥1 打赏¥3 打赏¥10 打赏一单 每天都能扫一次哦 老冰棍 快乐水 一餐饭 老婆 附录:常用推特id 推特id 备注 @korindo 博丽神主推特 @kirarafantasia 芳文社手游きららファンタジア官推 @azurlane_staff 碧蓝航线日服官推 @azurlanekorea 碧蓝航线韩服官推 @AzurLane_EN 碧蓝航线美服官推 @KanColle_STAFF 「艦これ」開発/運営 @fgoproject FGO官推 @granbluefantasy 学习资料]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>qqbot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python程序打包成exe]]></title>
    <url>%2Fpy2exe%2F</url>
    <content type="text"><![CDATA[前言用python写了个项目(在这)想发布出去给没有python环境的人用.试了pyinstaller,打包出来不能正常跑…于是心生淫技,将python环境跟项目放到一起,然后拿C++写几行程序,通过system call的方式调用python运行项目脚本,再将这个C++程序编译成exe… python环境的准备我首先试了拿虚拟环境,然后发现虚拟环境少了一堆dll…拿自己的python环境吧,一堆这个项目用不着的库,打包进去太大,挑出来太麻烦…索性另外装一个python.我本身环境是3.6.7版本的,又去另外装了个3.7.2版本.安装时注意把什么设置环境变量,向所有用户安装都取消了,留着pip就好,之后拿pip把包都装好,然后把整个python目录拷贝到项目根目录就完事了 准备一个exe这就比较野蛮…程序入口12345678910111213141516171819202122```C++#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;direct.h&gt; using namespace std;int main(int argc, char * argv[])&#123; string cwd = _getcwd(NULL, 0); string cmd = &quot;\\Python37-32\\python.exe __main__.py&quot;; cmd = cwd + cmd; for (int i = 1; i &lt; argc; i++) &#123; cmd += &quot; &quot;; cmd += argv[i]; &#125; const char *cmd_c_str = cmd.c_str(); // cout &lt;&lt; cmd_c_str&lt;&lt;endl; system(cmd_c_str); //system(&quot;pause&quot;); return 0;&#125; 编译好拿出来放到项目根目录就完事了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桌面追番助手]]></title>
    <url>%2FbangumiDesktopAssistant%2F</url>
    <content type="text"><![CDATA[本项目git仓库:https://dev.tencent.com/u/hhhhhg/p/bangumiDesktopAssistant尝试了打包成exe却做不到,所以应该只有装了python才能用了XDpython版本是3.6.4(因为用到了f前缀字符串,所以大概需要至少3.6版本),操作系统只试了windows 使用:1234git clone https://git.dev.tencent.com/hhhhhg/bangumiDesktopAssistant.gitcd bangumiDesktopAssistantpip install -r requirements.txtpython __main__.py 在任务栏找到图标(和项目头像是同一张图片),右键可进行追番编辑或者退出程序.追番编辑工具按要求填入信息,可生成一份番剧信息,保存在src/db/bangumisInfo中,如果填入得当,不发生意外,则可正常使用.遇到特殊情况(比如番剧停更)则需要手动改对应的json文件中的chapters部分… 有番剧更新时,会播放音频,为src/audio/alarm.wav透明度,配色等配置存在src/db/config.json中,可以轻易更改 配置好环境后,之后可以运行bangumi.bat来运行本工具,也可在注册表中将bangumi.bat设为开机自启运行截图: 1080p屏幕下unfocused状态表现 1080p屏幕下focused状态(鼠标悬停在之上时)表现 之前用tkinter写了两天了,察觉有点不好用,又换成了PyQt5.耗资源方面,平常在后台运行就占用十几二十M内存]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gui</tag>
        <tag>动漫</tag>
      </tags>
  </entry>
</search>
