<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里云全站加速]]></title>
    <url>%2Fali-dcdn%2F</url>
    <content type="text"><![CDATA[好好好好好好好好快啊这个 配置了有一会儿,照着这篇文章弄的使用阿里云CDN全站加速gitpages - 简书 快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快快]]></content>
  </entry>
  <entry>
    <title><![CDATA[weekly-2019-49]]></title>
    <url>%2Fweekly-2019-49%2F</url>
    <content type="text"><![CDATA[周二打了一天maimai…从机厅上午开门开始打的,一直打到累 bililivestatis在运行了,修了好几次报错了… 百度又来了个电话,说是补面,21号去cp的也要去上海,就约了20号去一趟百度上研]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp和java的区别]]></title>
    <url>%2Fdiff-csharp-java%2F</url>
    <content type="text"><![CDATA[java经常是, 需要操作一个变量的时候,选择去调用方法,而C#感觉是反过来,操作变量的时候去执行某些方法 234]]></content>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哔哩哔哩直播统计项目]]></title>
    <url>%2Fbili-live-statis%2F</url>
    <content type="text"><![CDATA[b站弹幕是用的ws与服务器连接来接收/发送消息的 这个弹幕和礼物的推送我感觉并不是很可靠,很有可能会有网络波动或连接断开的情况,所以我选择多个线程同时监听弹幕服务器的推送(当然多个线程可以选择跑在不同的进程跑在不同的机器上). 然后的问题是,把消息往mq里塞,还要消息不重复传.我这里没有选择用自带去重功能的rocketMQ,而是用的kafka(毕竟kafka性能和多语言客户端支持比rocketMQ好),三个Producer往mq里写消息之前,先试图往Redis里SetNX一个键值对,这个键就根据消息内容生成的,值为空字符串就好,如果写入成功,就由该线程将消息写入mq,如果没有写入成功,则表示有其他线程来往mq里写消息,自己直接返回即可.这里往redis里写的时候 过期时间我也不晓得应该设多少合适…多了占内存少了可能起不到作用…我现在是设的5s 然后mq的消息广播机制就很有作用了,我们可以有多个consumer,比如我服务器一直跑着一个consumer来往db里记录数据,然后我自己桌面可以开一个consumer来看实时弹幕(我这b站web端看直播经常没弹幕可看…) 大概画个图如下]]></content>
  </entry>
  <entry>
    <title><![CDATA[weekly-2019-48]]></title>
    <url>%2Fweekly-2019-48%2F</url>
    <content type="text"><![CDATA[周二去把三方签了 虚拟形象开始安排了,策划本写了半本了,画师也有约到了]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weekly-2019-47]]></title>
    <url>%2Fweekly-2019-47%2F</url>
    <content type="text"><![CDATA[这周金思维复试,拿到了offer,下周二去签三方 去打了一次maimai 斩服少女看了10集,jojo看了10集.感觉jojo没那么好看…]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weekly-2019-46]]></title>
    <url>%2Fweekly-2019-46%2F</url>
    <content type="text"><![CDATA[这周尝试了kafka,另外研究了下websocket. 这周只有周一去了maimai 看了永生之酒.蛮好玩的 这周有两天都只睡了一小时…相应的有两天睡了10小时… 看了360话火影漫画]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-kafka-java]]></title>
    <url>%2Fpython-kafka-java%2F</url>
    <content type="text"><![CDATA[想用python作为producer,往kafka中塞数据,然后java作为consumer,从kafka中取. 有点麻烦,用kafka自带的序列化的话,好像就只能java对象转java对象了,没得从python的转.所以…我的解决方法是都传json字符串,然后再自己控制序列化… 回头看下hessian能不能拿来做这个序列化?]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka-enable-remote]]></title>
    <url>%2Fkafka-enable-remote%2F</url>
    <content type="text"><![CDATA[用的sptingboot的KafkaTemplate连接kafka,结果出现java.net.UnknownHostException 然后改了kafka server配置 1vi config/server.properties 就行了]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-45周周报]]></title>
    <url>%2Fweekly-2019-45%2F</url>
    <content type="text"><![CDATA[这周去玩maimai玩的有点多,因为出门比较多 周一去了金智科技的一面,周三去的它的二面,周六去的省招会 这周把转推姬用java重构完毕了 开始读java性能优化权威指南了]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次ThreadLocal踩坑]]></title>
    <url>%2Fthreadlocal-hool%2F</url>
    <content type="text"><![CDATA[123private static final MultipartEntityBuilder BUILDER = MultipartEntityBuilder.create().addPart(BIZ, BIZ_VALUE).addPart(CATEGORY, CATEGORY_VALUE);private static final ThreadLocal&lt;MultipartEntityBuilder&gt; BUILDER_THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; BUILDER); 这样是不行的,作为initial的对象不能是static. 改成下面这样就好了: 123456private static final ThreadLocal&lt;MultipartEntityBuilder&gt; BUILDER_THREAD_LOCAL = new ThreadLocal&lt;&gt;()&#123; @Override protected MultipartEntityBuilder initialValue() &#123; return MultipartEntityBuilder.create().addPart(BIZ, BIZ_VALUE).addPart(CATEGORY, CATEGORY_VALUE); &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis-集群]]></title>
    <url>%2Fredis-13%2F</url>
    <content type="text"><![CDATA[概述 Redis集群是Redis提供的分布式数据库方案,集群通过分片(sharding)来进行数据共享,并提供复制和故障转移功能 节点 一个Redis集群通常由多个节点组成,在刚开始的时候,每个节点都是相互独立的,它们都处于一个只包含自己的集群当众,要组建一个真正可工作的集群,我们必须将各个独立的节点连接起来,构成一个包含多个节点的集群. 节点数据结构 clusterNode结构保存了一个节点的当前状态,比如节点的创建时间,节点的名字,节点当前的配置纪元,节点的IP地址和端口号等等 每个节点都会保存自己和集群中所有其他节点的状态 CLUSTER MEET命令的实现 CLUSTER MEET命令可以让节点A将另一个节点B添加到节点A当前所在的集群里面 节点A会为节点B创建一个clusterNode结构 节点A根据给定的IP和端口号向节点B发送一个MEET消息 节点B接收到节点A发送的MEET消息,节点B为节点A创建一个clusterNode结构 节点B向节点A返回一条PONG消息 节点A收到这条PONG消息,通过这条PONG消息节点A可以指导节点B已经成功地接收到了自己发送的MEET消息 节点A向节点B返回一条PING消息 节点B接收到节点A返回的PING消息,通过这条PING消息节点B可以指导节点A已经成功地接收到自己返回的PONG消息,握手完成 槽指派 Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为16384个槽,数据库中的每个键都属于这16384个槽的其中一个,集群中的每个节点可以处理0或最多16384个槽 当数据库中的16384个槽都有节点在处理时,集群处于上线状态;相反地,如果数据库中有任何一个草没有得到处理,那么集群处于下线状态 执行完CLUSTER MEET命令后的集群还是下线状态,通过向节点发送CLUSTER ADDSLOTS命令可以将槽指派给节点负责 记录节点的槽指派信息 记录在clusterNode结构的slots属性和numslot属性 传播节点的槽指派信息 在集群中执行命令 当客户端向节点发送与数据库键有关的命令时,接受命令的节点会计算出命令要处理的数据库键属于哪个槽,并检查这个槽是都指派给了自己 计算键属于哪个槽 类似HashMap 12def slot_number(key): return CRC16(key) &amp; 16383 重新分片 重新分片不需要下线集群 重新分片的实现原理 重新分片操作是由Redis的集群管理软件redis-trib负责执行的,Redis提供了进行重新分片所需的命令,而redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作 redis-trib对目标节点发送CLUSTER SETSLOT IMPORTING &lt;source_id&gt;命令,让目标节点准备好从源节点导入属于槽slot的键值对 redis-trib对源节点发送CLUSTER SETSLOT MIGRATING &lt;target_id&gt;命令,让源节点准备好属于槽slot的键值对迁移至目标节点 redis-trib向源节点发送CLUSTER GETKEYSINSLOT 命令,获得最多count个属于slot的键值对的键名 对于步骤3的每个键名,redis-trib都向源节点发送一个MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 命令,将被选中的键原子地从源节点迁移至目标节点 重复执行步骤3和4,直到源节点保存的所有槽slot的键值对都被迁移至目标节点为止 redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT NODE &lt;target_id&gt;命令,将槽slot指派给目标节点,这一指派信息会通过消息发送至整个集群,最终集群中的所有节点都会知道槽slot已经指派给了目标节点 ASK错误 TODO 复制与故障转移]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InnoDB-事务]]></title>
    <url>%2Finnodb-2%2F</url>
    <content type="text"><![CDATA[概述 分类 从事务理论的角度来说,可以把事务分为以下几种类型: 扁平事务 带有保存点的扁平事务 链事务 嵌套事务 分布式事务 扁平事务 是事务类型中最简单的一种,也是实际生产环境中使用最频繁的事务 在扁平事务中,所有操作都处于同一层次,由BEGIN WORK开始,由COMMIT WORK或ROLLBACK WORK结束,其间的操作是原字的,要么都执行,要么都回滚,因此扁平事务是应用程序成为原子操作的基本组成模块 扁平事务的主要限制是不能提交或回滚事务的某一部分,或分几个步骤提交. 带有保存点的扁平事务 除了支持扁平事务支持的操作外,允许在事务执行过程中回滚到同一事务中较早的一个状态,这是因为某些事务可能在执行过程中会先的错误并不会导致所有的操作都无效,放弃整个事务不合乎要求,开销也太大,保存点用来通知系统应该记住事务当前的状态,以便当发生错误时,事务能回到保存点当时的状态 链事务 可视为保存点模式的一种变种.带有保存点的扁平事务在系统崩溃时所有保存点都将小时,因为其保存点是易失的,而非持久的. 链事务的思想是:在提交一个事务时,释放不需要的数据对象,将必要的处理上下文隐式地传给下一个要开始的事务.链事务中提交事务操作和开始下一个事务操作将合并为一个原子操作.这意味着下一个事务能看到上一个事务的结果,就好像在一个事务中进行的. 链事务与带保存点的扁平事务不同的是带有保存点的扁平事务能回滚到任意正确的保存点,而链事务中的回滚仅限于当前事务,即只能恢复到最近一个的保存点.对于锁的处理,两者也不相同,链事务在执行COMMIT后释放了当前事务所持有的锁,而带有保存点的扁平事务不影响迄今为止所持有的锁 嵌套事务 是一个层次结构框架,由一个顶层事务控制各个层次的事务.顶层事务之下嵌套的事务被称为子事务,其控制每一个局部的变换. 嵌套事务是由若干事务组成的一棵树,子树既可以是嵌套事务,也可以是扁平事务 处在叶子节点的事务是扁平事务 处于根节点的事务成为顶层事务,其他事务成为子事务 子事务既可以提交也可以回滚,但它的操作并不是马上生效,除非其父事务已提交 树中任意一个事务的回滚会引起它所有子事务一起回滚 实际的工作是交由叶子节点来完成的,即只有叶子节点的事务才能访问数据库,发送信息,获取其他类型的资源,而高层的事务仅负责逻辑控制,决定何时调用相关的子事务 分布式事务 通常是一个在分布式环境下运行的扁平事务 事务的实现 事务隔离性由锁来实现,原子性,一致性,持久性通过数据库的redo log和undo log来完成.redo log称为重做日志,用来保证事务的原子性和持久性,undo log用来保证事务的一致性 redo 重做日志用来实现事务的持久性,其由两部分组成:一是内存中的重做日志缓冲,是易失的,而是重做日志文件,是持久的 InnoDB是事务的存储引擎,其通过Force Log at Commit机制实现事务的持久性,即当事务提交时,必须先将事务的所有日志写入到重做日志文件进行持久化,待事务的COMMIT操作完成才算完成 重做日志在InnoDB中有两部分组成,即redo log和undo log.redo log用来保证事务的持久性,undo log用来帮助事务回滚及MVCC的功能.redo log基本上都是顺序写的,在数据库运行时不需要对redo log的文件进行读取操作.而undo log是需要进行随机读写的]]></content>
      <categories>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-事务]]></title>
    <url>%2Fredis-12%2F</url>
    <content type="text"><![CDATA[概述 Redis通过MULTI,EXEC,WATCH等命令来实现事务功能 以下是一个事务的执行过程,该事务由一个MULTI命令开始,接着将多个命令放入事务当众,最后由EXEC命令将这个事务提交给服务器 1234567891011121314151617181920redis&gt; MULTIOKredis&gt; SET &quot;name&quot; &quot;Practical Common Lisp&quot;QUEUEDredis&gt; GET &quot;name&quot;QUEUEDredis&gt; SET &quot;author&quot; &quot;Peter Seibel&quot;QUEUEDredis&gt; GET &quot;author&quot;QUEUEDredis&gt; EXEC1) OK2) &quot;Practical Common Lisp&quot;3) OK4) &quot;Peter Seibel&quot; 事务的实现 一个事务从开始到结束通常会经历以下三个阶段: 事务开始 命令入队 事务执行 事务开始 MULTI命令的执行标志着事务的开始,将执行该命令的客户端从非事务状态切换到事务状态 命令入队 当一个客户端处于非事务状态时,这个客户端发送的命令会立即被服务端执行 当一个客户端处于事务状态时,服务端会根据这个客户端发来的不同命令执行不同的操作: 如果客户端发送的命令是EXEC,DISCARD,WATCH,MULTI四个命令中的一个,那么服务器会立即执行这个命令 如果是那四个之外的命令,服务器不会立即执行这个命令,而是将这个命令放入一个事务队列里面,然后向客户端返回QUEUED回复 事务队列 每个Redis客户端都有自己的事务状态,这个事务状态保存在客户端状态的mstate属性里面 事务状态包含一个事务队列,以及一个已入队命令的计数器 事务队列是一个multiCmd类型的数组,数组中每个multi结构都保存了一个已入队命令的相关信息,包括指向命令实现函数的指针,命令的参数,以及参数的数量 事务队列以FIFO的方式保存入队的命令. 执行事务 当一个处于事务状态的客户端向服务器发送EXEC命令时,这个EXEC命令将立即被服务器执行.服务器会遍历这个客户端的事务队列,执行队列中保存的所有命令,最后将执行命令所得的结果全部返回给客户端 WATCH命令的实现 WATCH命令是一个乐观锁,它可以在EXEC命令执行之前监视任意数量的数据库键,并在EXEC命令执行时,检查被监视的键是否至少有一个已经被修改过了,如果是的话,服务器将拒绝执行事务,并向客户端返回代表事务执行失败的空回复 一个事务失败的例子: 1234567891011redis&gt; WATCH &quot;name&quot;OKredis&gt; MULTIOKredis&gt; SET &quot;name&quot; &quot;peter&quot;QUEUEDredis&gt; EXEC(nil) 发生上面的情况是因为: 时间 客户端A 客户端B T1 WATCH “name” T2 MULTI T3 SET “name” “peter” T4 SET “name” “john” T5 EXEC 使用WATCH命令监视数据库键 每个Redis数据库都保存着一个watched_keys字典,这个字典的键是某个被WATCH命令监视的数据库键,而字典的值则是一个链表,链表中记录了所有监视响应数据库键的客户端 监视机制的触发 所有对数据库进行修改的命令在执行之后斗湖调用touchWatchKey函数对watched_keys字典进行检查,查看是否有客户端正在监视刚刚被命令修改过的数据库键,如果有的话,那么touchWatchKey函数将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开,表示该客户端的事务安全性已经被破坏 判断事务是否安全 当服务器收到一个客户端发来的EXEC命令时,服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务 一个完整的WATCH事务执行过程 假设当前客户端为c10086,而数据库watched_keys字典的当前状态如图19-7所示,那么当c10086执行以下WATCH命令之后: 12c10086&gt; WATCH &quot;name&quot;OK watched_keys字典将更新至图19-8所示的状态: 接下来,客户端c10086继续向服务器发送MULTI命令,并将一个SET命令放入事务队列: 12345c10086&gt; MULTIOKSET &quot;name&quot; &quot;peter&quot;QUEUED 这时,另一个客户端c999向服务器发送了一条SET命令,设置&quot;name&quot;键值 12c999&gt; SET &quot;name&quot; &quot;john&quot;OK c999执行的这个SET命令会导致正在监视&quot;name&quot;键的所有客户端的REDIS_DIRTY_CAS标识被打开,其中包括客户端c10086. 之后,c10086向服务器发送EXEC命令的时候,因为c10086的REDIS_DIRTY_CAS已经被打开,所以服务器将拒绝执行它提交的事务 12c10086&gt; EXEC(nil) 事务的ACID性质 在Redis中,事务总有原子性,一致性和隔离性,并且当Redis运行在某种特定的持久化模式下时,事务也具有持久性 重点回顾 在事务中多个命令会被入队到FIFO队列中等待执行 事务在执行过程中不会被终端,当十五队列中的梭鱼命令都被执行完毕之后,事务才会结束 带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联,当键值被修改时,程序会将所有监视被修改的键的客户端的REDIS_DIRTY_CAS标识打开 只有在REDIS_DIRTY_CAS标志未被打开时,服务器才会执行客户端提交的事务,否则的话,服务器将拒绝执行客户端提交的事务 Redis的事务总是具有ACID中的原子性,一致性和隔离性的,当服务器运行在AOF持久化模式下,并且appendfsync选项值为always时,事务也具有耐久性]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-哨兵]]></title>
    <url>%2Fredis-11%2F</url>
    <content type="text"><![CDATA[概览 Sentinel(哨兵)是Redis高可用性解决方案: 由一个或多个哨兵实例组成的哨兵系统可以监视任意多个主服务器,以及这些主服务器属下的所有从服务器,并在被监视的主服务器进入下线状态时,自动将下线主服务器属下的某个从服务器升级为新的主服务器 获取主服务器信息 哨兵默认会以十秒一次的频率,通过命令连接向被监视的主服务器发送INFO命令,并通过分析INFO命令的回复来获取主服务器的当前信息 通过分析主服务器返回的INFO命令回复,哨兵可以获取一下两方面的信息: 关于主服务器本身的信息 包括run_id域记录的服务器运行ID,以及role域记录的服务器角色 关于主服务器属下所有从服务器的信息 记录了从服务器的IP地址和端口号,哨兵无需用户提供从服务器的地址信息就可以发现从服务器 选举领头哨兵 当一个主服务器被判断为客观下线时,见识这个下线主服务器的各个哨兵会进行协商,选举出一个领头哨兵,并由领头哨兵对下线主服务器执行故障转移操作 以下是Redis选举领头哨兵的方法: 所有在线的哨兵都有被选为领头哨兵的资格,换句话说,监视同一个主服务器的多个在线哨兵中的任意一个都有可能成为领头哨兵 每次进行领头哨兵选举之后,不论选举是否成功,所有哨兵的配置纪元的值都会自增一次 在一个配置纪元里面,所有哨兵都有一次将某个哨兵设置为局部领头哨兵的机会,并且局部领头一旦设置,在这个配置纪元里面就不能再更改 每个发现主服务器进入客观下线的哨兵都会要求其他哨兵将自己设置为局部领头 当一个源哨兵向另一个目标哨兵发送SENTINEL is-master-down-by-addr命令,并且命令中的runid参数不是*符号而是源哨兵的运行ID时,表示源哨兵要求目标哨兵将前者设置为后者的局部领头哨兵 哨兵设置领头哨兵的规则是先到先得,最先向目标哨兵发送设置要求的源哨兵将成为目标哨兵的局部领头哨兵,而之后接收到的所有设置要求都会被目标哨兵拒绝 目标哨兵在接收到SENTINEL is-master-down-by-addr命令之后将向源哨兵返回一条命令回复,回复中的leader_runid参数和leader_epoch参数分别记录了目标哨兵的局部领头哨兵的运行ID和配置纪元 源哨兵在接收到目标哨兵返回的命令回复之后,会检查其中的leader_epoch参数值和自己的配置纪元是否相同,如果相同的话,那么源哨兵将继续取出回复中的leader_runid参数,如果leader_runuid参数的值和源哨兵的运行ID一致,那么表示目标哨兵将源哨兵设置为了局部哨兵 如果有某个哨兵被半数以上的哨兵设置成了局部领头哨兵,那么这个哨兵成为领头哨兵 因为哨兵的产生需要半数以上哨兵的支持,并且每个哨兵在背个配置纪元里面只能设置一次局部领头哨兵,所以在一个配置纪元里面只会出现一个领头哨兵 在给定期限内如果没有一个哨兵被选举为领头哨兵,那么哥哥哨兵将在一段时间之后再次进行选举,直到选出领头哨兵为止 故障转移 在选举产生出领头哨兵之后,领头哨兵将对已下线的主服务器执行故障转移操作,该操作包含以下三个步骤: 在已下线主服务器所辖所有从服务器里面,挑选出一个从服务器,并将其转换为主服务器 让已下线主服务器输下的所有从服务器改为新主服务器的从服务器 将已下线主服务器设置为新的主服务器的从服务器,当这个旧的主服务器重新上线时,他就会成为新的主服务器的从服务器 选出新的主服务器 大概规则就是挑选出在线的,复制偏移量最大的服务器,一样大就比较runID 修改从服务器的复制目标 即向从服务器发送SLAVEOF指令 将旧的主服务器变为从服务器 因为旧的主服务器已经下线,所以这种设置是保存在已下线旧主服务器对应的实例结构里面的,当就主服务器重新上线后,哨兵就会立即向他发送SLAVEOF命令 重点回顾 哨兵值是一个运行在特殊模式下的Redis服务器,它使用了和普通模式不同的命令表,所以哨兵模式能使用的命令和普通的Redis服务器能够使用的命令不同 哨兵会读入用户指定的配置文件,为每个要被检视的主服务器创建响应的实例结构,并创建连向主服务器的命令连接和订阅连接 哨兵通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息,并为这些从服务器创建相应的实力结构,以及连向这些从服务器的命令连接和订阅连接 在一般情况下,哨兵以每十秒一次的频率向被监视的主服务器和从服务器发送INFO命令,当主服务器处于下线状态,或者哨兵正在对主服务器进行故障转移操作时,哨兵向从服务器发送INFO命令的频率会改为每秒一次 对于监视同一个主服务器和从服务器的说个哨兵来说,它们会每两秒一次通过向被监视服务器的__sentinel__:hello频道发送消息来向其他哨兵宣告自己的存在 每个哨兵也会从__sentinel__:hello频道中接受其他哨兵发来的信息,并根据这些信息为其他哨兵创建响应的实例结构以及命令连接 哨兵只会与主服务器和从服务器创建命令连接和订阅连接,哨兵与哨兵之间只会创建命令连接 哨兵会以每秒一次的频率向实例(包括主服务器,从服务器,其他哨兵)发送PING命令,并根据实例对PING命令的回复来判断实例是否在线,当一个实例在指定的市场中连续向哨兵发送无效回复时,哨兵会将这个实例判断为主观下线 当哨兵将一个主服务器判断为主观下线时,它会向同样监视这个主服务器的其他哨兵进行询问,看他们是否同意这个主服务器已经进入主观下线的状态 当哨兵收集到足够多的的主观下线投票之后,它会将主服务器判断为客观下线,并发起一次针对主服务器的故障转移操作]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-复制]]></title>
    <url>%2Fredis-10%2F</url>
    <content type="text"><![CDATA[复制功能的实现 PSYNC命令具有完整重同步和部分重同步两种模式: 完整重同步 用于处理初次复制情况,完整重同步通过让主服务器创建并发送RDB文件,以及向从服务器发送保存在缓冲区里的写命令来同步 部分重同步 用于处理断线后重复制情况,当从服务器在断线后重新连接主服务器时,如果条件允许,主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器,从服务器只要接受并执行这些写命令就可以将数据库更新至主服务器当前所处的状态 部分重同步的实现 部分重同步功能由以下三个部分构成: 主服务器的复制偏移量和从服务器的复制偏移量 主服务器的复制挤压缓冲区 服务器的运行ID 复制偏移量 执行复制的双方,主服务器和从服务器会分别维护一个复制偏移量: 主服务器每次向从服务器传播N个字节的数据,就将自己的复制偏移量的值加上N,从服务器每次收到主服务器传播来的N个字节的数据时,就将自己的复制偏移量的值加上N 通过对比主从服务器的复制偏移量,程序可以很容易地知道主从服务器是否处于一致状态: 如果主从服务器的偏移量是相同的,那么它们处于一致状态 如果主从服务器的偏移量并不相同,那么说明主从服务器并未处于一致状态 复制积压缓冲区 复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列,默认大小为1MB 当主服务器进行命令传播时,它不仅会将写命令发送给所有从服务器,还会将写命令入队到复制挤压缓存里面 主服务器的复制积压缓冲区中会保存着一部分最近传播的写命令,并且复制积压缓冲区会为队列中俄每个字节记录相应的复制偏移量 当从服务器重新连接上主服务器时,从服务器会通过PSYNC命令将自己的复制偏移量offset发给主服务器,主服务器会根据这个偏移量来决定从服务器执行何种同步操作 如果从服务器的offset偏移量之后的数据仍然存在于主服务器的复制积压缓冲区,那么主服务器将对从服务器执行部分重同步操作 如果offset偏移量之后的数据已经不存在于复制积压缓冲区,那么主服务器将对从服务器执行完整重同步操作 服务器运行ID 每个Redis服务器,不论主服务器还是从服务器,都会有自己的运行ID,每个运行ID在服务器启动时自动生成,由40个随机的十六进制字符组成 当从服务器对主服务器进行初次复制时,主服务器会将自己的运行ID传给从服务器,而从服务器则会将这个运行ID保存起来.当从服务器断线并连上一个主服务器时,从服务器将向当前连接的主服务器发送之前保存的ID 如果从服务器保存的ID和当前连接的主服务器的运行ID相同,那么说明从服务器短线之前复制的就是当前连接的这个主服务器,主服务器可以继续尝试执行部分重同步操作 相反的,如果从服务器之前保存的ID和当前连接的主服务器的运行ID并不相同,那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器,主服务器会对从服务器执行完整重同步操作 复制的步骤 通过向从服务器发送SLAVEOF命令,可以让一个从服务器去复制一个主服务器 步骤1:设置主服务器的地址和端口 首先,从服务器客户端向从服务器发送命令: 12127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379OK 从服务器首先要做的是将客户端给定的主服务器IP和端口号保存到服务器状态中,之后向客户端返回OK,表示复制指令已经被接收,而实际的复制工作将在OK返回之后才真正开始执行 步骤2:简历套接字链接 在SLAVEOF命令执行之后,从服务器将根据命令所设置的IP地址和端口,创建联想主服务器的套接字链接 如果从服务器创建的套接字能成功连接到主服务器,那么从服务器将为这个套接字关联一个专门用于处理复制工作的事件处理器,这个处理器负责执行后续的复制工作,比如接受RDB文件,以及接受主服务器传来的写命令,诸如此类 而主服务器在接受从服务器的套接字连接之后,将为该套接字创建响应的客户端状态,并将从服务器看作是一个连接到主服务器的客户端来看待.因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进行,所以&quot;从服务器是主服务器的客户端&quot; 步骤3:发送PING命令 从服务器成为主服务器的客户端之后,要想主服务器发送一个PING命令 这个PING命令有两个作用: 虽然主从服务器成功建立起了套接字连接,但是双方并未使用该套接字进行过任何通信,通过发送PING命令可以检查套接字的读写状态是否正常 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态改下才能进行,通过PING命令可以检查主服务器能否正常处理命令请求 步骤4:身份验证 如果从服务器设置了masterauth选项,那么进行身份验证 从服务器向主服务器发送一条AUTH命令,命令的参数为服务器masterauth选项的值 如果主服务器没有设置requirepass选项,而且从服务器没有设置masterauth选项,那么主服务器将只需执行从服务器发送的命令,复制工作可以继续进行 如果从服务器通过AUTH发送的密码和主服务器requirepass选项所设置的密码相同,那么主服务器将继续执行从服务器发送的命令,复制工作可以进行;与此相反,如果从服务器设置的密码不相同,那么主服务器将返回一个invalid password错误 如果主服务器设置了requirepass选项,但从服务器没有设置masterauth选项,那么主服务器将返回一个NOAUTH错误;如果主服务器没有设置requirepass选项,但是从服务器设置了masterauth选项,那么主服务器将返回一个no password is set错误 步骤5:发送端口信息 在身份验证步骤之后,从服务器向主服务器发送从服务器的监听端口号 主服务器在接收从服务器的监听端口号之后,会将端口号记录在从服务器所对应的客户端状态属性中 步骤6:同步 从服务器将向主服务器发送PSYNC命令,执行同步操作,并将自己的数据库更新至主服务器数据库当前所处的状态 步骤7:命令传播 当完成了同步之后,主从服务器将会进入命令传播阶段,这时主服务器只要一直将自己执行的写命令发送给从服务器,而从服务器只要一直接收并执行主服务器发来的写命令.就可以保证主从服务器一直保持一致了 心跳检测 在命令传播阶段,从服务器默认会以每秒一次的频率,向主服务器发送命令:REPLCONF ACK {replicationoffset},其中{replicationoffset}是从服务器当前的复制偏移量 心跳检测对主从服务器有三个作用: 检测主从服务器的网络连接状态 辅助实现min-salves选项 Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令.例子:如果min-slaves-to-write设为3,min-slaves-max-lag设为10,则在从服务器的数量小于3,或者三个从服务器的延迟(lag)值都大于等于10秒时,主服务器将拒绝执行写命令 检测丢失命令 重点回顾 部分重同步通过复制偏移量,复制积压缓冲区,服务器ID三个部分来实现 主服务器通过向从服务器传播命令来更新从服务器的状态,保持主从服务器一致,而从服务器则通过向主服务器发送命令来进行心跳检测,以及命令丢失检测]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InnoDB-索引与算法]]></title>
    <url>%2Finnodb-1%2F</url>
    <content type="text"><![CDATA[概述 InnoDB存储引擎支持以下索引: B+树索引 B+树索引是传统意义上的索引.B+树索引并不能找到一个给定键值的具体行,只能找到备查找数据行所在的页,然后把页读入内存,再在内存中查找 全文索引 哈希索引 InnoDB支持的哈希索引是自适应的,InnoDB存储引擎会根据表的使用情况自动为表生产哈希索引,不能人为干预是否在一张表中生成哈希索引 B+树 B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树 B+树的插入操作 Leaf Page满 Index Page满 操作 false false 直接将记录插入到叶子节点 true false 1. 拆分Leaf Page2. 将中间的节点放入到Index Page中3. 小于中间结点的记录放左边4. 大于或等于中间结点的记录放右边 true true 1. 拆分Leaf Page2. 小于中间节点的记录放左边3. 大于或等于中间节点的记录放右边4. 拆分Index Page5. 小于中间结点的记录放左边6. 大于中间结点的记录放右边7. 中间结点放入上一层Index Page 不管怎么变化,B+树总会保持平衡.但是为了保持平衡对于新插入的键值可能会做大量的拆分页操作.因为B+树结构主要用于磁盘,页的拆分意味着磁盘操作,所以应该在可能的情况下尽量减少页的拆分操作,因此,B+数同样提供了类似平衡二叉树的旋转的功能 B+树索引 B+树做引在数据库中有一个特点是高扇出性,因此在数据库中,B+树高度一般都在24层,也就是说查找某一键值记录时最多只需要24次磁盘IO B+树索引可以分为聚集索引和辅助索引.不管是聚集索引还是辅助索引,其内部都是B+树的,即高度平衡,叶子节点存放着所有的数据.聚集索引与辅助索引不同的是,叶子节点存放的是否是一整行的信息 聚集索引 InnoDB存储引擎表是索引组织表,即表中数据按照主键顺序存放,而聚集索引就是按照每张表的主键构造一棵B+树,同时叶子节点存放的即为整张表的行记录数据,也将聚集索引的叶子节点成为数据页.聚集索引的这个特性决定了索引组织表中数据也是索引的一部分 由于实际的数据页只能按照一棵B+树进行排序,因此每张表只能拥有一个聚集索引. 辅助索引 对于辅助索引,叶子节点并不包含行记录的全部数据.叶子节点除了包含键值以外,每个叶子节点中的索引行中还包含了一个书签,该书签告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据.由于InnoDB存储引擎表是索引组织表,因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键 辅助索引的存在并不影响数据在聚集索引中的组织,因此每张表上可以有多个辅助索引.当通过辅助索引来寻找数据时,InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获取指向主键索引的主键,然后再通过主键索引来找到一个完整的行记录 Cardinality值 概述 并不是在所有的查询条件中出现的列都需要添加索引.如果某个字段取值范围很窄,则完全没有必要,相反,如果某个字段取值范围很广,几乎没有重复,即属于高选择性,则此时使用B+树索引是最合适的 索引是否有高选择性可以通过SHOW INDEX结果中的列Cardinality值来观察.Cardinality值非常关键,表示索引中不重复记录数量的预估值.在实际应用中,Cardinality/n_rows_in_table应尽可能地接近于1.如果非常小,那么用户需要考虑是否还有创建这个索引的必要.故在访问高选择性属性的字段并从表中取出很少一部分数据时,对这个字段添加B+树索引是非常有必要的. InnoDB存储引擎的Cardinality统计 数据库对Cardinality值的统计都是通过采样的方法来完成的. 在InnoDB存储引擎中,Cardinality统计信息的更新发生在两个操作中:INSERT和UPDATE.不可能每次发生INSERT和UPDATE时就去更新Cardinality信息,这样会增加数据库系统的负荷. InnoDB存储引擎内部对更新Cardinality信息的策略为: 表中1/16的数据已发生过变化 stat_modified_counter&gt;2000000000 B+树索引的使用 联合索引 联合索引也是一棵B+树,不同的是联合索引的键值的数量不是1,而是大于等于2. 覆盖索引 优化器选择不适用索引的情况 多发生于范围查找,JOIN链接操作等情况下. 若用户有足够信心使用辅助索引可以带来更好的性能,那么可以使用关键字FORCE INDEX来强制使用某个索引 索引提示 MySQL数据库支持索引提示,显式地告诉优化器使用哪个索引.下面时两种可能需要用到INDEX HINT的情况: MySQL数据库的的优化器错误地选择了某个索引,导致SQL语句运行的很慢 某SQL语句可以选择的索引非常多,这时优化器选择执行时间的开销可能会大于SQL语句本身的时间开销 Mult-Range Read优化 Multi-Range Read(MRR)优化的目的是为了减少磁盘的随机访问,并且将随机访问转化为较为顺序的数据访问,这对于IO-bound类型的SQL查询语句带来性能极大的提升.MRR优化可适用于range,ref,eq_ref类型的查询 MRR优化有以下好处: MRR是数据访问变得较为顺序 在查询辅助索引时,首先根据得到的查询结果按照主键进行排序,并按照主键顺序进行书签查找 减少缓冲池中页被替换的次数 批量处理对键值的查询操作 对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作,MRR的工作方式如下: 将查询得到的辅助索引键值存放于一个缓存中,这时缓存中的数据时根据辅助索引键值排序的 将缓存中的键值根据RowId进行排序 根据RowID的排序顺序来访问实际的数据文件 Index Condition Pushdown(ICP)优化 TODO 哈希算法 哈希表 InnoDB存储引擎中的哈希算法 InnoDB存储引擎使用哈希算法来对字典进行查找,其冲突机制采用链表方式,哈希函数采用除法散列方式. 自适应哈希索引 自适应哈希索引经哈希函数映射到一个哈希表中,因此对于字典类型的查找非常快速.但是范围查找就无能为力了. 全文检索 概述 全文检索是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术.它可以根据需要获得全文中有关章节段句词等信息,也可以进行各种统计和分析 倒排索引 全文检索通常使用倒排索引来实现.倒排索引同B+树索引一样,也是一种索引结构,它在辅助表中存出来单词与单词自身在一个活多个文档中所在位置之间的映射.这通常利用关联数组实现. InnoDB全文索引 TODO]]></content>
      <categories>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InnoDB关键特性]]></title>
    <url>%2Finnodb%2F</url>
    <content type="text"><![CDATA[插入缓冲 Insert Buffer和数据页一样,是物理页中的一部分. 在InndoDB存储引擎中,主键是行唯一的标识符.通常应用程序中行记录的插入顺序是按照主键递增的顺序插入的]]></content>
      <categories>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-AOF持久化]]></title>
    <url>%2Fredis-9%2F</url>
    <content type="text"><![CDATA[概述 RDB持久化通过保存数据库中的键值对来记录数据库状态 AOF通过Redis服务器所执行的写命令来记录数据库状态 比如,空白的数据库执行以下命令: 12345678redis&gt; SET msg &quot;hello&quot;OKredis&gt; SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;(integer) 3redis&gt; RPUSH numbers 128 256 512(integer) 3 RDB持久化保存数据库状态的方法是将msg,fruits,numbers三个键的键值对保存到RDB文件中,而AOF持久化保存数据库状态的方法则是将服务器执行的SET,SADD,RPUSH三个命令保存到AOF文件中 被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的,因为Redis的命令请求协议是纯文本格式,所以我们可以直接打开一个AOF文件来观察里面的内容 比如,对于上面的三个写命令来说,服务器将产生包涵一下内容的AOF文件: 1234*2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n*3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n*5\r\n$4\r\nSADD\r\n$6\r\nfruits\r\n$5\r\napple\r\n$6\r\nbanana\r\n$6\r\ncherry\r\n*5\r\n$5\r\nRPUSH\r\n$7\r\nnumbers\r\n$3\r\n123\r\n$3\r\n256\r\n$3\r\n512\r\n 在这个AOF文件里面,除了用于指定数据库的SELECT命令是服务器自动添加的之外,其他都是我们之前通过客户端发送的命令 AOF持久化的实现 AOF持久化功能的实现可以分为命令追加,文件写入,文件同步三个步骤 命令追加 当AOF持久化功能处于打开状态时,服务器在执行完一个写命令后,回忆协议格式将被执行的谢明令追加到服务器状态的aof_buf缓冲区的末尾 AOF文件的写入与同步 Redis的服务器进程就是一个时间循环(loop),这个循环中的时间负责接收客户端的命令请求,以及向客户端发送命令回复,而时间事件则负责像serverCron函数这样需要定时运行的函数 因为服务器在处理文件事件时可能会执行写命令,使得一些内容被追加到aof_buf缓冲区里面,所以服务器每次结束一个事件循环,它都会调用flushAppendOnlyFile函数,考虑是否将aof_buf缓冲区中的内容写入或保存到AOF文件里面. 123456789101112def eventLoop(): while True: # 处理文件时间,接受命令请求以及发送命令回复 # 处理命令请求时可能会有新内容被追加到aof_buf中 processFileEvents() # 处理时间事件 processTimeEvents() # 考虑是否将aof_buf中俄内容写入和保存到APF文件里面 flushAppendOnlyFile() flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定,各个不同值代表的行为: appendfsync选项值 flushAppendOnlyFile函数的行为 always 将aof_buf缓冲区中的所有内容写入并同步到AOF文件 everysec(默认) 将aof_buf缓冲区中的所有内容写入到AOF文件,如果上次同步AOF文件的时间距离现在超过一秒钟,那么在此对AOF文件进行同步,并且这个同步操作是有一个线程专门负责执行的 no 将aof_buf缓冲区中的所有内容写入到AOF文件,但并不对AOF文件进行同步,何时同步由系统决定 文件的写入与同步为了提高文件写入的效率,在现代操作系统中,当用户调用write函数,将一些数据写入到文件的时候,操作系统通常会将写入数据暂时保存在一个内存缓冲区里面,等到缓冲区的时间被填满,或者超过了指定的时限之后,才真正地将缓冲区中的数据写入到磁盘如果极端及发生停机的话,缓冲区里的数据将会消失. AOF持久化的效率和安全性 服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性 always 服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件,并且同步AOF文件,所以always失效率最慢的,但也是最安全的,因为即使出现故障停机,AOF持久化也只会丢失一个时间循环中所产生的的命令数据 everysec 效率:足够快,就算出现故障停机,数据库只会丢掉1秒钟的命令数据 no 效率:最快,安全:我谔谔 AOF文件的载入与数据还原 Redis读取AOF文件并还原数据库状态的详细步骤如下: 创建一个不带网络连接的伪客户端 因为Redis的命令只能在客户端上下文中执行,而载入AOF问件事所使用的命令直接来源于AOF文件而不是网络连接,所有服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的谢明令,伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样 从AOF文件中分析并读取一条写命令 使用伪客户端执行被独处的写命令 不断重复2和3,知道AOF文件中的所有写命令都被处理完毕为止 AOF重写 随着服务器运行时间的流逝,AOF文件中的内容会越来越多,文件体积也会越来越大,如果不加以控制,体积过大的AOF文件很可能会对Redis服务器甚至整个宿主计算机造成影响,并且使用AOF文件来进行数据还原所需的时间就越多 为了解决AOF文件体积膨胀的问题,Redis提供了AOF文件重写功能,通过该功能,Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但新AOF文件不会包含任何浪费空间的冗余命令. AOF文件重写的实现 AOF文件重写并不需要对现有的AOF文件进行任何读取,分析或者写入操作,这个功能是通过读取服务器当前数据库状态来实现的 AOF后台重写 Redis将AOF重写程序放到子进程里面执行,这样做可以同时达到两个目的: 子进程进行AOF重写期间,服务器进程可以继续处理命令请求 子进程带有服务器进程的数据副本,使用子进程而不是线程,可以在避免使用锁的情况下,保证数据的安全 不过,使用子进程也有一个问题需要解决:因为子进程在进行AOF重写期间,服务器进程还需要继续处理命令请求,而新的命令可能会对现有的数据库状态进行修改,从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致. 为结局这种数据不一致的问题,Redis服务器设置了一个AOF重写缓冲区,这个缓冲区在服务器创建子进程之后开始使用,当Redis服务器执行完一个命令之后,它会同时将这个写命令发送给AOF缓冲区与AOF重写缓冲区. 这样一来可以保证: AOF缓冲区的内容会被定期写入和同步到AOF文件,对现有AOF文件的处理工作会如常进行 从创建子进程开始,服务器执行的所有写命令都会被记录到AOF重写缓冲区里面 当子进程完成AOF重写工作执行,它会想主进程发送一个信号,主进程在接受到信号后,会调用一个信号处理函数: 将AOF重写缓冲区中的所有内容写入到新AOF文件中 对新AOF文件进行改名,覆盖现有的AOF文件,完成新旧AOF文件的替换 重点回顾 AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态 AOF文件中的所有命令都以Redis命令请求协议的格式保存 命令请求会先保存到AOF缓冲区里面,之后再定期写入并同步到AOF文件 服务器载入并重新执行保存在AOF文件中的命令来还原数据库原本的状态 AOF重写可以产生一个新的AOF文件,这个新的AOF文件和原有的AOF文件所保存的数据库状态一样,但体积更小]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-RDB持久化]]></title>
    <url>%2Fredis-8%2F</url>
    <content type="text"><![CDATA[概述 RDB出九华既可以手动执行,也可以根据服务器配置选项进行定期执行,该功能可以将某个时间点上的数据库状态保存到一个RDB文件中;RDB出九华功能所生成的RDB文件是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件生成时的数据库状态 RDB文件的创建与载入 SAVE命令和BGSAVE命令可以用于生成RDB文件,SAVE命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器阻塞期间,服务器不能处理任何命令请求;BGRDB命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程继续处理命令请求. 另外,因为AOF文件的更新频率通常比RDB文件的更新频率更高,所以如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件来还愿数据库状态,只要在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还愿数据库状态. SAVE命令执行时的服务器状态 阻塞 BGSAVE命令执行时的服务器状态 继续处理客户端的命令请求,但是,在BGSAVE命令执行期间,服务器处理SAVE,BGSAVE,BGWRITEAOF三个命令的方式会和平时有所不同 在BGSAVE命令执行期间,客户端发送的SAVE和BGSAVE命令会被服务器拒绝 其次,BGWRITEAOF和BGSAVE两个命令不能同时进行,如果BGSAVE命令正在执行,那么客户端发送的BGWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行;如果BGWRITE命令正在执行,那么客户端发送的BGSAVE命令会被服务器拒绝. 因为BGWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行,所以两个命令在操作方面并没有冲突的地方,不能同时执行它们值是一个性能方面的考虑. RDB文件载入时的服务器状态 阻塞 自动间隔保存 用户可以通过save选项设置多个保存条件,只要其中任意一个条件被满足,服务器就会执行BGSAVE命令 比如,我们的配置如下: 123save 900 1save 300 10save 60 10000 那么只要满足以下三个条件中的任意一个,BGSAVE命令就会被执行: 服务器在900s之内对数据库进行了至少1次修改 服务器在300s之内对数据库进行了至少10次修改 服务器在60s之内对数据库进行了至少10000次修改 dirty计数器和lastsave属性 除了saveParams数组之外,服务器状态还维持着一个dirty计数器,以及一个lastsave属性: dirty计数器距离上一次成功执行SAVE命令或者BGSAVE命令之后,服务器对数据库状态进行了多少次修改 lastsave属性是一个UNIX时间戳,记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间 检查保存条件是否满足 Redis的服务器周期性操作函数serverCron默认每隔100毫秒会执行一次,该函数用于对正在运行的服务器进行维护,它的其中一项工作就是检查save选项锁设置的保存条件是否已经满足,如果满足的话,就执行BGSAVE命令 RDB文件结构 一个完整的RDB文件包含的各个部分: REDIS db_version databases EOF check_num 上表中的字母大写的单词表示常量,小写的单词表示变量 REDIS RDB文件最开头是&quot;REDIS&quot;五个字符.通过这五个字符,程序可以在载入文件时,快速检查锁载入的文件是不是RDB文件(类似魔数?) db_version 记录RDB文件版本号的整数 database database部分包含着零个或任意多个数据库,以及各个数据库中的键值对数据 EOF EOF常量的长度为1字节,标志着RDB文件正文内容的结束,当读入程序遇到EOF的时候,他知道所有数据库的所有键值对都已经载入完毕了 check_num check_num是一个8字节长度的无符号证书,保存着一个校验和,这个校验和是程序通过对REDIS,db_version,database,EOF四个部分内容进行计算得出的,服务器在载入RDB文件时会将载入数据所计算得出的校验和与check_num所记录的校验和进行对比,以此来检查RDB文件是否有出错或者损坏的情况出现.(类似于下载文件后,用于校验的md5?) database部分 一个RDB文件的database部分可以保存任意多个非空数据库 例如,如果服务器的0号数据库和3号数据库非空,那么服务器将创建一个如下所示的RDB文件: REDIS db_version database0 database3 EOF check_num 每个非空数据库在RDB文件中都保存为SELECTDB,db_number,key_value_pairs三个部分: SELECTDB db_number key_value_pairs SELECTDB常量 长度为1字节,当读入程序遇到这个值的时候,它知道接下来要读入的将是一个数据库号码 db_number 保存着一个数据库号码,当程序读入db_number部分之后,服务器会调用SELECT命令,根据读入的数据库号码进行数据库切换,似的之后读入的键值对可以载入到正确的数据库中 key_value_pairs 保存了数据库中的所有键值对数据,如果键值对带有过期时间,那么过期时间也会和键值对保存在一起. key_value_pairs部分 RDB文件中每个key_value_pairs部分都保存了一个活以上数量的键值对,如果键值对带有过期时间的话,那么键值对的过期时间也会被保存在内. 不带过期时间的键值对在RDB文件中由TYPE,key,value三部分组成. TYPE key value TYPE记录了value的类型 TYPE值可以是以下常量的其中一个 REDIS_RDB_TYPE_STRING REDIS_RDB_TYPE_LIST REDIS_RDB_TYPE_SET REDIS_RDB_TYPE_ZSET REDIS_RDB_TYPE_HASH REDIS_RDB_TYPE_LIST_ZIPLIST REDIS_RDB_TYPE_SET_INTLIST REDIS_RDB_TYPE_ZSET_ZIPLIST REDIS_RDB_TYPE_HASH_ZIPLIST 当服务器读入RDB文件中的键值对数据时,程序会根据TYPE的值来决定如何读入和解释value的数据 设有过期时间的键值对在RDB文件中的结构: EXPIRETIME_MS ms TYPE key value EXPIRETIME_MS常量告知读入程序,接下来要读入的僵尸一个以毫秒为单位的过期时间 ms是一个8字节长的带符号的证书,记录着一个以毫秒为单位的UNIX时间戳,代表键值对的过期时间 value的编码 TODO 分析RDB文件 od命令 不包含任何键值对的RDB文件 12345redis&gt; FLUSHALLOKredis&gt; SAVEOK 然后调用od命令,打印RDB文件 1234$ od -c dump.rdb0000000 R E D I S 0 0 0 6 377 334 263 C 360 Z 3340000020 362 V0000022 最开头是&quot;REDIS&quot;字符串,之后的006是版本号,再之后的一个字节377代表EOF常量,最后的334 263 C 360 Z 334 362 V八个字节则代表RDB文件的校验和 包含字符串键的RDB文件 TODO 重点回顾 RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据 SAVE命令由服务器进程直接执行保存操作,所以该命令会阻塞服务器 BGSAVE命令由子进程执行保存操作,所以该命令不会阻塞服务器 服务器状态中会保存所有用save选项设置的保存条件,当任意一个条件被满足时,服务器会自动执行BGSAVE命令 RDB文件是一个经过亚索的二进制文件,由多个部分组成 对于不同的键值对,RDB文件会用不同的方式保存它们]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据库]]></title>
    <url>%2Fredis-7%2F</url>
    <content type="text"><![CDATA[数据库键空间 Redis是一个键值对数据库服务器,服务器中的每个数据库都由一个redisDb结构表示,其中,redisDb结构的dict字典保存了数据库中的所有键值对,我们将这个字典成为键空间(key space) 键空间和用户所见的数据库时直接对应的: 键空间的键也就是数据库的键,每个键都是一个字符串对象 键空间的值也就是数据库的值,每个值都可以是字符串对象,列表对象,哈希表对象,集合对象和有序集合对象中的任意一种Redis对象 添加新建 12redis&gt; SET date &quot;2013.12.1&quot;OK 新增一个键为&quot;date&quot;字符串对象,而键值对的值则是一个&quot;2013.12.1&quot;的字符串对象 删除键 12redis&gt; DEL book(integer) 1 更新键 12redis&gt; SET date &quot;2019.09.10&quot;OK 对键取值 12redis&gt; GET date&quot;2019.09.10&quot; 其他键空间操作 除了上面的操作之外,还有很多针对数据库本身的Redis命令,也是通过对键空间进行处理来完成的 比如,用于清空整个数据库的FLUSHDB命令,就是通过删除键空间的所有键值对来实现的;用于随机返回数据库中某个键的RANDOMKEY命令,就是通过在键空间中随机返回一个键来实现的 另外,用于返回数据库键数量的DBSIZE命令,就是通过返回键空间中包含的键值对的数量来实现的.类似的命令还有EXISTS,RENAME,KEYS等,这些命令都是通过对键值对进行操作来实现的 读写键空间时的维护操作 当使用Redis命令对数据库进行读写时,服务器不仅会对键空间执行指定的读写操作,还会执行一些额外的维护操作: 在读取一个键之后(读操作和写操作都需要对键进行读取),服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数,这两个值可以在INFO stats命令的keyspace_hits属性或者keyspace_misses属性中查看 在读取一个键之后,服务器会更新键的LRU时间,这个值可以用于计算键的闲置时间 如果服务器在读取一个键时发现该键已经过期,那么服务器会先删除这个过期键,然后才执行余下的其他操作 如果有客户端使用WATCH命令监视了某个键,那么服务器在对被监视的键进行修改之后,会将这个键标记为脏,从而让食物程序注意到这个键已经被修改过 服务器每次修改一个键之后,都会对脏舰计算器的值增1,这个计数器会触发服务器的持久化以及复制操作 如果服务器开启了数据库通知功能,那么在对键进行修改之后,服务器将按配置发送相应的数据库通知 设置键的生存时间或过期时间 通过EXPIRE命令或者PRXPIRE命令,客户端可以以喵或者毫秒精度为数据库中的某个键设置生存时间(Time To Live, TTL),在经过指定的秒数或者毫秒数后,服务器就会自动删除生存时间为0的键 1234567891011redis&gt; SET key valueOKredis&gt; EXPIRE key 5(integer) 1redis&gt; GET key // 5秒内&quot;value&quot;redis&gt; GET key // 5秒后(nil) EXPIRE命令以秒为单位,PEXPIRE命令以毫秒为单位,代表键的生存时间 EXPIREAT命令以秒为单位,PEXPIREAT命令以毫秒为单位,为某个键设置过期时间 过期时间是一个UNIX时间戳,当键的过期时间来临时,服务器就会自动从数据库中删除这个键 保存过期时间 redisDb结构的expires字典保存了上课中所有键的过期时间 过期字典的键是一个指针,这个指针指向键空间中某个键对象(也即是某个数据库键) 过期字典的值是一个long long类型的证书,这个证书保存了键所指向的数据库键的过期时间,一个毫秒精度的UNIX时间戳 过期键的判定 通过过期字典,程序可以用以下步骤检查一个给定的键是否过期: 检查给定键是否存在于过期字典:如果存在,那么获取键的过期时间 检查当前UNIX时间戳是否大于键的过期时间:如果是的话,那么舰已过期;否则键未过期 过期键删除策略 定时删除 在设置键的过期时间同时,创建一个定时器(timer),让定时器在键的过期时间来临时,立即执行对键的删除操作 定时删除策略对内存是友好的:通过使用定时器,定时删除策略可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存 另一方面,定时删除策略的缺点是,它对CPU时间是最不友好的:在过期键比较多的qingkuangxia,删除过期键这一行为可能会占用相当一部分CPU时间,在内存不紧张但是CPU时间非常紧张的情况下,将CPU时间用在删除和当前任务无关的过期键上,会对服务器的响应时间和吞吐量造成影响 除此之外,创建一个定时器需要用到Redis服务器中的时间事件,而当前时间时间的实现方式是无序链表,查找一个事件的时间复杂度是O(N),并不能高效的处理大量时间事件 因此,要让服务器创建大量的定时器,从而实现定时删除策略,在现阶段来说并不现实 惰性删除 放任键过期不管,但是每次从键空间中获取键时,都检查取得的键是否过期,如果过期的话就删除该键,如果没有过期则返回该键 惰性删除策略对CPU时间来说是最友好的,程序只会在取出键时才对键进行过期检查,这可以保证删除过期键的操作只会在非做不可的情况下进行,并且删除的目标仅限于当前处理的键,这个策略不会再删除其它无关的过期键上花费任何CPU时间 惰性删除策略的缺点是,它对内存是最不友好的,如果一个键已经过期,而这个键又仍然保留在数据库中,那么只要这个过期键不被删除,它所占用的内存就不会释放 在使用惰性删除策略时,如果数据库中有非常多的过期键,而这些过期键又恰好没有被访问到的话,那么它们也许永远不会被删除,我们甚至可以将这种情况看作是一种内存泄漏 定期删除 每隔一段时间,程序就对数据库进行一次检查,删除里面的过期键 定期策略时前两种策略的一种整合和折中: 定期删除策略每隔一段时间执行一次删除过期键的操作,并通过限制删除操作执行的时长和频率来尖山删除操作对CPU时间的影响 除此之外,通过定期删除过期键,定期删除策略有效地减少了因为过期键而带来的内存浪费 定期删除策略的难点是确定删除操作执行的时长和频率: 如果删除操作执行得太频繁,或者执行时间太长,定期删除策略就会退化成定时删除策略,以至于将CPU时间过多地消耗在删除过期键上面 如果删除操作执行得太少,或者执行的时间太短,定期删除策略又会和惰性删除策略一样,出现浪费内存的情况 Redis的过期键删除策略 Redis服务器实际使用的是惰性删除和定期删除两种策略,通过配合使用这两种删除策略,服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡 惰性删除策略的实现 所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查: 如果输入键已经过期,那么expireIfNeeded函数将输入键从数据库中删除 如果键未过期,那么expireIfNeeded函数将不做动作 expireIfNeed函数就像一个过了长期,它可以在命令真正执行之前,过滤掉过期的输入键,从而避免命令接触到过期键 另外,因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除,所以每个命令的实现函数都必须能处理键存在以及键不存在这两种情况 定期删除策略的实现 过期键的定期删除策略由activeExpireCycle函数实现.每当Redis的服务器周期性操作serverCron函数执行时,activeExpireCycle函数就会被调用. 它在规定的时间内,分多次遍历服务器中的各个数据库,从数据库的expires字典中随机检查一部分键的过期时间,并删除其中的过期键 函数每次运行时,都从一定数量的数据库中取出一定数量的随机键进行检查,并删除其中的过期键 全局变量current_db会记录当前activeExpireCycle函数检查的进度,并在下一次activeExpireCycle函数调用时,接着上一次的进度进行处理 随着activeExpireCycle函数的不断执行,服务器中的所有数据库都会被检查一遍,这时函数将current_db变量重置为0,然后再次开始新一轮的检查 AOD,RDB和复制功能对过期键的处理 生成RDB文件 在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时,程序会对数据库中的键进行检查,已过期的键不会被保存到新创建的RDB文件中 // TODO 数据库通知 数据库通知可以让客户端通过订阅给定的频道或者模式,来货值数据库中键的变化,以及数据库中命令的执行情况 // TODO]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构-压缩列表]]></title>
    <url>%2Fredis-5%2F</url>
    <content type="text"><![CDATA[概述 压缩列表(ziplist)是列表键和哈希键的底层实现之一 当一个列表只包含少量列表项,并且每个列表项要么是小整数值,要么就是长度比较短的字符串,那么Redis会使用压缩列表来做列表键的底层实现 例如: 12345redis&gt; RPUSH lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot;(integer) 6redis&gt; OBJECT ENCODING 1st&quot;ziplist&quot; 另外,当一个哈希键质保函少量键值对,并且每个键值对的键和值要么是小整数值,要么是长度比较短的字符串,Redis就会使用压缩列表来做哈希键的底层实现 压缩列表的构成 TODO]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构-整数集合]]></title>
    <url>%2Fredis-4%2F</url>
    <content type="text"><![CDATA[概述 整数集合(intset)是集合键的底层实现之一,当一个集合质保函整数值元素,并且这个集合的元素数量不多时,Redis就会使用整数集合作为集合键的底层实现 12345redis&gt; SADD numbers 1 3 5 7 9(integer) 5redis&gt; OBJECT ENCODING numbers&quot;intset: 在这个例子中,我们创建了一个只包含5个元素的集合键,并且集合中的所有元素都是整数值,那么这个集合键的底层实现就会是整数集合 整数集合的实现 整数集合是Redis用于保存整数值的集合抽象数据结构,它可以保存类型为int16_t, int32_t或者int64_t的整数值,并且保重集合中不会出现重复元素 12345678910typeof struct intset &#123; // 编码方式 unit32_t encoding; // 集合包含的元素数量 unit32_t length; // 保存元素的数组 int8_t contents[];&#125; intset; contents数组是整数集合的底层实现,整数集合的每个元素都是contents数组的一个数组项,各个数组项在树脂中按值的大小从小大大有序地排列,并且数组中不包含任何重复项 length属性记录了整数集合包含的元素数量,也即是contents数组的长度. 虽然intset结构将contains属性声明为int8_t类型的数组,但实际上contents数组并不保存任何int8_t类型的值,contents数组的真正类型取决与encoding属性的值 升级 每当我们需要将一个新元素添加到整数集合里面,并且新元素的类型比钟书记和现有的所有元素的类型都要长时,证书集合需要先进行升级,然后才能将新元素添加到整数集合里面 升级整数集合并添加新元素共分为三步进行: 根据新元素的类型,扩展整数集合底层数组的空间大小,并为其分配空间 将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位上,而且在放置元素的过程中,需要继续维持底层数组的有序性质不变 将新元素添加到底层数组里面 升级的好处 证书集合的升级策略有两个好处,一个是提升整数集合的灵活性,另一个是尽可能地节约内存 提升灵活性 因为C语言是静态类型语言,为了避免类型错误,我们通常不会将两种不同类型的值放在同一个数据结构里面. 例如,我们一般只使用int16_t类型的数组来保存int16_t类型的值,只使用int32_t类型的数组来保存int32_t类型的值 但是,因为整数集合可以通过自动升级底层数组来适应新元素,所以我可以随意地将int16_t,int32_t或者int64_t类型的整数添加到集合中,而不必担心出现类型错误 节约内存 当然,要让一个数组可以同时保存int_16t,int32_t,int64_t三种类型的值最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现,不过这样一来,机师添加到整数集合里面的都是int16_t或者int32_t类型的值,数组都需要使用int64_t类型的空间去保存它们,从而出现浪费内存的情况 而整数集合现在的做法既可以让集合能同时保存三种不同类型的值,又可以确保升级操作只会在有需要的时候进行,这可以尽量节省内存 降级 没有降级 重点回顾 整数集合是集合键的底层实现之一 整数集合的底层实现为数组,这个数组以有序,无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型 升级操作为整数集合带来了操作上的灵活性,并且尽可能地节约了内存 整数集合只支持升级操作,不支持降级操作]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构-跳跃表]]></title>
    <url>%2Fredis-3%2F</url>
    <content type="text"><![CDATA[跳跃表通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的. 跳跃表支持平均O(logN),最坏O(N)复杂度的节点查找,还可以通过顺序性操作来批量处理节点 在大部分情况下,跳跃表的效率可以和平衡树相媲美,并且因为跳跃表的实现比平衡术要来的更为简单,所以有不少程序都使用跳跃表来代替平衡树 Redis使用跳跃表作为有序集合键的底层实现之一,吐过一个有序集合包含的元素数量比较多,又或者有序集合中元素成员是比较长的字符串时,Redis就会使用跳跃表来作为有序集合键的底层实现 12345678910redis&gt; ZRANGE fruit-price 0 2 WITHSCORES1) &quot;banana&quot;2) &quot;5&quot;3) &quot;cherry&quot;4) &quot;6.5&quot;5) &quot;apple&quot;6) &quot;8&quot;redis&gt; ZCARD fruit-price(integer)130 fruit-price有序集合的所有数据都保存在一个跳跃表里面,其中每个跳跃表节点都保存了一款水果的价钱信息,所有水果按价钱的高低从低到高在跳跃表里面排序 和链表,字典等数据结构被广泛地应用在Redis内部不同,Redis只在两个地方用到了跳跃表,一个是实现有序集合键,另一个是在集群节点中用作内部数据结构,除此之外,跳跃表在Redis里面没有其他用途 重点回顾 跳跃表是有序集合的底层实现稚艺 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成,其中zskiplist用于保存跳跃表信息,而zskiplistNode则用于表示跳跃表节点 每个跳跃表节点的层高都是1至32之间的随机数 在同一个跳跃表中,多个节点可以包含相同的分支,但每个节点的对象必须是唯一的 跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构-字典]]></title>
    <url>%2Fredis-2%2F</url>
    <content type="text"><![CDATA[字典的实现 跟HashMap差不多,不过hash碰撞不使用红黑树而是一昧拉链 哈希算法 Redis使用MurmurHash2算法来计算键的哈希值 渐进式rehash 扩展或收缩哈希表的动作并不是一次性,集中地完成的,而是分多次,渐进式地完成的.]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构-链表]]></title>
    <url>%2Fredis-1%2F</url>
    <content type="text"><![CDATA[概述 链表提供了高效的节点重排能力,以及顺序性的节点访问方式,并且可以通过增删节点来灵活地调整链表的长度 链表在Redis中的应用非常广泛,比如列表键的底层实现之一就是链表.当一个列表键包含了数量比较多的元素,又或者列表中包含的元素都是比较长的字符串时,Redis就会使用链表作为列表键的底层实现 除了链表键之外,发布与订阅,慢查询,监视器等功能也用到了链表,Redis服务器本身还使用链表来保存多个客户端的状态信息,以及使用链表来构建客户端缓冲区 Redis链表和链表节点的实现 1234567891011typedef struct listNode &#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *tail; // 节点的值 void *value;&#125;listNode; 1234567891011121314151617181920typedef struct list &#123; // 表头节点 listNode *head; // 表尾节点 listNode *tail; // 链表所包含的节点数量 unsigned long len; // 节点值赋值函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr, void *key);&#125; Redis链表实现的特性: 双端 链表节点带有prev和next指针,获取某个节点的前置节点和后置节点的复杂度都是O(1) 无环 表头节点的prev指针和表尾节点的next指针都指向null,对链表的访问以null为终点 带表头指针和表尾指针 通过list结构的head指针和tail指针,程序获取链表的表头节点和表尾节点的复杂度是O(1) 带连表长度计数器 程序使用list结构的len属性来对list持有的链表节点进行计数,程序获取链表中节点数量的复杂度为O(1) 多态 链表节点使用void*指针来保存节点值,并且可以通过list结构的dup,free,match三个属性为节点值设置类型特定加密手机,所以链表可用于保存各种不同的值 重点回顾 链表被广泛用于实现Redis的各种功能,比如列表键,发布与订阅,慢查询,监视器等 每个链表节点由一个listNode结构来表示,每个节点都有一个指向前置节点的后置节点的指针,所以Redis的链表实现是双端链表 每个链表使用一个list结构来表示,这个结构带有表头结点指针,表尾结点指针以及链表长度等信息 因为链表表头节点的前置节点和表尾节点的后置节点都指向null,所以Redis的链表实现是无环链表 通过为链表设置不同的类型特定函数,Redis的链表可以用于保存各种不同类型的值]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构-字符串]]></title>
    <url>%2Fredis-0%2F</url>
    <content type="text"><![CDATA[简单动态字符串(SDS) Redis自己构建了一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型,并将SDS用作Redis的默认字符串表示. 在Redis中,C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方,比如打印日志: 1redisLog(REDIS_WARNING, "Redis is now ready to exit"); 当Redis需要的不仅仅是一个字符串字面量,而是一个可以被修改的字符串值时,Redis就会使用SDS来表示字符串值,比如在Redis的数据库里面,包含字符串值的键值对在底层都是由SDS实现的. SDS除了用来保存数据库中的字符串之外,SDS还被用作缓冲区:AOF模块中的AOF缓冲区,以及客户端状态中的输入缓冲区,都是由SDS实现的 SDS的定义 123456789101112struct sdshdr &#123; // 记录buf数组中已使用字节的数量 // 等于SDS所保存的字符串的长度 int len; // 记录buf数组中未使用字节的数量 int free; // 字节数组,用于保存字符串 char buf[];&#125; SDS遵循C字符串以空字符结尾的管理,保存空字符串的1字节空间不计算在SDS的len属性里面. 为空字符自动分配额外的1字节空间,以及添加空字符串到字符串末尾等操作都是由SDS函数自动完成的,所以这个空字符串对于SDS的使用者来说是完全透明的. 遵循空字符串结尾这一管理的好处是,SDS可以直接重用一部分C字符串函数库里面的函数 SDS与C字符串的区别 根据传统,C语言使用长度为N+!的字符串数组来表示长度为N的字符串,并且字符数组的最后一个元素总是空字符’\0’ C语言使用这种简单的字符串表示方式,并不能满足Redis对字符串在安全性,效率以及功能方面的要求 区别总结: - C字符串 SDS 获取字符串长度的复杂度 O(N) O(1) 缓冲区安全 不安全 安全 修改字符串长度N次需要的重分配次数 N次 最多N次 保存数据 只能保存文本数据 可以保存文本或者二进制数据 可以使用&lt;string.h&gt;库中的函数 所有 部分 常数复杂度获取字符串长度 因为C字符串并不记录自身的长度信息,所以为了获取一个C字符串的长度,程序必须遍历整个字符串 和C字符串不同,因为SDS在len属性中记录了SDS本身的长度,所以获取一个SDS长度的复杂度近位O(1) 使用SDS确保了获取字符串长度的工作不会成为Redis的性能瓶颈 杜绝缓冲区溢出 当SDS API需要对SDS进行修改时,API会先检查SDS的空间是否满足修改所需的要求,如果不满足的话,API会自动将SDS的空间扩展至执行修改所需的大小,然后才执行实际的修改操作,所以使用SDS既不需要手动修改SDS空间大小,也不会出现缓冲区溢出问题 减少修改字符串时带来的内存重分配次数 因为C字符串并不记录自身的长度,所以对于一个包含了N个字符串的C字符串来说,这个C字符串的底层实现总是一个N+1字符长的数组.因为字符串的长度和底层数组长度之间存在着这种关联性,所以每次增长或者缩短一个C字符串,程序都总要对保存这个C字符串的数组进行一次内存重分配操作: 如果程序执行的是增长字符串的操作,比如拼接操作(append),那么在执行这个操作之前,程序需要先通过内存重分配来扩展底层数组的空间大小,如果忘了这一步就会产生缓冲区溢出 如果程序执行的是缩短字符串的操作,比如截断操作(trim),那么在执行这个操作之后,程序需要通过对内存重分配来释放字符串不再使用的那部分空间,如果忘了这一步就会产生内存泄露 因为内存重分配设计复杂的算法,并且可能需要执行系统调用,所以它通常是一个比较耗时的操作,在一般程序中,如果修改字符串长度的情况不太常出现,那么每次修改都执行一次内存重分配是可以接受的;而对于Redis数据库,经常被用于速度要求严苛,数据频繁被修改的场合,如果每次修改字符串的长度都需要执行一次内存重分配的话,那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分,如果频繁发生更改的话,可能还会对性能造成影响 为了避免C字符串的这种缺陷,SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联:在SDS中,buf数组的长度不一定就是字符数量加一,数组里面可以包含未使用的字节,而这些字节的数量就由SDS的free属性记录 通过未使用空间,SDS实现了空间预分配和惰性空间释放两种优化策略 空间预分配 空间预分配用于优化SDS的字符串增长操作:当SDS的API对一个SDS进行修改,并且需要对SDS进行空间扩展的时候,程序不仅会为SDS分配修改所必须要的空间,还会为SDS分配额外的未实用空间. 其中,额外分配的未实用空间矢量由以下规则决定: 如果对SDS进行修改之后,SDS的长度将小于1MB,那么程序分配和len属性同样大小的未实用空间(这时SDS的len属性的值将和free属性的值相同) 如果对SDS进行修改之后,SDS的长度将大于1MB,那么程序会分配1MB的未实用空间 通过空间预分配策略,Redis可以减少连续执行字符串增长操作所需的内存重分配次数 在扩展SDS空间之前,SDSAPI会先检查未实用空间是否足够,如果足够的话,API就会直接使用未使用的空间,而无需执行内存重分配 惰性空间释放 惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时,程序并不立即使用内存重分配来回收缩短后多出来的字节,而是使用free属性将这些字节的数量记录起来,并等待将来使用 与此同时,SDS也提供了相应的API,让我们可以在有需要时,真正地释放SDS的未使用空间,所以不用担心惰性空间释放策略会造成内存浪费 二进制安全 C字符串中的字符必须符合某种编码(比如ASCII),并且除了字符串的末尾之外,字符串里面不能包含空字符,否则最先被程序读入的空字符创将被认为是字符串结尾,这些限制使得C字符串只能保存文本数据,而不能保存像图片,音频,视频,压缩文件这样的二进制数据 虽然数据库一般用于保存文本数据,但使用数据库来保存二进制数据的场景也不少见,因此,为了确保Redis可以适用于各种不同的使用场景,SDS的API都是二进制安全的(binary-safe),所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据,程序不会对其中的数据做任何限制,过滤,或者假设,数据在写入时是什么样的,它被读取时就是什么样的 这也是我们将SDS的buf属性成为字节数组的原因:Redis不是用这个数组来保存字符,而是用它保存一系列二进制数据. 兼容部分C字符串函数 虽然SDS的API都是二进制安全的,但他们一样遵循C字符串以空字符结尾的惯例,这是为了让那些保存文本数据的SDS可以重用一部分库定义的函数 SDS API 函数 作用 时间复杂度 sdnew 创建一个包含给定C字符串的SDS O(N) sdsempty 创建一个不包含任何内容的空SDS O(1) sdsfree 释放给定的SDS O(N) sdslen 返回SDS已使用空间字节数 O(1) sdsavail 返回SDS的未实用空间字节数 O(1) sdsdup 创建一个给定SDS的副本 O(N) sdsclear 清空SDS保存的字符串内容 惰性释放:O(1) sdscat 将给定C字符串拼接到SDS字符串的末尾 O(N) sdscatsds 将给定SDS字符串拼接到另一个SDS字符串的末尾 O(N) sdscpy 将给定的C字符串复制到SDS里面,覆盖SDS原有的字符串 O(N) sdsgrowzero 用空字符将SDS扩展至给定长度 O(N) sdsrange 保留SDS给定区间内的数据,不在区间内的数据会被覆盖或清除 O(N) sdstrim 接受一个SDS和一个C字符串作为参数,从SDS左右两端分别溢出所有在C字符串中出现过的字符 O(M*N) sdscmp 对比两个SDS字符串是否相同 O(N) 重点回顾 Redis只会使用C字符串作为字面量,在大多数情况下,Redis使用SDS作为字符串表示 SDS具有以下优点: 常数复杂度获取字符串长度 杜绝缓冲区溢出 减少修改字符串长度时所需的内存重分配次数 二进制安全 兼容部分C字符串函数]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条件队列]]></title>
    <url>%2Fjava-concurrent-condition%2F</url>
    <content type="text"><![CDATA[概述 条件队列就像烤面包机中通知&quot;面包已烤好&quot;的铃声.如果注意听着铃声,那么当面包烤好后可以立刻得到通知,开始吃面包.如果没有听见铃声,那么会错过消息通知,但回到厨房时还可以观察烤面包机的状态,如果已经烤好,就取出面包;没有烤好就再次留意铃声 &quot;条件队列&quot;这个名字来源于:它使得一组线程(称之为等待线程集合)能够通过某种方式来等待特定的条件为真.传统队列的元素是一个个数据,而与之不同的是,条件队列中的元素是一个个正在等待相关条件的线程. 正如每个java对象都可以作为一个锁,每个对象同样可以作为一个条件队列,并且Object中的wait,notify和notifyAll方法就构成了内部条件队列的API.对象的内置锁与其内部条件队列是相互关联的,要调用对象X中的条件队列的任何一个方法,必须持有对象X上的锁.这是因为&quot;等待由状态构成条件&quot;与&quot;维护状态一致性&quot;这两种机制必须被紧密地绑定在一起:只有能对状态进行检查时,才能在某个条件上等待,并且只有能修改状态时,才能从条件等待中释放另一个线程. Object.wait会自动释放锁,并请求操作系统挂起当前线程,从而使其他线程能够获得这个锁并修改对象的状态.当被挂起的线程醒来时,它将在返回之前重新获取锁.从直观上来理解,调用wait意味着&quot;我要去休息了,但当发生特定的事情时唤醒我&quot;,而调用通知方法就意味着&quot;特定事件发生了&quot; 一个条件队列 123456789101112131415161718192021222324public class BoundedBuffer&lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123; public BoundedBuffer(int capacity) &#123; super(capacity); &#125; public synchronized void put(V v) throws InterruptedException &#123; while(isFull())&#123; // 如果资源满了,则挂起线程,等待notifyAll() wait(); &#125; doPut(v); notifyAll(); &#125; public synchronized V take() throws InterruptedException &#123; while(isEmpty())&#123; // 如果资源空的,则挂起线程,等待notifyAll wait(); &#125; V v = doTake(); notifyAll(); return v; &#125;&#125; 显式的Condition对象 一个Condition和一个Lock关联在一起.Condition比内置条件队列提供了更丰富的功能: 在每个锁上柯村仔多个等待 条件等待可以是可中断的或不可中断的 基于时限的等待 公平或非公平的队列操作 Condition对象会继承Lock对象的公平性 每个Lock都可以有任意数量的Condition对象 Condition的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ConditionBoundedBuffer&lt;T&gt; &#123; protected final Lock lock = new ReentrantLock(); private final Condition notFull = lock.newCondition(); private final Condition notEmpty = lock.newCondition(); @GuardedBy("lock") private int tail, head, count; @GuardedBy("lock") private T[] items; public BoundedBuffer(int capacity) &#123; this.items = (T[]) new Object[capacity]; &#125; public void put(T t) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) &#123; notFull.await(); &#125; items[tail] = t; if (++tail == items.length) &#123; tail = 0; &#125; notEmpty.notify(); &#125; finally &#123; lock.unlock(); &#125; &#125; public T take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) &#123; notFull.await(); &#125; T x = items[head]; items[head] = null; if (++head == items.length) &#123; head = 0; &#125; --count; notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; ConditionBoundedBudder的行为与BoundedBuffer相同,但它对条件队列的使用方式更容易理解. 通过将两个条件谓词分开并放到两个等待线程集中,Condition使其更容易满足单次通知的需求 signal比signalAll更高效.]]></content>
      <categories>
        <category>Java并发实战</category>
      </categories>
      <tags>
        <tag>Java并发实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock源码阅读]]></title>
    <url>%2Flearn-jdk-reentrantLock%2F</url>
    <content type="text"><![CDATA[参考kangjianwei大佬的LearningJDK 概述 类图 获得锁操作委托给继承了AQS的内部类Sync FairSync和NonfairSync继承自Sync,分别实现公平和非公平的tryAcquire方法 调用解释 当调用reentrantLock().lock()时,调用sync.aquire(1),即aqs.aquire(1),然后aqs.tryAquire(),实际上是fairSync.tryAcquire()或nonfairSync.tryAcquire(),即sync.fairTryAquire()和sync.nonfairTryAquire(),尝试获取锁获取不到的话,则aqs.addWaiter(),在同步队列中排队,之后aqs.acquireQueued()从队列中申请,如果申请不到的话,则aqs.selfInterrupt(),阻塞线程. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@ReservedStackAccessfinal boolean nonfairTryAcquire(int acquires) &#123; // 获取申请锁的线程 final Thread current = Thread.currentThread(); // 当前许可证数量 int c = getState(); // 如果锁没有被任何线程占用 if(c == 0) &#123; // 发现锁空闲时，不管【同步队列】中有没有人抢锁，该线程直接尝试抢锁，这也是"非公平"所在 // 尝试更新许可证数量为acquires，返回true代表更新成功，即成功抢到了锁 if(compareAndSetState(0, acquires)) &#123; // 设置当前线程为&lt;占有者线程&gt; setExclusiveOwnerThread(current); return true; &#125; &#125; else &#123; /* 至此，说明锁已被占用 */ // 如果当前线程不是锁的占用者，直接返回false，代表抢锁失败，该线程需要去排队 if(current != getExclusiveOwnerThread()) &#123; return false; &#125; /* 至此，说明当前线程就是占用锁的线程，则需要再次持有锁，累计许可证数量，这也是"可重入"的含义 */ // 更新许可证数量 int nextc = c + acquires; if(nextc&lt;0) &#123; // 溢出 throw new Error("Maximum lock count exceeded"); &#125; setState(nextc); return true; &#125; return false;&#125;// 申请一次公平锁，返回值代表锁是否申请成功final boolean fairTryAcquire(int acquires) &#123; // 获取申请锁的线程 final Thread current = Thread.currentThread(); // 当前许可证数量 int c = getState(); // 如果锁没有被任何线程占用 if(c == 0) &#123; /* 发现锁空闲时，需要检查有没有其他线程在排队，如果没有其他人在队首，才尝试抢锁，这也是"公平"所在 */ // 判断【|同步队列|】的队头是否还有其他（非当前线程）的线程在排队 if(!hasQueuedPredecessors()) &#123; // 尝试更新许可证数量为acquires，返回true代表更新成功，即成功抢到了锁 if(compareAndSetState(0, acquires))&#123; // 设置当前线程为&lt;占有者线程&gt; setExclusiveOwnerThread(current); return true; &#125; &#125; &#125; else &#123; /* 至此，说明锁已被占用 */ // 如果当前线程不是锁的占用者，直接返回false，代表抢锁失败，该线程需要去排队 if(current != getExclusiveOwnerThread()) &#123; return false; &#125; /* 至此，说明当前线程就是占用锁的线程，则需要再次持有锁，累计许可证数量，这也是"可重入"的含义 */ // 更新许可证数量 int nextc = c + acquires; if(nextc&lt;0) &#123; // 溢出 throw new Error("Maximum lock count exceeded"); &#125; setState(nextc); return true; &#125; return false;&#125; nonfairTryAcquire和fairTryAcquire区别在于fairTryAcquire判断了是否有正在排队的其他线程]]></content>
      <categories>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS]]></title>
    <url>%2Fjava-concurrent-aqs%2F</url>
    <content type="text"><![CDATA[概述 在基于AQS构建的同步器类中,最基本的操作包括各种形式的获取操作和释放操作. 获取操作是一种依赖状态的操作,并且通常会阻塞.当使用锁或信号量时,&quot;获取&quot;操作的含义就很直观,即获取的是锁或者许可,并且调用者可能会一直等待直到同步器类处于可被获取的状态.在使用CountDownLatch时,“获取&quot;操作意味着&quot;等待并直到闭锁到达结束状态”,而在使用FutureTask时,“获取&quot;操作意味着&quot;等待并直到任务已经完成”.&quot;释放&quot;并不是一个可阻塞的操作,当执行&quot;释放&quot;操作时,所有在请求时被阻塞的线程都会开始执行. 如果一个类想成为状态依赖的类,那么它必须拥有一些状态.AQS负责管理同步器类中的状态,它管理了一个整数状态信息,可以通过getState,setState以及compareAndSetState等protected类型方法来进行操作.这个整数可以用于表示任意状态.例如,ReentrantLock用它来表示所有者线程已经重复获取该锁的次数,Semaphore用它来表示剩余的蓄客数量,FutureTask用它来表示人物的状态.在同步器类中还可以自行管理一些额外的状态变量,例如,ReentrantLock保存了锁当前所有者的信息,这样就能区分某个获取操作是重入的还是竞争的. 根据同步器不同,获取操作可以是一种独占操作(如ReentrantLock),也可以是一个非独占操作(例如Semaphore和CountDownLatch).一个获取操作包括两部分. 首先,同步器判断当前状态是否允许获得操作,如果是,则允许线程执行,否则获取操作将阻塞或失败.这种判断是由同步器的语义决定的.例如,对于锁来说,如果它没有被某个线程持有,那么它就能被成功地获取.而对于闭锁来说,如果它处于结束状态,那么也能被成功地获取. 1234567891011121314151617181920boolean acquire() throws InterruptedException &#123; while(当前状态不允许操作)&#123; if (需要阻塞获取请求) &#123; 如果当前线程不在队列中,则将其插入队列; 阻塞当前线程; &#125;else&#123; 返回失败 &#125; &#125; 可能更新同步器状态; 如果线程位于队列中,则将其移出队列; 返回成功;&#125;void release() &#123; 更新同步器状态; if (新的状态允许某个被阻塞的线程获取成功) &#123; 解除队列中一个或多个线程的阻塞状态; &#125;&#125; 其次,就是更新同步器的状态.获取同步器的某个线程可能会对其他线程能否也获取该同步器造成影响.例如,当获取一个锁后,锁的状态将从&quot;未被持有&quot;变成&quot;已被持有&quot;,而从Semaphore中获取一个许可后,将把剩余许可的数量减1.然而,当一个线程获取闭锁时,并不会影响其他线程能否获取它,因此获取封闭锁的操作不会改变闭锁的状态. 如果某个同步器支持独占的获取操作,那需要实现一些保护方法,包括tryAcquire,tryRelease和isHeldExclusively等, 而对于支持共享获取的同步器,则应该实现tryAcquireShared和tryReleaseShared等方法.AQS中的acquire,acquireShared,release和releaseShared等方法都将调用这些方法在子类中带有前缀try的版本来判断某个操作是否能执行.在同步器的子类中,可以根据其获取操作和释放操作的语义,使用getState,setState以及compareAndSetState来检查和更新状态,并通过返回的状态值来告知基类&quot;获取&quot;或&quot;释放&quot;同步器的操作是否成功. 例如,如果tryRequireShared返回一个负值,则表示获取操作失败;返回零值表示同步器通过独占方式获取,返回正值则表示同步器通过非独占方式被获取.对于tryRelease和tryReleaseShared方法来说,如果释放操作似的所有在获取同步器时被阻塞的线程恢复执行,那么这两个方法应该返回true. 为了使支持条件队列的锁(如ReentrantLock)实现起来更简单,AQS还提供了一些机制来构造与同步器相关联的条件变量 一个简单的闭锁 1234567891011121314151617181920212223242526272829public class OneShotLatch &#123; private class Sync extends AbstractQueuedSynchronizer &#123; @Override protected int tryAcquireShared(int ignored) &#123; // 如果闭锁是开的(state == 1),那么这个操作成功,否则失败. return (getState() == 1) ? 1 : -1; &#125; @Override protected boolean tryReleaseShared (int ignored)&#123; // 打开闭锁 setState(1); // 其他的线程可以获取该闭锁 return true; &#125; &#125; private final Sync sync = new Sync(); public void signal()&#123; sync.releaseShared(0); &#125; public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(0); &#125;&#125; OneShotLatch是一个使用AQS实现的二元闭锁,它包含两个公有方法:await和signal,分别对应获取操作和释放操作. 起初,闭锁是关闭的,任何调用await的线程都将阻塞并直到闭锁被打开.当通过调用signal打开闭锁时,所有等待中的线程都将被释放,并且随后到达闭锁的线程也被允许执行. 在OneShotLatch中,AQS状态用来表示闭锁状态:关闭(0)或者打开(1) await方法调用AQS的acquireSharedInterruptibly,然后接着调用OneShotLatch中的tryAcquireShared方法.在tryAcquireShared的实现中必须返回一个值来表示该获取操作是否能执行.如果之前已经打开了闭锁,那么tryAcquireShared将返回成功并允许线程通过,否则就会返回一个表示获取操作失败的值.acquireSharedInterruptibly方法在处理失败的方式,是把这个线程放入等待线程队列中,类似地,signal将调用releaseShared,接下来又会调用tryReleaseShared,在tryReleaseShared中将无条件地把闭锁的状态设置为打开,(通过返回值)表示该同步器处于完全释放的状态.因而AQS让所有等待中的线程都尝试重新请求该同步器,并且由于tryAcquireShared将返回成功,因此现在的请求操作将成功. OneShotLatch是一个功能全面的,可用的,性能较好的同步器.当然,它缺少了一些有用的特性,例如限时的请求操作以及检查闭锁的状态. OneShotLatch也可以通过继承AQS来实现,而不是将一些功能委托给AQS,但这种做法并不合理.这样做将破坏OneShotLatch接口(只有两个方法)的简洁性,并且虽然AQS的公共方法不允许调用者破坏闭锁的状态,但调用者仍可以很容易地误用它们.java.util.concurrent中的所有同步器都没有直接扩展AQS,而是将它们的相应功能委托给私有的AQS子类来实现. JUC同步器中的AQS JUC中的许多可阻塞类,如ReentrantLock,Semaphore,ReentrantReadWriteLock,CountDownLatch,SynchronousQueue和FutureTask等,都是基于AQS构建的. ReentrantLock ReentrantLock只支持独占方式的获取操作,因此它实现了tryAcquire,tryRelease和isHeldExclusively.ReentrantLock将同步状态用于保存锁获取操作的次数,并且还维护一个owner变量来保存当前所有者线程的标识符,只有在当前线程刚刚获取到锁,或者正要释放锁的时候,才会修改这个变量.在tryRelease中检查owner域,从而确保当前线程在执行unlock操作之前已经获得了锁:在tryAcquire中将使用这个域来区分获取操作是重入的还是竞争的. 1234567891011121314protected boolean tryAcquire(int ignored)&#123; final Thread current = Thread.currentThread(); int c = getState(); if(c == 0) &#123; if(compareAndSetState(0, 1)) &#123; owner = current; return true; &#125; &#125;else if(current == owner) &#123; setState(c + 1); return true; &#125; return false;&#125; 当一个线程尝试获取锁时,tryAcquire将首先检查锁的状态.如果锁未被持有,那么它将尝试更新锁的状态以表示锁已经被持有.由于状态可能在检查后被立即修改,因此tryAcquire使用conpareAndSetState来原子地更新状态,表示这个锁已经被占有,并确保状态在最后一次检查以后就没有被修改过.如果锁状态已经被持有,并且当且线程是锁的持有这,那么获取锁技术会递增.如果当前线程不是锁的拥有者,那么操作将失败. Semaphore与CountDownLatch Semaphore将AQS的同步状态用于保存当前可用许可的数量.tryAcquireShared方法首先计算剩余许可的数量,如果没有足够的许可,那么会返回一个值表示获取操作失败.如果还有剩余的许可,那么tryAcquireShared会通过compareAndSetState以原子方式来降低许可的计数.如果这个操作成功,那么将返回一个值表示获取操作成功.在返回值中还包含了表示其他共享获取操作能否成功的信息,如果成功,那其他等待的线程同样会接触阻塞. CountDownLatch使用AQS的方式与Semaphore很相似:在同步状态中保存的是当前的计数值.countDown方式调用release,从而导致计数值递减,并且当计数值为0时,接触所有等待线程的阻塞. FutureTask FutureTask看上去不像一个同步器,但Future.get的语义非常类似闭锁的语义:如果发生了某个时间(FutureTask表示的任务执行完成或被取消),那么线程就可以恢复执行,否则这些线程将停留在队列中并直到该事件发生. ReentrantReadWriteLock ReadWriteLock接口表示存在两个锁:一个读锁一个写锁 但在基于AQS实现的ReentrantLock中,单个AQS子类将同时管理读取加锁和写入加锁.ReentrantReadWriteLock使用了一个16位的状态来表示写入锁的计数,并且使用了另一个16位的状态来表示读取锁的计数.在读取锁上的操作将使用共享的获取方法与释放方法,在写锁上操作将使用独占的获取方法与释放方法. AQS在内部维护了一个等待线程队列,其中记录了某个线程请求的是独占访问还是共享访问.在ReentrantReadWriteLock中,当锁可用时,如果位于队列头部的线程执行写入操作,那么线程会得到这个锁,如果位于头部的线程执行读取访问,那么队列中在第一个写入线程之前的所有线程都将获得这个锁.]]></content>
      <categories>
        <category>Java并发实战</category>
      </categories>
      <tags>
        <tag>Java并发实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步工具类]]></title>
    <url>%2Fjava-concurrent-sync-tool-class%2F</url>
    <content type="text"><![CDATA[闭锁 闭锁(Latch)是一种同步工具类,可以延迟线程的进度知道到达中止状态. 闭锁的作用相当于一扇门: 在闭锁到达结束状态之前,这扇门是一直关闭的,并且没有任何线程能够通过. 在闭锁到达结束状态时,这扇门会打开并允许所有的线程通过. 当闭锁到达结束状态后,将不再改变状态,这扇门永远保持打开状态. 闭锁可以用来确保某些活动直到其他活动都完成后才继续执行,例如: 确保某个计算在其需要的所有资源都被初始化之后才继续执行.二元闭锁(包括两个状态)可以用来表示&quot;资源R已经被初始化&quot;,而所有需要R的操作都必须现在这个闭锁上等待. 确保某个服务在其依赖的所有其他服务都已经启动之后才启动.每个服务都有一个相关的二元闭锁.当启动服务S时,将首先在S依赖的其他服务上等待,在所有依赖的服务都启动后会释放闭锁S,这样其他依赖S的服务才能继续执行 等待知道某个操作的所有参与者都就绪再继续执行.这种情况下,当所有参与者都准备就绪时,闭锁将到达结束状态 CountDownLatch是一种灵活的闭锁实现,可以在上述各种情况中使用,它可以是一个或多个线程等待一组事件发生.闭锁状态包括一个计数器,该计数器被初始化为一个正数,表示需要等待的事件数量.countDown方法递减计数器,表示有一个时间已经发生了,而await方法等待计数器达到0,这表示所有需要等待的事件都已经发生.如果计数器的值非0,那么await会一直阻塞直到计数器为0,或者等待中的线程中断,或者等待超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.concurrent.CountDownLatch;class Tmp &#123; static long timeTasks(int nThreads, final Runnable task) throws InterruptedException &#123; final CountDownLatch startGate = new CountDownLatch(1); final CountDownLatch endGate = new CountDownLatch(nThreads); for (int i = 0; i &lt; nThreads; i++) &#123; new Thread() &#123; @Override public void run() &#123; try &#123; // 等待startGate信号 startGate.await(); try &#123; task.run(); &#125; finally &#123; // endState信号减一 endGate.countDown(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; long start = System.nanoTime(); // startGate信号减一,线程继续执行 startGate.countDown(); // 等待线程执行完 endGate.await(); long end = System.nanoTime(); return end - start; &#125; public static void main(String[] args) &#123; long l = 0; try &#123; l = timeTasks(100, () -&gt; &#123; System.out.print(123); &#125;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(); System.out.println(l); &#125;&#125; FutureTask FutureTask也可用作闭锁.FutureTask表示的计算是通过Callable来实现的,相当于一种可生成结果的Runnable,并且可以处于以下三种状态:等待运行(Waiting to run), 正在运行(running)和运行完成(conpleted). 执行完成表示计算的所有可能结束方式,包括正常完成,由于取消结束和由于异常结束等.当FurureTask进入完成状态后,它会永远停止在这个状态. Future.get的行为取决于任务的状态. 如果任务已经完成,那么get会立即返回结果,否则将get阻塞直到任务进入完成状态,然后返回结果或抛出异常.FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程,而FutureTask的规范确保了这种传递过程能实现结果的安全发布. 信号量 计数信号量(Counting Semaphore)用来控制同时访问某个特定资源的操作数量,或者同时执行某个指定操作的数量.计数信号还可以用来实现某种资源池,或者对容器市价边界. Semaphore中管理着一组虚拟的许可(permit),许可的初始数量可通过构造函数来指定,在执行操作时可以首先获取许可(只要还有剩余的许可),并在使用以后释放许可.如果没有许可,那么acquire将阻塞直到有许可(或者终端后者操作超时).release方法将返回一个许可信号量. 计算信号量的一种简化形式是二值信号量,即初始值为1的Semaphore,二值信号量可以用作互斥体(mutex),并具备不可重入的加锁语义:谁拥有这个唯一的许可,谁就拥有了互斥锁. Semaphore可以用于实现资源池,例如数据库连接池.我们可以构造一个固定长度的资源池,当池为空时,请求资源将会失败,但你真正希望看到的行为是阻塞而不是失败,并且当池非空时接触阻塞.如果将Semaphore的计数值初始化为池的大小,并在从翅中获取一个资源志气你首先调用acquire方法获取一个许可,在将资源返回给池之后调用release释放许可,那么acquire将一直阻塞直到资源池不为空. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.concurrent.Semaphore;public class BoundedHashSet&lt;T&gt; &#123; private Set&lt;T&gt; set; private Semaphore sem; public BoundedHashSet(int bound) &#123; this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;()); sem = new Semaphore(bound); &#125; public boolean add(T o) throws InterruptedException &#123; // 获得一个许可 sem.acquire(); boolean wasAdded = false; try &#123; wasAdded = set.add(o); return wasAdded; &#125; finally &#123; if (!wasAdded) &#123; // 如果没添加成功,则当场释放一个许可 sem.release(); &#125; &#125; &#125; public boolean remove(T o) &#123; boolean wasRemoved = set.remove(o); if (wasRemoved) &#123; // 如果删除成功,则释放一个许可 sem.release(); &#125; return wasRemoved; &#125; public static void main(String[] args) &#123; var a = new BoundedHashSet&lt;Integer&gt;(4); try &#123; a.add(1); a.add(2); a.add(3); a.add(4); // add(5)这一步会阻塞 a.add(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 栅栏 我们已经看到通过闭锁来启动一组相关的操作,或者等待一组相关的操作结束.闭锁是一次性对象,一旦进入中止状态,就不能被重置. 栅栏(Barrier)类似于闭锁,他能阻塞一组线程直到某个事件发生. 栅栏与闭锁的关键区别在于,所有线程必须同时到达栅栏位置,才能继续执行.闭锁用于等待事件,栅栏用于等待其他线程. 栅栏用于实现一些协议,例如几个家庭决定在某个地方集合:所有人在6:00在麦当劳碰头,到了以后要等其他人,之后再讨论下一步要做的事情 CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集,它在并行迭代算法中非常有用: 这种算法通常将一个问题拆分成一系列相互独立的子问题.当线程达到栅栏位置时将调用await方法,这个方法将阻塞直到所有线程都到达栅栏位置.如果所有线程都到达了栅栏位置,那么栅栏将打开,此时所有线程都被释放,而栅栏将被重置以便下次使用.如果对await调用超时,或者await阻塞的线程被中断,那么栅栏就被认为是打破了,所有阻塞的await调用都将终止并抛出BrokenBarrierException.如果成功地通过栅栏,那么await将为每个线程返回一个唯一的到达索引号,我们可以利用这些索引来&quot;选举&quot;产生一个领导线程,并在下一次迭代中由该领导线程执行一些特殊的工作.CyclicBarrier还可以使你将一个栅栏操作传递给构造函数,这是一个Runnable,当成功通过栅栏时会执行它,但在阻塞线程被释放之前是不能执行的. 在模拟程序中通常需要使用栅栏,例如某个步骤中的计算可以并行执行,但必须等到该不走中的所有计算都执行完毕才能进入下一个步骤.]]></content>
      <categories>
        <category>Java并发实战</category>
      </categories>
      <tags>
        <tag>Java并发实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节食日记]]></title>
    <url>%2Fgo-on-a-diet%2F</url>
    <content type="text"><![CDATA[记个这个玩意督促我减肥 general 我想吃东西了怎么办啊啊啊啊啊啊啊啊啊 点开淘宝,看买家秀 摸摸肚子 喝水 吃木糖醇(不能多吃) 去洗洗衣服啥的,找点其他事情做 吃 饿了或者馋了都要忍,但是饿到四肢无力的时候必须吃点 记录 2019年9月9日 中午吃的,一份大荤,一份藕,一份海带 2019年9月8日 没吃 2019年9月7日 中午点了份炸鸡 2019年9月6日 上午10点去领快递,在一食堂吃了一份大荤两个鸡锁骨和一根炸香肠 下午6点去领快递在正新鸡排点了一份鸡米花两根炸香肠 2019年9月5日 晚饭吃的,一份小荤一份小青菜 2019年9月4日 下午吃的,点了20块的冒菜 2019年9月3日 午餐吃了两道菜,鸭肉和炸鸡 2019年9月2日 下午吃的冒菜,不小心点多了,点了30块的… 2019年9月1日 拿快递时在一食堂吃的,点了两块鸡锁骨,一根香肠,一份土豆鸡]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringIoC]]></title>
    <url>%2Fspring-ioc%2F</url>
    <content type="text"><![CDATA[概述 Spring中,IoC容器是实现IoC的载体,它可以在对象生成或初始化时直接将数据注入到对象中,也可以通过将对象引用注入到对象数据域中的方式来注入对方法调用的依赖. 这种依赖注入是递归的,对象被组成注入 依赖注入流程 阶段一: 收集和注册 第一个阶段可以认为是构建和收集bean定义的阶段,在这个阶段中,我们可以通过XML或者Java代码的方式定义一些bean,然后通过手动组装或者让容器基于某些机制自动扫描的形式,将这些bean定义收集到IoC容器中 阶段二: 分析和组装 第一阶段完成后,可以暂且认为IoC容器中充斥着一个个独立的bean,这是它们之间还没有任何关系.但实际上,它们之间是有依赖关系的,所以,IoC容器在第二阶段要干的事情就是分析这些已经在IoC容器中的bean,然后根据它们之间的依赖关系先后组装它们 IoC容器 在Spring IoC容器的设计中,我们可以看到两个主要的容器系列,一个是实现BeanFactory接口的简单容器系列,这系列容器只实现了容器最基本的功能;另一个是ApplicationContext应用上下文,它作为容器的高级形态而存在.应用上下文在简单容器的基础上增加了许多面向框架的特性,同时对应用环境做出了许多适配 BeanFactory BeanFactory的应用场景 BeanFactory接口设计了getBean方法,这个方法是使用IoC容器API的主要方法,通过这个方法,可以取得IoC容器中管理的Bean,Bean的取得是通过指定名字来索引的.如果需要在获取Bean时对Bean的类型进行检查,BeanFactory接口定义了带有参数的getBean方法,这个方法的使用与不带参数的getBean方法类似,不同的是增加了对Bean检索的类型的要求. 用户可以通过BeanFactory接口方法中的getBeean使用Bean的名字,从而在获取Bean时,如果需要获取的Bean是prototype类型的,用户还可以为这个prototype类型的Bean生成指定构造函数的对应参数.这使得在一定程度上可以控制生成prototype类型的Bean 有了BeanFactory的定义,用户可以执行以下操作: 通过接口方法containsBean让用户能够判断容器是否含有指定名字的Bean 通过接口方法isSingleton来查询指定名字的Bean是否是Singleton类型的Bean.对于Singleton属性,用户可以在BeaDefinition中指定 通过接口方法isPrototype来查询指定名字的Bean是否是prototype类型的.对于prototype属性,用户可以在BeanDefinition中指定 通过接口方法isTypeMatch来查询指定了名字的Bean的Class类型是否是特定的Class类型.这个Class类型可以由用户来指定 通过接口方法getType来查询指定名字的Bean的Class类型 通过接口方法getAliases来查询指定了名字的Bean的所有别名,这些别名都是用户在BeaDefinition中定义的 BeanFactory容器的设计原理 BeanFactory接口提供了使用IoC容器的规范.在这个基础上,Spring还提供了符合这个IoC容器接口的一系列容器的实现供开发人员使用.比如,XmlBeanFactory设计的类继承关系: 它只提供最基本的IoC容器的功能.]]></content>
  </entry>
  <entry>
    <title><![CDATA[面向面试笔记]]></title>
    <url>%2Forient-interview%2F</url>
    <content type="text"><![CDATA[Java 泛型的实现方式 类型擦除 多态的原理 动态绑定 反射的实现和原理 读写锁的实现 Java并发 饿汉懒汉 是指单例模式的懒汉饿汉 cyclicbarrier 和countdownlatch 消费者生产者模型 线程回调 线程的几种状态 sleep和yield MVCC 网络与IO 每层的协议都有什么 窗口机制 websocket http1.1 2.0 https加密方式 DMS寻址过程 粘包和拆包 epoll、poll、select Linux sed和awk 查看进程和杀死进程 组原 float存储 线程的通信方式 进程的通信方式 系统线程数量上限 页式存储 内存碎片 数据库 Innodb和MyIsam的区别 聚簇索引和非聚簇索引 聚簇索引: 叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引 非聚簇索引: 叶结点包含索引字段值及指向数据页数据行的逻辑指针 联合索引 https://cloud.tencent.com/developer/article/1030117 mysql事务是如何实现的 Spring bean依赖冲突 BeanFactory 自动装配的方式 dispatch-servlet spring事务 中间件 redis SDS 算法 大数运算 一致性hash]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[to-learn]]></title>
    <url>%2Fto-learn%2F</url>
    <content type="text"><![CDATA[[ ] jvm参数 [ ] spring [ ]]]></content>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock]]></title>
    <url>%2Fjava-concurrent-reentrantlock%2F</url>
    <content type="text"><![CDATA[Lock接口 12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; ReentrantLock实现了Lock接口,并提供了与synchronized相同的互斥性和内存可见性.在获取ReentrantLock时,有着与进入同步代码相同的内存语义,在释放ReentrantLock时,同样有着与退出代码相同的内存语义.ReentrantLock还提供了可重入的加锁语义. 大多情况下,内置锁都能很好地工作,但在功能上存在一些局限性,例如,无法中断一个正在等待获取锁的线程,或者无法在请求获取一个锁时无限地等待下去.内置锁必须在获取该锁的代码块中释放,这就简化了编码工作,并且与异常处理操作实现了油耗的交互,但却无法试下非阻塞结构的加锁规则. Lock接口库的标准使用形式: 12345678910Lock lock = new ReentrantLock();...lock.lock();try &#123; // 更新对象状态 // 捕获异常&#125; finally &#123; // 必须在finally中释放锁 lock.unlock();&#125; ReentrantLock锁特性 轮询锁与定时锁 可定时的与可轮询的锁模式都是由tryLock方法实现的,与无条件的锁获取模式相比,它具有更完善的错误恢复机制.在内置锁中,死锁是一个严重的问题,恢复程序的唯一方法是重启应用程序,而防止死锁的唯一方法是在构造程序时避免出现不一致的锁顺序.可定时的与可轮询的锁提供了避免死锁发生的方案. 如果不能获取所有需要的锁,那么可以使用可定时的或可轮询的锁获取方式,从而使程序重新获得控制权.它会释放已经获得的锁,然后重新尝试获取所有锁. 在实现就有时间限制的操作时,定时锁同样非常有用.当在带有时间限制的操作中调用了一个阻塞方法时,它能根据剩余时间来提供一个时限.如果操作不能在指定的时间内给出结果,那么就会使程序提前结束.当使用内置锁时,在开始请求锁后,这个操作将无法取消,因此内置锁很难实现带有时间限制的操作. 12345678910public boolean trySendOnSharedLine(String message, long timeout, TimeUnit unit) throws InterruptException &#123; if (!lock.tryLock(nanosToLock, NANOSECONDS)) &#123; return false; &#125; try &#123; return sendOnSharedLine(message); &#125;finally &#123; lock.unlock(); &#125;&#125; 可中断的锁获取操作 正如定时的锁获取操作能在带有时间限制的操作中使用独占锁,可中断的锁获取操作同样能在可取消的操作中加锁. 123456789101112public boolean sendOnShareLine(String message) throws Interruption &#123; lock.lockInterruptibly(); try &#123; return cancellableSendOnSharedLine(message); &#125; finally &#123; lock.unlock(); &#125;&#125;private boolean cancellableSendSharedLine(String message) throws InterruptedException &#123; ...&#125; 非块结构的加锁 在内置锁中,锁的获取和释放等操作都是基于代码块的,释放锁的操作总是与获取锁的操作处于同一个代码块,而不考虑控制权如何退出该代码块.内置锁的自动释放操作简化了对程序的分析,避免了可能的编码错误,但有时候需要更灵活的加锁方式. 公平性 在ReentrantLock的构造函数中提供了公平性选择. 公屏是一种好的行为,而不公平则是一种不好的行为,但是当执行加锁操作时,公平性将由于在挂起线程和恢复线程时存在的开销极大的降低性能.在实际情况中,统计学上的公平性保证:确保被阻塞的线程能最终获得锁,通常已经够用了,并且实际开销也很小. 性能考虑因素 ReentrantLock在Java5.0比内置锁提供更好的竞争性能. 在Java6中,内置锁与ReentrantLock之间的性能差异减小. 在synchronized和ReentrantLock之间进行选择 ReentrantLock在加锁he内存上提供的语义与内置锁相同,此外它还提供了一些其他功能.ReentrantLock在性能上似乎优于内置锁. 与ReentrantLock相比,内置锁仍然具有很大的优势:内置锁为很多开发人员所熟悉,并且简洁紧凑 ReentrantLock的危险性比synchronized要高,如果忘记在finally中调用relock,那… 仅当内置锁不能满足需求时,才考虑ReentrantLock. 未来更可能提升synchronized而不是ReentrantLock的性能.因为synchronized是JVM的内置属性,它能执行一些优化,例如对线程封闭锁对象的锁消除优化,通过加锁的粒度来消除内置锁的同步,而如果通过基于类库的锁来实现这些功能,则可能性不大. 就性能方面来说,应该选择synchronized而不是ReentrantLock.]]></content>
      <categories>
        <category>Java并发实战</category>
      </categories>
      <tags>
        <tag>Java并发实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程-基础构建模块]]></title>
    <url>%2Fjava-concurrent-1%2F</url>
    <content type="text"><![CDATA[同步容器类 如Vector和HashTable.其实现方式是:将它们的状态封存起来,并对每个公有方法都进行同步,使得每次只能有一个线程能访问容器的状态 同步容器类的问题 容器上常见的符合操作: 迭代 , 跳转 和 条件运算.在同步容器中,这些复合操作在没有客户端加锁的情况下仍然是线程安全的,但当其他的线程并发地修改容器时,它们可能会表现出意料之外的行为]]></content>
      <categories>
        <category>Java并发实战</category>
      </categories>
      <tags>
        <tag>Java并发实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020校招]]></title>
    <url>%2Fseek-job-2020%2F</url>
    <content type="text"><![CDATA[公司 职位 简历投递时间 笔试时间 简历评估 面试时间 offer时间 我的 流程 阿里巴巴 研发工程师JAVA 8.1-10月中旬 链接 链接 百度 上海-Java研发工程师 7.5-9.21 9.24 10.8-10.13（暂定） 9月中旬-11月上旬 链接 腾讯 软件开发-后台开发方向 8.1-9.12 9.18-9.20 9.15-10.23 链接 字节跳动 后端开发工程师 7.19-10.31 7月下旬-11月上旬 链接 美团点评 后台开发工程师 -09.17 9.18 9.16-9.20 链接 网易 Java开发工程师-杭州 8.1~9.3 9.7 or 9.21 9月中旬~10月 面试后10个工作日内 链接 小米 软件开发工程师-Java方向-上海 尽快 携程 后台开发工程师-上海 -9.2 9.4 9月-10月 10月-11月 爱奇艺 Java开发工程师-上海 8.15起 9.8 or 9.18 8.26- 9月起 链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-10-Dubbo过滤器]]></title>
    <url>%2Fdubbo-10%2F</url>
    <content type="text"><![CDATA[概述 过滤器提供了服务提供者和消费者调用过程的拦截,即每次执行RPC调用的时候,对应的过滤器都会生效 过滤器的使用 Dubbo中已经有很多内置的过滤器,并且大多数都是默认启动的,如ContextFilter,对于自行扩展的过滤器,一种方式是使用@Active注解默认启动,另一种方式是在配置文件中配置 1234567891011&lt;!-- 消费方调用过程拦截 --&gt;&lt;dubbo:reference filter="xxx,yyy" /&gt;&lt;!-- 消费方调用过程默认拦截器,将拦截所有reference --&gt;&lt;dubbo:consumer filter="xxx,yyy" /&gt;&lt;!-- 服务提供方调用过程拦截 --&gt;&lt;dubbo:service filter="xxx,yyy" /&gt;&lt;!-- 服务提供方调用过程默认拦截器,将拦截所有service --&gt;&lt;dubbo:provider filter="xxx,yyy" /&gt; 以上就是配置方式,下面是一些规则: 过滤器顺序 用户自定义的过滤器的顺序默认会在框架内置过滤器之后,我们可以使用filter=&quot;xxx,default&quot;这种配置方式让自定义的过滤器顺序靠前 我们在配置filter=&quot;xxx,yyy&quot;时,写在前面的xxx会比后面的yyy顺序靠前 剔除过滤器 对于一些默认的过滤器或自动激活的过滤器,有些方法不想使用这些过滤器,则可以使用&quot;-“加过滤器名称来剔除,如filter=”-xxFilter&quot;会让xxFilter不生效.如果不想使用所有默认启用的过滤器,则可以配置filter=&quot;-default&quot;来进行剔除 过滤器的叠加 如果服务提供者,消费者端都配置了过滤器,则两边的过滤器不会互相覆盖,而是相互叠加,都会生效,如果需要覆盖,则可在消费方使用&quot;-&quot;的方式剔除对应的过滤器 过滤器的总体结构 只有CompatibleFilter只继承Filter接口,不会默认被激活.其他的内置过滤器都使用了Activate注解,默认激活;Filter接口上有@SPI注解,用户可以基于这个扩展点接口实现字的过滤器.所有过滤器会被分为消费者和服务提供者两种.消费者类型的过滤器只会在服务引用时被加入Invoker,服务提供者类型的过滤器只会在暴露的时候加入对应的Invoker. 自带过滤器]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-9-Dubbo高级特性]]></title>
    <url>%2Fdubbo-9%2F</url>
    <content type="text"><![CDATA[Dubbo高级特性概述 Dubbo解决了分布式场景RPC通信调用的问题,但是要满足各种业务场景还是不够的.场景: 支付业务需要自身迭代版本,比如1.0和2.0版本,在2.0版本做了大量性能改进,需要发布到性能测试环境与1.0版本做对比,这个时候需要框架提供服务隔离的能力. 客户端消费远程服务时不希望阻塞,这个时候业务方可以在线程池中发起RPC调用,但这样不够优雅,需要框架支持异步调用和回调 Dubbo提供了大量的高级特性. 服务分组和版本 Dubbo中提供的服务分组和版本是强隔离的,如果制定了服务分组和版本,则消费方调用也必须传递相同的分组名称和版本名称 参数回调 Dubbo支持异步参数回调,当消费方调用服务端方法时,允许服务端在某个时间点回调回客户端的方法.在服务端回调客户端时,服务端不会重新开启TCP连接,会复用已经建立的从客户端到服务端的TCP连接.下面是一个参数回调的例子: 异步回调服务端实现 123456789101112131415161718192021222324252627282930313233343536373839404142// 服务提供方暴露的接口public interface CallbackService &#123; void addListener(String key, CallbackListener listener);&#125;// 消费方被回调的方法public interface CallbackListener &#123; void changed(String msg);&#125;// 服务提供方接口实现public class CallbackServiceImpl implements CallbackService &#123; private Map&lt;String, CallbackListener&gt; listeners = new ConcurrentHashMap&lt;String, CallbackListener&gt;(); public void addListener(String key, CallbackListener listener) &#123; listeners.put(key, listener); &#125; public CallbackServiceImpl() &#123; Thread t = new Thread(new Runnable() &#123; public void run() &#123; while(true) &#123; try &#123; for(Map.Entry&lt;String, CallbackListener&gt; entry : listeners.entrySet())&#123; try&#123; entry.getValue().changed(getChanged(entry.getKey())); &#125; catch (Throwable t) &#123; listeners.remove(entry,.getKey); &#125; &#125; Thread.sleep(5000); &#125; catch(Throwable ignored) &#123;&#125; &#125; &#125; &#125;) t.start() &#125; private String getChanged(String key) &#123; return "Changed: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()); &#125;&#125; 消费异步回调服务 123456789ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("classpath:consumer.xml");context.start();CallbackService callbackService = (CallbackService)context.getBean("callbackService");callbackService.addListener("foo.bar", new CallbackListener()&#123; public void changed(String msg) &#123; System.out.println("callback1:" + msg); &#125;&#125;) 隐式参数 Dubbo服务提供者或消费者启动时,配置元数据会生成URL,一般是不可变的.在很多场景中,在服务运行期需要动态改变属性值,在做动态路由和灰度发布场景中需要这个特性.Dubbo框架支持消费方在RpcContext#setAttachment方法中设置隐式参数,在服务端RpcContext#getAttachment方法中获取隐式传递 TODO:具体实现 异步调用 在客户端实现异步调用非常简单,在消费接口时配置异步标识,在调用时从上下文中获取Future对象,在期望结果返回时再调用阻塞方法Future.get()即可. 客户端异步调用: 123456fooService.findFoo(fooId);// 在发起其他RPC调用时,现获取Future引用,当结果返回后,会被通知和设置到此FutureFuture&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture();Foo foo = fooFuture.get(); Dubbo异步调用流程: 站在Dubbo客户端角度来说,直接发起RPC调用属于用户线程.用户线程①发起任意的远程方法调用,最终会通过I/O线程发送网络报文,在真实发送报文前会让用户线程中设置当前异步请求Future(③).因此在此用户线程发起下一个远程方法调用前,需要先保存异步Future对象(④).Dubbo框架会把异步请求放到DefaultFuture类中,当服务端响应或超时时,被挂起的用户线程将被唤醒(⑤).用户线程设置异步Future对象的逻辑在DubboInvoker#doInvoke方法中完成.(详细参阅DubboInvoker) 泛化调用 Dubbo繁华调用特性可以在不依赖服务接口API包的场景中发起远程调用.这种特性特别适合框架集成和网关类应用开发.Dubbo在客户端发起泛化调用并不要求服务端是泛化暴露. 泛化调用实例: 1234567891011121314151617181920ReferenceConfig&lt;GenericService&gt; ref = new ReferenceConfig&lt;&gt;();ApplicationConfig appConfig = new ApplicationConfig("demo-consumer");RegistryConfig registryConfig = new RegistryConfig();registryConfig.setProtocol("zookeeper");registryConfig.setAddress("localhost:2181");ref.setProtocol("dubbo");ref.setApplication(appConfig);ref.setRegistry(registryConfig);ref.setInterface("com.xxx.XxxService");// 标识泛化调用ref.setGeneric(true);// 创建远程代理GenericService genericService = ref.get();// 发起远程调用Object result = genericService.$invoe("sayHello", new String[]&#123;"java.lang.String"&#125;, new Object[] &#123;"word"&#125;); 泛化调用必需的参数主要包括:应用名称,注册中心,直接接口名称和泛化标识.在发起远程调用时,GenericService方法参数类型分别为真实方法名,真实方法参数类型签名和真实参数值. 这里需要注意的是,每次动态创建的GenericService实例比较重,需要建立TCP连接,处理注册中心订阅和服务列表等计算,因此需要缓存ReferenceConfig进行复用. 服务端在处理服务调用时,在GenericFilter拦截器中先把RpcInvocation中传递过来的参数类型和参数值提取出来,然后根据传递过来的接口名,方法名和参数类型查找服务端被调用的方法,获取真实方法后,主要提取真实方法参数类型(可能包含泛化类型),然后将参数值做Java类型转换.最后用解析后的参数值构造新的RpcInvocation对象发起调用 上下文信息 Dubbo上下文的获取和存储同样是基于JDKThreadLocal实现的.上下文中存放的是当前调用过程中所需的环境信息.RpcContext是一个ThreadLocal的临时状态记录器,当收到或发送RPC时,当前线程关联的RpcContext状态都会变化.比如:A调用B,B再调用C,则在B机器上,在B调用C之前,RpcContext记录的是A调用B的信息,在B调用C之后,RpcContext记录的是B调用C的信息. 服务端上下文的获取和使用: 123456789public class DemoServiceImpl implements DemoService &#123; public void hello() &#123; boolean isProviderSide = RpcContext.getContext)().isProviderSide(); String clientIP = RpcContext.getContext().getRemoteHost(); String application = RpcContext.getContext().getUrl().getPatameter("application"); yyyService.done(); boolean isProviderSide = RpcContext.getContext.isProviderSide(); &#125;&#125; 在客户端和服务端分别有一个拦截设置当前上下文信息,分别对应ConsumerContextFilter和ContextFilter.在客户端拦截器实现中,因为Invoker包含远程服务信息,因此直接设置远程IP等信息.在服务端拦截器中主要设置本地地址,这个时候无法获取远程调用地址.设置远程地址主要在DubboProtocol#ExchangeHandlerAdapter.reply方法中完成,可以直接通过channel.getRemoteAddress方法获取 Telnet操作 TODO Mock调用 Dubbo提供服务容错的能力,通常用于服务降级,比如验权服务,当服务提供方&quot;挂掉&quot;后,客户端不抛出异常,而是通过Mock数据返回授权失败. TODO 结果缓存 Dubbo框架提供了对服务调用结果尽心缓存的特性,用于加速热门数据的访问速度,Dubbo提供声明式缓存,以减少用户加载缓存的工作量.因为每次调用都会使用JSON.toString方法将请求参数转换成字符串,然后拼装唯一的key,用于缓存唯一键. lru缓存策略是框架默认使用的.]]></content>
      <categories>
        <category>dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-8-Dubbo扩展点]]></title>
    <url>%2Fdubbo-8%2F</url>
    <content type="text"><![CDATA[概述 背景 扩展机制和扩展点作为Dubbo设计的核心机制,不仅是Dubbo能够适应不同公司的技术需要,流行至今的重要引出,也是Dubbo本身生态不断完善,功能越来越强大的核心原因之一 扩展点整体架构 按使用者和开发者来分,Dubbo可以分为API层和SPI层.API层让用户只关注业务的配置,直接使用框架API即可;SPI层可以让用户自定义不同的实现类来扩展整个框架的功能 按逻辑来区分,可以把Dubbo从上到下分为三层:业务层,RPC层,Remote层 RPC层扩展点 RPC层分为四层:Config,Proxy,Registry,Cluster Proxy层扩展点 Proxy层主要的扩展接口是ProxyFactory.ProxyFactory帮我们生成了代理类,当我们请求某个远程接口时,实际上使用的是代理类 Dubbo中的ProxyFactory有两种默认实现,Javassist和JDK,用户可以自行扩展自己的实现,如CGLib.基于性能和使用的建议性考虑,Dubbo选用Javassist作为默认的字节码生成工具 1234567891011@SPI("javassist")public interface ProxyFactory &#123; @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException; @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, boolean generic) throws RpcException; @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;&#125; Registry层扩展 这一层最重要的扩展是org.apache.dubbo.registry.RegistryFactory.整个框架的注册与服务发现客户端都是这个扩展点负责创建的.该扩展点有@Adaptive({“protocol”})注解,可以根据URL中的protocol参数创建不同的注册中心客户端.如果我们扩展了自定义的注册中心,那么只需要配置不同的protocol即可. 1234567891011121314151617181920@SPI("dubbo")public interface RegistryFactory &#123; /** * Connect to the registry * &lt;p&gt; * Connecting the registry needs to support the contract: &lt;br&gt; * 1. When the check=false is set, the connection is not checked, otherwise the exception is thrown when disconnection &lt;br&gt; * 2. Support username:password authority authentication on URL.&lt;br&gt; * 3. Support the backup=10.20.153.10 candidate registry cluster address.&lt;br&gt; * 4. Support file=registry.cache local disk file cache.&lt;br&gt; * 5. Support the timeout=1000 request timeout setting.&lt;br&gt; * 6. Support session=60000 session timeout or expiration settings.&lt;br&gt; * * @param url Registry address, is not allowed to be empty * @return Registry reference, never return empty value */ @Adaptive(&#123;"protocol"&#125;) Registry getRegistry(URL url);&#125; 使用这个扩展点,还有一些需要遵循的规则: 如果URL中设置了check=false,则连接不会被检查.否则,需要在断开连接时抛出异常 需要支持通过username:password格式在URL中传递鉴权 需要支持设置back参数来执行备选注册集群的地址 需要支持file参数来指定本地文件缓存 需要设置timeout参数来指定请求的超时时间 需要支持设置session参数来指定连接的超时或过期时间 Cluster层扩展点 Cluster层负责了整个Dubbo框架的集群容错,设计的扩展点较多,包括容错(Cluster),路由(Router),负载均衡(LoadBalance),配置管理工厂(ConfiguratorFactory)和合并器(Merger) Cluster扩展点 Cluster主要负责一些容错策略,也是整个集群容错的入口.当远程调用失败后,由Cluster负责重试,快速失败等,整个过程对上层透明 Cluster扩展点默认使用Failover机制 12345@SPI(FailoverCluster.NAME)public interface Cluster &#123; @Adaptive &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException;&#125; Cluster接口只有一个join方法,并且有@Adaptive注解,会根据配置动态调用不同的容错机制 RouteFactory扩展点 RouterFactoryFactory是一个工厂类,用于创建不同的Router.假设接口A有多个服务提供者提供服务,如果配置了路由规则(某个消费者只调用某几个提供者),则Router会过滤掉其他服务提供者,只留下符合路由规则的提供者列表 12345@SPIpublic interface RouterFactory &#123; @Adaptive("protocol") Router getRouter(URL url);&#125; 现有的路由规则支持文件,脚本和自定义表达式等方式.接口上有@Adaptive(“protocol”)注解,会根据不同的protocol自动匹配路由规则 扩展key名 扩展类名 file org.apache.dubbo.rpc.cluster.router.file.FileRouterFactory script org.apache.dubbo.rpc.cluster.router.script.ScriptRouterFactory condition org.apache.dubbo.rpc.cluster.router.condition.ConditionRouterFactory server org.apache.dubbo.rpc.cluster.router.condition.config.ServiceRouterFactory app org.apache.dubbo.rpc.cluster.router.condition.config.AppRouterFactory tag org.apache.dubbo.rpc.cluster.router.tag.TagRouterFactory mock org.apache.dubbo.rpc.cluster.router.mock.MockRouterFactory LoadBalance扩展点 Dubbo的LoadBalance默认使用随机算法 12345@SPI(RandomLoadBalance.NAME)public interface LoadBalance &#123; @Adaptive("loadbalance") &lt;T&gt; Invoke&lt;T&gt; select(List&lt;Invoke&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;&#125; ConfiguratorFactory 创建配置实例的工厂类,现有override和absent两种工厂实现,分别会创建OverrideConfigurator和AbsentConfigurator两种配置对象 OverrideConfigurator会直接把配置中心中的参数覆盖本地参数 AbsentConfigurator会先看本地存在该 配置,有则不会覆盖 12345@SPIpublic interface ConfiguratorFactory &#123; @Adaptive("protocol") Configurator getConfigurator(URL url);&#125; Merge扩展点 合并器,可以对并行调用的结果进行合并.例如:并行调用A,B两个服务器都会返回一个List结果集,Merge可以把两个List合并成一个返回给应用.用户可以基于该扩展点,添加自定义类型的合并器 1234@SPIpublic interface Merge&lt;T&gt; &#123; T merge(T... items);&#125; 默认已支持:map, set, list, byte, char, short, int, long, float, double, boolean Remote层扩展点 Remote处于整个Dubbo框架的底层,设计协议,数据的交换,网络的传输,序列化,线程池等,覆盖了一个远程调用的所有要用 Remote层是对Dubbo传输协议的封装,内部再划分为Transport传输层和Exchange信息交换层.其中Transport层只负责单项消息传输,是对Mina,Netty等传输工具库的抽象.而Exchange层在传输层智商实现了Request-Response语义,这样我们可以在不同传输方式智商都能做到统一的请求/响应处理.Serialize层是RPC的一部分,决定了在消费者和服务提供者之间的二进制数据传输格式 Protocol层扩展点 Protocol扩展点 Protocol是Dubbo RPC的核心调用层,具体的RPC协议都可以由Protocol点扩展.如果想新添加一种RPC协议,只需要扩展一个新的Protocol扩展点实现即可.Protocol扩展点接口代码: 12345678910111213@SPI("dubbo")public interface Protocol &#123; int getDefaultPort(); @Adaptive &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException; @Adaptive // 引用一个服务 &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException; void destroy();&#125; Protocol的每个接口会有一些规则,在实现自定义协议的时候需要注意 export方法 协议收到请求后应记录请求源IP地址.通过RpcContext.getContext().setRemoteAddress()方法存入RPC上下文 expoet方法必须实现幂等,即无论调用多少次,返回的URL都是相同的 Invoker实例由框架传入,无须关心协议层 refer方法 当我们调用refer()方法返回Invoker对象的invoker()方法时,协议需要相应地执行invoker方法.这一点在设计自定义协议的Invoker时需要注意 正常来说refer()方法返回的自定义Invoker需要继承Invoker接口 当URL参数有check=false时,自定义的协议实现必须不能抛出异常,而是在出现连接失败异常时尝试恢复连接 destroy方法 调用destroy方法的时候,需要销毁所有本协议暴露和引用的方法 需要释放所有占用的资源,如连接,端口等 自定义的协议可以在被销毁后继续导出和引用新服务 整个Protocol的逻辑由Protocol,Exporter,Invoker三个接口串起来 Protocol接口是入口,其实现封装了用来处理Exporter和Invoker的方法: Exporter代表要暴露的远程服务引用,Protocol#export方法是将服务暴露的处理过程,Invoker代表要调用的远程服务代理对象.Protocol#refer方法通过服务类型和URL获得要调用的服务代理 由于Protocol可以实现Invoker和Exporter对象的创建,因此除了作为远程调用对象的构造,还能用于其他用途,如:在创建Invoker的时候对原对象进行包装增强,添加其他Filter进去,ProtocolFilterWrapper实现就是把Filter链加入Invoker. Filter扩展点 Filter是Dubbo的过滤器扩展点,可以自定义过滤器,在Invoker调用前后执行自定义的逻辑.在Filter的实现中,必须要调用传入的Invoker的invoke方法,否则整个链路就断了 12345678@SPIpublic interface Filter &#123; Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException; default Result onResponse(Result, Invoker&lt;?&gt; invoker, Invocation invocation)&#123; return result; &#125;&#125; 一个invoke函数的实现: 1234doSomeThingBefore();Result result = invoker.invoke(invocation);doSomeThingAfter();return result; ExporterListener/InvokerListener扩展点 ExporterListener和InvokerListener这两个扩展点非常相似,ExporterListener是在暴露和取消暴露服务时提供回调;InvokerListener则是在服务引用和销毁引用时提供回调. ExporterListener扩展点源码: 12345@SPIpublic interface ExporterListener &#123; void exported(Exporter&lt;?&gt; exporter) throws RpcException; void unExported(Exporter&lt;?&gt; exporter);&#125; InvokerListener扩展点源码: 12345@SPIpublic interface InvokerListener &#123; void referred(Invoker&lt;?&gt; invoker) throws RpcException; void destroy(Invoker&lt;?&gt; invoker):&#125; Exchange层扩展点 Exchange层只有一个扩展点接口Exchanger,这个接口主要为了封装请求/响应模式,例如:把同步请求转化为异步请求.默认的扩展点实现是org.apache.dubbo.remoting.exchange.support.header.headerExchanger.每个方法上都有@Adaptive注解,会根据URL中的Exchanger参数决定实现. 12345678@SPI(HeaderExchanger.NAME)public interface Exchanger &#123; @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;) ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException; @Adaptive(&#123;Condtants.EXCHANGER_KEY&#125;) ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException;&#125; Exchange层存在的意义是让上层业务不关注Netty这样的底层Channel.上层一个Request只关注对应的Response,对于是同步还是异步,或者是用什么传输根本不关心.Transport层无法满足这项需求的,Exchange层实现了Request-Response模型,可以理解为对Transport层做了高级封装. Transport层扩展点 Transport层为了屏蔽不同通信框架的差异,封装了统一的对外接口.主要的扩展点接口有Transport,Dispatcher,Codec2和ChannelHandler 其中ChannelHandler主要处理连接相关的事件,例如:连接上,断开,发送消息,收到消息,出现异常等.虽然接口上有SPI注解,但是在框架中实现类的确实直接new出来的 Transporter扩展接口 Transporter屏蔽了通信框架接口和实现的不同,使用统一的通信接口 12345678@SPI("netty")public interface Transporter &#123; @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;) Server bind(URL url, ChannelHandler handler) throws RemotingException; @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;) Client connect(URL url, ChannelHandler handler) throws RemotingException;&#125; bind方法会生成一个服务,监听来自客户端的请求;connect方法则会连接到一个服务.两个方法上都有@Adaptive注解,首先会根据URL中的server的参数值去匹配实现类,如果匹配不到则根据transporter参数去匹配实现类.默认的实现是netty4 Dispatcher扩展接口 如果有些逻辑处理比较慢,如IO等.Dispatcher扩展接口通过不同的派发则略,把工作派发到不同的线程池,以此来应对不同的业务场景 12345@SPI(AllDispatcher.NAME)public interface Dispatcher &#123; @Adaptive(&#123;Constants.DISPATCHER_KEY, "dispatcher", "channel.handler"&#125;) ChannelHandler dispatch(ChannelHandler handler, URL url);&#125; Codec2扩展接口 Codec2主要实现对数据的编码和解码,但这个接口只是需要实现编码/解码过程中的通用逻辑流程,如解决半包,粘包等问题.该接口再序列化上封装了一层.Code2扩展接口: // TODO: 半包和粘包 // TODO: 第六章还没读 123456789101112@SPIpublic interface Code2 &#123; @Adaptive(&#123;Constants.CODEC_KEY&#125;) void encode(Channel channel, ChannelBuffer buffer Object message) throws IOException; @Adaptive(&#123;Constants.CODEC_KEY&#125;) object decode(Channel channel, ChannelBuffer buffer) throws IOException; enum DecodeResult &#123; NEED_MORE_INPUT, SKIP_SOME_INPUT &#125;&#125; ThreadPool扩展接口 我们在Transport层由Dispatcher实现不同的派发策略,最终会派发到不同的ThreadPool中执行.ThreadPool接口扩展接口就是线程池扩展 12345@SPI("fixed")public interface ThreadPool &#123; @Adaptive(&#123;Constants.THREADPOOL_KEY&#125;) Executor getExecutor(URL url);&#125; 框架中默认含有四种线程池扩展的实现: fixed 固定大小线程池,启动时简历线程,不关闭,一直持有 cached 缓存线程池,空闲一分钟自动删除,需要时重建 limited 可伸缩线程池,但线程池中的线程数只会增长不会收缩,只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题 eager 优先创建Worker线程池,在任务数量大于corePoolSize小于maximumPoolSize时,优先创建Worker来处理任务,当任务数量大于maximunPoolSize时,将任务放入阻塞队列.阻塞队列充满时抛出RejectedExecutionException(cached在任务数量超过miximumPoolSize时直接抛出异常而不是将任务放入阻塞队列) Serialize层扩展点 Serialize层主要实现具体的对象序列化,只有Serialization一个扩展接口 123456789101112@SPI("hessian2")public interface Serialization &#123; byte getContentTypeId(); String getContentType(); @Adaptive ObjectOutput serialize(URL url, OutputStream output) throws IOException; @Adaptive ObjectInput deserialize(URL url, InputStream input) throws IOException;&#125; 其他扩展点 TelnetHandler扩展点 Dubbo支持Telnet命令链接,Telnet接口就是用于扩展新的Telnet命令的接口 TODO:以后再看 StatusChecker扩展点 通过这个扩展点,可以让Dubbo框架支持各种状态的检查,默认已经实现了内存和load的检查.用户可以自定义扩展,如硬盘,CPU等的状态检查 Container扩展点 服务容器就是为了不需要使用外部的Tomcat,JBoss等Web容器来运行服务,因为有可能服务根本用不到它们的功能,只是需要简单地在Main方法中暴露一个服务即可.此时就可以使用服务容器.Dubbo中默认使用SPring作为服务容器 CacheFactory扩展点 我们可以通过dubbo:method配置每个方法的调用返回值是否进行缓存 Validation扩展点 该扩展点主要实现参数的校验,我们可以在配置中使用&lt;dubbo:service validation=“校验实现名” /&gt;实现参数校验 LoggerAdapter扩展点 日志适配器用于适配各种不同的日志框架,使其拥有统一的使用接口. Compiler扩展点 @Adaptive注解会生成Java代码,然后使用编译器动态编译出新的Class.Compiler接口就是可扩展的编译器]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-7-负载均衡]]></title>
    <url>%2Fdubbo-7%2F</url>
    <content type="text"><![CDATA[负载均衡的封装 容错策略中的负载均衡都使用了抽象父类AbstractCluster中定义的Invoker select方法而并不是直接使用LoadBalance方法,因为抽象父类在LoadBalance的基础上又封装了一些新特性: 粘滞连接 粘滞连接用于有状态服务,尽可能让客户端总是向同一提供者发起调用,除非该提供者挂了,再连接另一台.粘滞连接将自动开启延迟连接,以减少长连接数 可用检测 Dubbo调用的URL中,如果有含有cluster.availablecheck=false,则不会检测远程调用是否可用,直接调用.如果不设置,则默认会开启检查,对所有的服务都做是否可用的检查,如果不可用,则再次做负载均衡 避免重复调用 对于已经调用过的服务,避免重复调用,每次使用同一节点,这种特性主要为了避免并发场景下,某个节点瞬间被大量请求 整个逻辑大致可以分为4步: 检查URL中是否配置粘滞连接,如果有则使用粘滞连接的Invoker.如果没有配置粘滞连接,或者重复调用检测不通过或可用检测不通过,则进入第2步 通过ExtensionLoader获取负载均衡的具体实现,并通过负载均衡做节点的选择.对选择出来的节点做重复调用,可用性检测,通过则返回,否则进入第3步 进行节点的重新选择 如果需要做可用性检测,则会遍历Directory中得到的所有节点,过滤掉不可用和已经调用过的节点,在剩下的节点中重新做负载均衡;如果不需要做可用性检测,则会遍历Directory中得到的所有节点,但只过滤已经调用过的,在剩余的节点中重新做负载均衡.如果在过滤时将所有节点都过滤了不留节点,则进入第4步 遍历所有已经调用过的节点,选出可用的节点,再通过负载均衡选出一个节点并返回.如果还找不到可用的节点,则返回null 负载均衡的总体结构 负载均衡算法: 名称 效果 Random 随机,按权重设置随机概率.再一个截面上碰撞的概率高,但调用量越大分布月均匀,且按概率使用权重后也比较均匀,有利于动态调整提供者的权重 RoundRobin 轮询,按公约后的权重设置轮询比例.存在 慢的提供者积累请求 的问题 LeastActive 最少活跃调用数.如果活跃数相同则随机调用.使慢的提供者收到更少请求 ConsistentHash 一致性Hash,相同参数的请求总是发到同一提供者.当提供者挂掉时,原本发往该提供者的请求,基于虚拟节点,会平摊到其他提供者,不会引起剧烈变动 4中负载均衡算法都继承自同一个抽象类,使用的也是模板模式,抽象父类中已经把通用的逻辑完成,留一个抽象的doSelect方法给子类实现 Random负载均衡 Random负载均衡 RoundRobin负载均衡 普通的轮询的好处是每个节点获得的请求是很均匀的,如果某些节点的负载能力比较弱,则这个节点会堆积较多的请求. 普通轮询之外是权重轮询.权重轮询又分为普通权重轮询和平滑权重轮询.普通权重轮询会造成某个节点会突然频繁选中,这样很容易突然让一个节点流量暴增.平滑权重轮询在轮询时会穿插其他节点,让整个服务器的选择的过程比较均匀,不会逮住一个节点一直调用.Dubbo使用平滑权重轮询. TODO:平滑权重轮询实现细节 LeastActive负载均衡 最少活跃调用数负载均衡.框架会记下每个Invoker的活跃数,每次只从活跃数最少的Invoker里选一个节点.这个算法需要配合ActiveLimitFilter过滤器来计算每个接口方法的活跃数.最少活跃负载均衡可以看做Random负载均衡的加强版,因为最后根据权重做负载均衡的时候,使用的算法和Random是一样的 其会遍历所有Invoker,不断寻找最小的活跃数,如果有多个Invoker活跃数都等于leastActive,则把他们保存到同一个集合中,最后在这个Invoker集合中再通过随机的方式选出一个Invoker 一致性Hash负载均衡 一致性Hash负载均衡可以让参数相同的请求每次都路由到相同的机器上.相比于直接使用Hash负载均衡而言,某些节点下线时,请求会平摊到其他服务提供者,不会引起剧烈变动 Merger的实现 当一个接口有多种实现,消费者有需要同时引用不同的实现时,可以用group来区分不同的实现.如: 12&lt;dubbo:service group="group1" interface="com.xxx.SomeInterface" /&gt;&lt;dubbo:service group="group2" interface="com.xxx.SomeInterface" /&gt; TODO: Merger和Mock]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-6-Dubbo集群容错]]></title>
    <url>%2Fdubbo-6%2F</url>
    <content type="text"><![CDATA[Cluster层概述 Cluster的总体工作流程可以分为以下几种: 生成Invoker对象 不同的Cluster实现会生成不同类型的ClusterInvoker对象并返回.然后调用ClusterInvoker的Invoker方法,正式开始调用流程 获得可调用的服务列表 首先会做前置校验,检查远程服务是否已被销毁.然后通过Directory#list方法获取所有可用的服务列表.接着使用Router接口处理该服务列表,根据路由规则过滤一部分服务,最终返回剩余的服务列表 负载均衡 服务列表还需要通过不同的负载均衡策略选出一个服务,首先框架会根据用户的配置,调用ExtensionLoader获取不同负载均衡策略的扩展点实现.然后做一些后置操作,如果是异步调用则设置调用编号.接着调用子类实现的doInvoke方法,子类会根据具体的负载均衡策略选择一个可以调用的服务 RPC调用 首先保存每次调用的Invoker到RPC上下文,并做RPC调用.然后处理调用结果,对于调用出现异常,成功,失败等情况,每种容错策略会有不同的处理方式. 上图是一个全量的通用流程,其中1~3步都是在抽象方法AbstractClusterInvoker中实现的,可以理解为通用的模板流程,主要做了校验,参数准备等工作. 容错机制 Dubbo容错机制能增强整个应用的稳定性,容错过程对上层用户是完全透明的,但用户也可以通过不同的配置项来选择不同的容错机制.每种容错机制又有自己的个性化配置项. Dubbo各种容错机制的特性: 机制名 机制简介 Failover Dubbo默认的容错机制.当出现失败时,会重试其他服务器.可以通过retries=2设置重试次数.会对请求做负载均衡.通常使用在读操作或幂等的写操作上,但重试会导致接口的延迟增大,在下游机器负载已经达到极限时,重试容易加重下游的服务的负载 Failfast 快速失败,当请求失败后,快速返回异常结果,不做任何重试.该容错机制会对请求做负载聚恒,通常使用在非幂等的接口上.该机制收网络抖动的影响较大 Failsafe 当出现异常时,直接忽略异常.会对请求做负载均衡.通常使用在&quot;佛系&quot;调用场景,即不关心成功不成功,并不想抛出异常影响外层调用.如某些不重要的异常同步,即使出现异常也无所谓 Failback 请求失败后,会自动记录在失败队列中,并由一个定时线程池定时重试,适用于一些异步或者最终一致性的请求.会对请求做负载均衡 Forking 同时调用多个相同的服务,只要其中一个返回,则立刻返回结果.用户可以配置forks=&quot;最大并行调用数&quot;参数来确定最大并行调用的服务数量.通常使用在对接口实时性要求极高的调用上,但也会很浪费资源]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-5-Dubbo远程调用]]></title>
    <url>%2Fdubbo-5%2F</url>
    <content type="text"><![CDATA[Dubbo调用介绍 首先客户端启动时会从注册中心拉取和订阅对应的服务列表,Cluster会把拉取到的服务列表聚合成一个Invoker,每次RPC调用前会通过Directory#list获取provider地址,获取这些服务列表给后续路由和负载均衡使用 应图中①中主要是将多个服务提供者做聚合.在框架内部另外一个实现Directory接口RegistryDirectory类,它和接口名是一一对应的关系,主要负责拉取和订阅服务提供者,动态配置和路由项 在Dubbo发起服务调用时,所有路由和负载均衡都是在客户端实现的.客户端服务调用首先会触发路由操作,然后将路由结果得到的服务列表作为负载均衡参数,经过负载均衡后会选出一台机器进行RPC调用,这三个步骤对应②,③,④.客户端经过路由和负载均衡后,会将请求交给底层I/O线程池(比如Netty)处理.I/O线程池主要处理读写,序列化和反序列化等逻辑,因此这里一定不能用阻塞操作.Dubbo也提供了控制参数控制(decode.in.io)参数,在处理反序列化对象时会在业务线程池中处理.在⑤中包含两种类似的线程池,一种是I/O线程池,另一种是Dubbo业务线程池 下面说的Telnet的东西我都不知道是啥 目前Dubbo将服务调用和Telent调用做了端口复用,在编码层面也做了适配.在Telnet调用时,会建立起一个TCP链接,传递接口,方法和JSON格式的参数进行服务调用,在编译码层面读取六中的字符串,最终交个Telnet对应的Handler去解析方法调用.如果是非Telnet调用,则服务提供方会根据传递过来的接口,分组和版本信息查找Invoker对应的实例进行反射调用.在⑦中进行了端口复用,如果是Telnet调用,则先找到对应的Invoker进行方法调用.Telnet和正常的RPC调用不一样的地方是序列化和反序列化使用的不是Hession方式,而是直接使用fastjson进行处理 Dubbo协议 Dubbo协议涉及参考了现有的TCP/IP协议,一次RPC调用包括协议头和协议提两部分,16字节长的报文头部主要携带了模式以及当前请求报文是否是Request,Response,心跳和事件的信息,请求时也会带上当前报文体内序列化协议编号.除此之外,请求报文还携带了请求状态,以及请求唯一表示和报文体长度 Dubbo协议字段解析: 偏移比特位 字段描述 作用 0~7 魔数高位 8~15 魔数低位 16 数据包类型 是否为双向的RPC调用,0位Response,1为Request 17 调用方式 仅在第16位设置为1的情况下有效0为单向调用,1位双向调用比如在优雅停机时服务端发送readonly不需要双向调用,这里标志位就不会设定 18 事件标识 0为当前数据包时请求或响应包1为当前数据包时心跳包,设置了心跳包的报文不会透传到业务方法调用,仅用于框架内部保活机制 19~23 序列化器编号 2 为Hessian2Serialization3 为JavaSerialization4 为CompactedSerialization6 为FastJsonSerialization7 为NativeJavaSerialization8 为KryoSerialization9 为FstSerialization 24~31 状态 20 为OK30 为CLIENT_TIMEOUT31 为SERVER_TIMEOUT40 为BAD_REQUEST50 为BAD_RESPONSE60 为SERVICE_NOT_FOUND70 为SERVICE_ERROR80 为SERVER_ERROR90 为CLIENT_ERROR100 为SERVERTHREADPOOL_EXHAUSTEDERROR(服务端线程池满拒绝执行) 32~95 请求编号 8个字节存储RPC请求的唯一id,用来将请求和响应做关联 96~127 消息体长度 占用4个字节存储消息体长度.再一次RPC请求过程中,消息体中一次会存储7部分内容 在消息体中,客户端严格按照序列化顺序写入信息,服务端也会遵循相同的顺序读取消息.客户端发起请求的消息体一次保存下列内容:Dubbo版本号,服务接口名,服务接口版本,方法名,参数类型,方法参数值和请求额外参数 响应标记: 状态值 状态符号 作用 5 RESPONSE_NULL_VALUE_WITH_ATTACHMENTS 响应空值包含隐藏参数 4 RESPONSE_VALUE_WITH_ATTACHMENTS 响应结果包含隐藏参数 3 RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS 异常返回包含隐藏参数 2 RESPONSE_NULL_VALUE 响应空值 1 RESPONSE_VALUE 响应结果 0 RESPONSE_WITH_EXCEPTION 异常返回 在返回消息体中,会先把返回值状态标记写入输出流,紧接着再写返回方法值 Dubbo使用特殊符号0xdabb魔数来分割处理粘包问题 客户端使用多线程并发调用服务时,Dubbo通过使用协议头的全局请求id标识正确响应调用的线程 客户端多个线程并发请求时,框架内部会调用DefaultFuture对象get方法进行等待,在请求发起时,框架内部会创建Request对象,这个时候会被分配一个唯一id,DefaultFuture可以从Request对象中获取id,并将关联关系存储到静态HashMap中(即上图的Futures).当客户端收到响应时,会根据Response对象中的id,从Futures集合中查找对应的DefaultFuture对象,最终会唤醒对应的线程并通知结果.客户端也会启动一个定时扫描去探测超时没有返回的请求 编解码器 TODO Telnet调用原理 编码器把Telnet当做明文字符串处理,按照Dubbo的调用规范,解析成掉用命令格式,然后查找对应的Invoker,发起方法调用 Telnet指令解析原理 Telnet指令解析被设置成了扩展点TelnetHandler,每个Telnet指令都会实现这个扩展点. 通过这个扩展点定义,能够解决扩展更多命令的诉求.message包含处理命令之外的所有字符串参数,具体如何使用这些参数以及这些参数的定义全部交给命令实现者决定. 完成Telnet指令转发的核心实现类是TelnetHandlerAdapter,它的实现非常简单,首先将用户输入的指令识别成command,然后将剩余的内容解析成message.message会交给命令实现者去处理. TODO Telnet实现健康监测 Telnet提供了健康检查的指令,可以在Telnet连接成功后执行status -l查看线程池,内存和注册中心等状态信息. TODO]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-4-Dubbo起停原理]]></title>
    <url>%2Fdubbo-4%2F</url>
    <content type="text"><![CDATA[配置解析 目前Dubbo框架同时提供了3中配置方式:XML配置,注解,属性文件配置 基于schema设计解析 Dubbo框架直接集成了Spring的能力,利用了Spring配置文件扩展出自定义的结息方式.Dubbo配置约束文件在dubbo-config/dubbo-config-spring/src/main/resources/dubbo.xsd中 dubbo.xsd文件用来约束使用XML配置时的标签和对应属性,比如Dubbo中的dubbo:service和dubbo:reference标签等.Spring在解析到自定义的namespace标签是,会查找对应的spring.schemas和spring.handlers文件,最终触发Dubbo的DubboNamespaceHandler类来进行初始化和解析 1234567// spring.schemas文件http\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsdhttp\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/compat/dubbo.xsd// spring.handlers文件http\://dubbo.apache.org/schema/dubbo=org.apache.dubbo.config.cpring.schema.DubboNamespaceHandlerhttp\://code.alibabatech.com/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler 其中,spring.schemas文件指明约束文件的具体路径,spring.handlers文件指明DubboNamespaceHadler类来解析标签 Dubbo设计之初也考虑到属性最大限度的复用,因此对schema进行了精心的设计,Dubbo schema层级详细设计: TODO:]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-3-Dubbo扩展点机制]]></title>
    <url>%2Fdubbo-3%2F</url>
    <content type="text"><![CDATA[加载机制概述 Dubbo良好的扩展性与两个方面密不可分:一个是整个框架中针对不同场景,恰到好处地使用了各种设计模式,二就是加载机制.基于Dubbo SPI加载机制,让整个框架的接口和具体的实现完全解耦,从而奠定了整个框架良好可扩展性的基础. Dubbo定义了良好的框架结构,它默认提供了很多可以直接使用的扩展点.Dubbo几乎所有的功能组件都是基于扩展机制(SPI)实现的. Dubbo没有直接使用Java SPI,而是在它的思想上又做了一定的改进,形成一套自己的配置规范与特性.同时,Dubbo又兼容Java SPI.服务在启动的时候Dubbo就会查找这些扩展点的所有实现. Java SPI SPI全称是Service Provider Interface,起初是提供厂商做插件开发的. Java SPI使用了策略模式,一个接口多种实现.我们只声明接口,具体的实现并不在程序中直接确定,而是由程序之外的配置掌控 12345678910+--java| +--com| +--test| +--spi| --PrintService| --PrintServiceImpl+--resources| +--META-INF| +--services| --com.test.spi.PrintService 1234567891011121314151617public interface PrintService&#123; void printInfo();&#125;public class PrintServiceImpl implements PrintService &#123; @Override public void printInfo() &#123; Systom.out.println("hello"); &#125;&#125;public static void main(String[] args) &#123; ServiceLoader&lt;PrintService&gt; serviceLoader = ServiceLoader.load(PrintService.class); for (PrintService printService : serviceLoader) &#123; printService.printInfo(); &#125;&#125; 扩展点加载机制的改进 与Java SPI相比,Dubbo SPI做了一定的改进与优化,官方文档有这么一段: JDK标准的SPI会一次实例化扩展点所有实现,如果有扩展实现则初始化很好使,如果没有用上也加在,则浪费资源如果扩展加载失败,则连扩展的名称都获取不到了增加了对扩展IoC和AOP的支持,一个扩展可以直接setter注入其他扩展.java.util.ServiceLoader会一次把接口下的所有实现类全部初始化,用户直接调用即可.Dubbo SPI只是加载配置文件中的类,并分成不同的种类缓存在内存中,而不会立即全部初始化,在性能上有更好的表现 12345678910111213141516@SPI("impl")public interface PrintService &#123; void printInfo();&#125;public class PrintServiceImpl implements PrintService &#123; @Override public void printInfo() &#123; System.out.println("hello"); &#125;&#125;public static void main(String[] args) &#123; PrintService printService = ExtensionLoader.getExtensionLoader("PrintService.class").getDefaultExtension(); printService.printInfo();&#125; Java SPI加载失败,可能会因为各种原因导致异常信息被&quot;吞掉&quot;,导致开发人员问题追踪比较困难.Dubbo SPI在扩展加载失败的时候会先抛出真实立场并打印日志.扩展点在被动加载的时候,即使有部分扩展加载失败也不会影响其他扩展点和整个框架的使用. Dubbo SPI自己实现了IoC和AOP机制,一个扩展点可以通过setter方法直接注入其他扩展的方法,T injectExtension(T instance)方法实现了这个功能.另外,Dubbo支持包装扩展类,推荐把通用的抽象逻辑放到包装类中,用于实现扩展点的AOP特性.比如ProtocolFilterWapper包装扩展了DobboProtocol类,一些通用的判断逻辑全部放在了ProtocolFilterWrapper类的export方法中,但最终会调用DubboProtocol#export方法.这和Spring动态代理思想一样,在被代理的前后插入自己的逻辑进行增强,最终调用被代理类.下面是ProtocolFilterWrapper.export方法: 123456public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol()))&#123; return protocol.export(invoker); &#125; ...&#125; 扩展点的配置规范 Dubbo和Java SPI类似,需要在META-INF/dubbo/下设置对应的SPI配置文件,文件名称需要命名为接口的全路径名.配置文件的内容为key=扩展点实现类全路径名(如: cat=com.ggemo.test.service.Animal),如果有多个实现类则使用换行符分隔.其中,key会作为Dubbo SPI注解中的传入参数.另外,Dubbo SPI还兼容了Java SPI的配置路径和内容配置方式.在Dubbo启动的时候,会默认扫这三个目录下的配置文件:META-INF/services/ ,META-INF/dubbo/ ,META-INF/dubbo/internal/ 规范名 规范说明 SPI配置文件路径 META-INF/services/ ,META-INF/dubbo/ ,META-INF/dubbo/internal/ SPI配置文件名称 全路径类名 文件内容格式 key=value方式,多个用换行符分隔 扩展点的分类与缓存 Dubbo SPI可以分为Class缓存,实例缓存.这两种缓存有能根据扩展类的种类分为普通扩展,包装扩展类,自适应扩展类等. Class缓存 Dubbo SPI获取扩展类时,会先从缓存中读取.如果缓存中不存在,则加载配置文件,根据配置把Class缓存到内存中,并不会直接全部初始化. 实例缓存 基于性能考虑,Dubbo框架中不仅缓存Class,也会缓存Class实例化后的对象.每次获取的时候,会先从缓存中获取,如果缓存中读不到,则重新加载并缓存起来. 缓存也是为什么Dubbo SPI相对于Java SPI性能上有优势的原因,因为Dubbo缓存的Class并不会全部实例化,而是按需实例化并缓存,因此性能最好 被缓存的Class和对象实例可以根据不同的特性分为不同的类别: 普通包装类 最基础的,配置在SPI配置文件中的扩展类实现 包装扩展类 这种Wrapper类没有具体的实现,只是做了通用逻辑的抽象,并且需要在构造方法中传入一个具体的扩展接口的实现.属于Dubbo的自动包装特性. 自适应扩展类 一个扩展接口会有多种实现类,具体使用哪个实现类可以不写死在代码或配置里,通过传入URL中的某些参数动态来确定.这属于扩展点的智适应特性. 其他缓存 如扩展类加载器缓存,扩展名缓存等 Class缓存: 集合名 缓存类型 Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses 普通扩展类缓存,不包括自适应扩展类和Wrapper类 Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses Wrapper类缓存 Class&lt;?&gt; cachedAdaptiveClass 自适应扩展类缓存 ConcurrentMap&lt;String, Holder&gt; cachedInstances 扩展名与扩展对象缓存 Holder cachedAdaptiveInstance 实例化后的自适应(Adaptive)扩展对象,只能同时存在一个 ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames 扩展类与扩展名缓存 ConcurrentMap&lt;Class, ExtensionLoader&gt; EXTENSION_LOADERS 扩展类与对应的扩展类加载器缓存 ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES 扩展类与类初始化后的实例 Map&lt;String, Active&gt; cachedActivates 扩展名与@Active的缓存 扩展点的特性 扩展类一共包含四种特性:自动包装,自动加载,自适应和自动激活 自动包装 ExtensionLoader在加载扩展时,如果发现这个扩展类包含其他扩展点作为构造函数的参数,则这个扩展类就会被认为是Wrapper类.Wrapper类示例代码: 12345678910public class ProtocolFilterWrapper implements Protocol &#123; private final Protocol protocol; public ProtocolFilterWrapper(Protocol protocol) &#123; if (protocol == null) &#123; throw new illegalArgumentException("protocol = null"); &#125; this.protocol = protocol; &#125; ...&#125; ProtocolFilterWrapper虽然继承了protocol, 但是其构造函数中又注入了一个Protocol类型的参数,因此ProtocolFilterWrapper被认为是一个Wrapper类.这是一种装饰器模式,把通用的抽象逻辑进行封装或对子类进行增强,让子类更加专注具体的实现 自动加载 除了在构造函数中传入其他扩展实例,我们还经常使用setter方法设置属性值,如果某个扩展类时另外一个扩展点类的成员属性,并且拥有setter方法,那么框架也会自动注入对应的扩展点实例.ExtensionLoader在执行扩展点初始化的时候,会自动通过setter方法注入对应的实现类. 这里存在一个问题,如果扩展类属性是一个接口,它有多种实现,那么具体注入那个要通过自适应特性判断 自适应 在Dubbo SPI中,我们使用@Adaptive注解,可动态地通过URL中的参数来确定姚世勇哪个具体的实现类,从而解决自动加载中的实例注入问题.示例代码: 12345678@SPI("netty")public interface Transporter &#123; @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;) Server bind(URL url, ChannelHandler handler) throws RemotingException; @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;) Server connect(URL url, ChannelHandler handler) throws RemotingException;&#125; @Adaptice注解传入了两个Constants中的参数,它们的值分别是&quot;server&quot;和&quot;transporter&quot;.当外部调用Transporter#bind方法时,会动态从传入的参数URL中提取key参数&quot;server&quot;的value,如果能匹配上某个扩展实现类则直接使用对应的实现类;如果未匹配上,则继续通过第二个key参数&quot;transporter&quot;提取value;如果都没匹配上则抛出异常.即,如果@Adaptive中传入了多个参数,则依次进行实现类匹配,知道最后抛出异常. 这种动态寻找实现类的方式比较灵活,但只能激活一个具体的实现类,如果需要多个实现类同时被激活,如Filter可以同时有多个过滤器;或者根据不同的条件,同时激活多个实现类,则需要依靠最后一个特性. 自动激活 使用@Active注解,可以标记对应的扩展点默认被激活启用.该注解可以传入不同的参数,设置扩展点在不同条件下自动激活.主要的使用场景是某个扩展点的多个实现类需要同时启用. 扩展点注解 扩展点注解: @SPI @SPI注解可以使用类,接口,枚举上,Dubbo框架中都是使用在接口上的.它的主要作用就是标记这个接口是一个Dubbo SPI接口,即是一个扩展点,可以有多个不同的内置或用户定义的实现.运行时需要通过配置找到具体的实现类.@SPI注解的源码: 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)public @interface SPI &#123; String value() default "";&#125; @SPI注解有一个value属性,通过这个属性我们可以传入不同的参数来设置这个接口的默认实现类.例如,我们可以看到Transporter接口使用Netty作为默认实现: 1234@SPI("netty")public interface Transporter &#123; ...&#125; Dubbo中很多地方通过getExtension(Class type, String name)来获取扩展点接口的具体实现,此时会对传入的Class做校验,判断是否是接口,以及是否有@SPI注解,两者缺一不可. 扩展点自适应注解: @Adaptive @Adaptive注解可以标记在类,接口和方法上,但是在整个Dubbo框架中,只有几个地方使用在类级别上,如AdaptiveExtensionFactory和AdaptiveCompiler,其余都标注在方法上.如果标注在接口的方法上,即方法级别的注解,则可以通过参数动态获得实现类.方法级别注解在第一次getExtension时,会自动生成和编译一个动态的Adaptive类,从而达到动态实现类的效果. 例如上面的Transporter接口再bind和connect两个方法上添加了@Adaptive注解.Dubbo在初始化扩扎你按时,会生成一个Transporter$Adaptive类,里面会实现这两个方法,方法里会有一些抽象的通用逻辑,通过Adaptive传入的参数,找到并调用真正的实现类. 如Dubbo的Transporter的bind方法: 12@Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)Server bind(URL url, ChannelHandler handler) throws RemotingException; 两种实现: TODO:什么玩意啊以后再看 扩展点自动激活注解: @Activate @Activate可以标记在类,接口,枚举类和方法上.主要使用在有多个扩展点实现,需要根据不同条件被激活的场景中.如Filter需要多个同时激活,因为每个Filter实现的是不同的功能. @Activate可传入的参数: 参数名 效果 String[] group() URL的分组如果匹配则激活,则可以设置多个 String[] value() 查找URL中如果含有该key值,则会激活 String[] before() 填写扩展点列表,表示哪些扩展点要在本扩展点之前 String[] after() 同上,表示哪些扩展点要在本扩展点之后 int order() 直接的排序信息 ExtensionLoader的工作原理 ExtensionLoader是整个扩展机制的主要逻辑类,在这个类里面实现了配置的加载,扩展类缓存,自适应对象生成等所有工作. 工作流程 ExtensionLoader的逻辑入口可以分为getExtension,getAdaptiveExtension,getActivateExtension,分别是获取普通扩展类,获取自适应扩展类,获取自动激活的扩展类. 总体逻辑从调用这三个方法开始,每个方法可能有不同的重载方法. 三个入口中,getActivateExtension对getExtension的依赖比较重,getAdaptiveExtension则相对独立 getActivateExtension方法只是根据不同的条件同时激活多个普通扩展类,因此,该方法中只会做一些通用的判断逻辑,如接口中是否包含@Activate注解,匹配条件是否符合等.最终还是通过调用GetExtension方法获得具体扩展点实现类. getExtension(String name)是整个扩展加载器中最核心的方法,实现了一个完整的普通扩展类加载过程.加载过程中的每一步,都会先检查缓存中是否已经存在所需的数据,如果存在则直接从缓存中读取,没有则重新加载.这个方法每次只会根据名称返回一个扩展点实现类. 初始化过程: 框架读取SPI对应路径下的配置文件,并根据配置加载所有扩展类并缓存(不初始化) 根据传入的名称初始化对应的扩展类 尝试查找符合条件的包装类 返回对应的扩展类实例 getAdaptiveExtension也相对独立,只有加载配置信息部分与getExtension共用了同一个方法.和普通扩展类一样,框架会先检查缓存中是否有已经初始化好的Adaptive实例,没有则调用createAdaptiveExtension重新初始化. 初始化过程: 加载配置文件 生成自适应类的代码字符串 获取类加载器和编译器,并用编译器编译刚刚生成的代码字符.Dubbo一共有三种类型的编译器实现(后面会讲到) 返回对应的自适应类实例 getExtension的实现原理 当调用getExtension(String name)方法时,会先检查缓存中是否有线程的数据,没有则调用createExtension开始创建.这里有个特殊点,如果getExtension传入的name是true,则加载并返回默认扩展类. 在调用createExtension开始创建的过程中,也会先检查缓存中是否有配置信息,如果不存在扩展类,则会从resources中加载. 加载完扩展点配置后,再通过反射获得所有扩展实现类并缓存起来,这时,JVM仅仅将Class加载进内存中,但并没有做初始化.在加载Class文件时,会根据Class上的注解来判断扩展点类型,再根据类型分类做缓存. 最后,根据传入的name找到对应的类并通过Class.forName方法进行初始化,为其注入依赖的其他扩展类(自动加载特性).当扩展类初始化后,会检查一次包装扩展类Set&lt;Class&lt;?&gt;&gt;wrapperClasses,查找包含与扩展点类型相同的构造函数,为其注入刚初始化的扩展类.依赖注入代码: 1234567injectExtension(instance); // 向扩展类注入其他依赖属性,如扩展类A又依赖的扩展类BSet&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;if (wrapperClass != null &amp;&amp; !wrapperClasses.isEmpty()) &#123; for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123; instance = injectExtension((T) wrapperClass.getConstructor(type)).newInstance(instance); // 找到构造方法参数类型为type(扩展类的类型)的包装类,为其注入扩展类实例 &#125;&#125; 在injectExtension方法中可以为类注入依赖属性,它使用了ExtensionFactory#getExtension(Class type, String name)来获取对应的bean实例 injectionExtension方法总体实现了类似Spring的IoC机制,其实现原理比较简单:首先通过反射获取类的所有方法,然后遍历以字符串set开头的方法,得到set方法参数类型,再通过ExtensionFactory寻找参数类型相同的扩展类实例,如果找到,就设值进去. 123456789101112for (Method method : instance.getClass().getMethods()) &#123; if(method.getName().startWith("set") &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; Class&lt;?&gt; pt = method.getParameterTypes()[0]; ... String property = ...; // 通过字符串截取,获得小写开头的类名,如setTestService,截取testService Object object = objectFactory.getExtension(pt, property); if (object != null) &#123; method.invoke(instance, object); &#125; ... &#125;&#125; 从上面代码可知包装类的构造参数注入也是通过injectionExtension方法实现的 getAdaptiveExtension的实现原理 TODO 扩展点动态编译的实现 动态编译时Dubbo SPI自适应特性的基础,因为动态生成的自适应类只是字符串,需要通过编译得到真正的Class.虽然可以使用反射来动态代理一个类,但是在性能上和直接编译好的Class会有一定差距.Dubbo SPI通过代理的动态生成,配合动态编译器,灵活地在原始类的基础上创建新的自适应类. 总体结构 Dubbo中有三种代码编译器,分别是JDK编译器,Javassist编译器和AdaptiveCompiler编译器.这几种编译器都实现了Compiler接口. Compile接口上含有一个SPI注解,注解的默认值是@SPI(“javassist”) AdaptiveCompiler上面有@Adaptive注解,说明AdaptiveCompiler会固定为默认实现,这个Compiler的主要作用和AdaptiveExtensionFactory相似,就是为了管理其他Compiler. AdaptiveCompiler#setDefaultCompiler方法会在ApplicationConfig中被调用,也就是Dubbo在启动时,会解析配置中的&lt;dubbo:application compiler=“jdk” /&gt;标签,获取设置的值,初始化对应的编译器. AbstractCompiler是一个抽象类,里面封装了通用的模板逻辑.还定义了一个抽象方法doCompile,留给子类来实现具体的编译逻辑.AbstractCompiler的主要抽象逻辑如下: 通过正则匹配出包路径,类名,再根据包路径,类名拼接出全路径名 尝试通过Class.forName加载类并返回,防止重复编译.如果类加载器中没有这个类,则进入第三步 调用doCompile方法进行编译 Javassist动态代码编译 Java中动态生成Class的方式有很多,可以直接基于字节码的方式生成,常见的工具有CGLIB,ASM,Javassist等.而自适应扩展点使用了生成字符串代码再编译为Class的方式. Javassist生成一个&quot;Hello World&quot;的例子: 12345678ClassPool classPool = ClassPool.getDefault();CtClass ctClass = classPool.makeClass("Hello World");CtMethod ctMethod = CtNewMethod.make("public static void test()&#123;System.out.println(\"Hello World\");&#125;",ctClass);ctClass.addMethod(ctMethod);Class aClass = ctClass.toClass();Object object = aClass.newInstance();Method m = aClass.getDeclaredMethod("test", null);m.invoke(object, null); // 这行会打印出Hello World Javassist不断通过正则表达式匹配不同不问的代码,然后调用Javassist库中的API生成不同部位的代码,最后得到一个CLass对象: 初始化Javassist,设置默认参数,如设置当前的classpath 通过正则匹配出所有import包,并使用Javassist添加import 通过正则匹配出所有的extends包,创建Class对象,并使用Javassist添加extends 通过正则匹配出所有implements包,并使用Javassist添加implements 通过正则匹配出类里面的所有内容,即得到{}中的内容,再通过正则匹配出所有方法,并使用Javassist添加类方法 生成Class对象 JDK动态代码编译 JdkCompiler是Dubbo编译器的另一种实现,使用了JDK自带的编译器,原生JDK编译包位于javax.tools下,主要使用了三个东西:JavaFileObject接口,ForwardingJavaFileManager接口,JavaCompiler.CompilationTask方法.整个动态编译过程可以简单地总结为:首先初始化一个JavaFileObject对象,并把代码字符串作为参数传入构造方法,然后调用JavaCompiler.CompilationTask方法编译出具体的类.JavaFileManager负责管理类文件的输入/输出位置. JavaFileObject接口 字符串代码会被包装成一个文件对象,并提供获取二进制流的接口.Dubbo框架中的JavaFileObjectImpl类可以看做该接口的一种扩展实现,构造方法中需要传入生成好的字符串代码,此文件对象的输入和输出都是ByteArray流. JavaFileManager接口 主要管理文件的读取和输出位置.JDK中没有可以直接使用的实现类,唯一的实现类ForwardingJavaFileManager构造器又是protect类型,因此Dubbo中定制化实现了一个JavaFileManagerImpl类,并通过一个自定义类加载器ClassLoaderImpl完成资源加载 JavaCompiler.CompilationTask 把JavaFileObject对象编译成具体的类]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-2-注册中心]]></title>
    <url>%2Fdubbo-2%2F</url>
    <content type="text"><![CDATA[注册中心概述 在Dubbo微服务体系中,注册中心是其核心组件之一.Dubbo通过注册中心实现了分布式环境中各服务之间的注册与发现,是各个分布式节点之间的纽带. 主要作用 动态注册 一个服务提供者通过注册中心可以动态地把自己暴露给其他消费者,无需消费者朱歌曲更新配置文件. 动态发现 一个消费者可以动态地感知新的配置,路由规则和服务提供者,无需重启服务. 动态调整 注册中心支持参数的动态调整,新参数自动更新到所有相关服务节点. 统一配置 避免了本地配置导致每个服务配置不一致的问题 模块 Dubbo注册中心源码在Dubbo-registry中,其包含五个子模块: 模块名称 模块介绍 Dubbo-registry-api 包含了注册中心所有的API和抽象实现类 Dubbo-registry-zookeeper 使用ZooKeeper作为注册中心的实现 Dubbo-registry-redis 使用Redis作为注册中心的实现 Dubbo-registry-default Dubbo基于内存的默认实现 Dubbo-registry-multicast multicast模式的服务注册与发现 工作流程 服务提供者启动 会向注册中心写入自己的元数据信息,同时会订阅配置元数据信息 消费者启动 也会想注册中心写入自己的元数据,并订阅服务提供者,路由和配置元数据信息 服务治理中心(Dubbo-admin)启动 会同时订阅所有消费者,服务提供者,路由和配置元数据信息 当有服务提供者离开或有新的服务提供者加入 注册中心服务提供者目录会发生变化,变化信息会动态通知给消费者,服务治理中心 当消费者发起服务调用 会异步将调用,统计信息等上报给监控中心(Dubbo-monitor-simple) 数据结构 ZooKeeper ZooKeeper是树形结构注册中心 节点类型 持久节点 服务注册后保证借点不会丢失,注册中心重启也会存在 持久顺序节点 在持久节点的基础上增加了节点先后顺序的能力 临时节点 服务注册后连接丢失或session超时,注册的节点会自动被溢出 临时顺序节点 在临时节点特性的基础上增加了节点先后顺序的能力 Dubbo使用ZooKeeper作为注册中心时,只会创建持久节点和临时节点两种,对顺序没有要求 概述 /Dubbo/com.foo.BarService/providers 是服务提供者在ZooKeeper注册中心的一个示例,是一种属性结构,该结构分为4层: root 根节点,对应示例中的Dubbo service 接口名称,对应示例中的com.foo.BarService 四种服务目录 对应实例中的providers,其他目录还有consumers,routers,configurators 树形结构的关系 树的根节点是注册中心分组 下面有多个服务接口,分组值来自用户配置Dubbo:registry中的group属性,默认是/Dubbo 服务接口下包含4类子目录 分别是providers,consumers,routers,configurators,这个路径是持久节点 服务提供者目录 (/Dubbo/service/providers) 下面包含的接口有多个服务者URL元数据信息 服务消费者目录 (/Dubbo/service/consumers) 下面包含的接口有多个消费者URL元数据信息 路由配置目录 (/Dubbo/service/routers) 下面包含多个用于消费者路由策略URL元数据信息 动态配置目录 (/Dubbo/service/configurator) 下面包含多个用于服务者动态配置URL元数据信息 在Dubbo框架启动时,会根据用户配置的服务,在注册中心中创建4个目录,在providers和consumers目录中分别存储服务提供方,消费方元数据信息,主要包括IP,端口,权重和应用名等数据. 在Dubbo框架进行服务调用时,用户可以通过服务治理平台(Dubbo-admin)下发路由配置.如果要在运行时改变服务参数,则用户可以通过服务治理平台下发动态配置.服务端会通过订阅机制收到属性变更,并重新更新已经暴露的服务. 目录名称 存储值样例 /Dubbo/service/providers Dubbo://192.168.0.1.20880/com.alibaba.demo.Service?key=value&amp;… /Dubbo/service/consumers Dubbo://192.168.0.1.5002/com.alibaba.demo.Service?key=value&amp;… /Dubbo/service/routers condition://0.0.0.0/com.alibaba.demo.Service?category=routers&amp;key=value&amp;… /Dubbo/service/configurators override://0.0.0.0/com.alibaba.demo.Service?category=configurators&amp;key=value&amp;… 服务元数据中的所有参数都是以键值对形式存储的. 订阅/发布 发布的实现 服务提供者和消费者都需要把自己注册到注册中心.服务提供者的注册是为了让消费者感知服务的存在,从而发起远程调用;也让治理中心感知有新的服务提供者上线.消费者的发布是为了让服务治理中心发现自己.Dubbo中ZooKeeper发布代码非常简单,只是调用了ZooKeeper的客户端库在注册中心上创建一个目录 创建目录: 1zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true)); 删除目录: 1zkClient.delete(toUrlPath(url)); 订阅的实现 订阅通常有pull和push两种方式,一种是客户端定时轮询注册中心拉取配置,另一种是注册中心主动推送数据给客户端.这两种方式各有利弊,目前Dubbo采用的是第一次启动拉取方式,后续接收事件重新拉取数据 在服务暴露时,服务端会订阅configurators用于监听动态配置,在消费端启动时,消费端会订阅providers,routers和configurators这三个目录,分别对应服务提供者,路由和动态配置变更通知. ZooKeeper注册中心采用的是&quot;事件通知&quot; + &quot;客户端拉取&quot;的方式,客户端再第一次连接上注册中心时,会获取对应目录下全量数据,并在订阅的节点上注册一个watcher,客户端与注册中心之间保持TCP长连接,后续每个节点有任何数据变化的时候,注册中心会根据watcher的回调主动通知客户端(事件通知),客户端接到通知后,会把对应节点下的全量数据都拉取过来(客户端拉取).这一点在NotifyListener#notify(List urls)接口上就有约束的注释说明.全量拉取有一个局限,当微服务节点较多时会对网络造成很大的压力. ZooKeeper的每个节点都有一个版本号,当某个节点的数据发生变化(即事务操作)时,该节点对应的版本号就会发生变化,并触发watcher时间,推送数据给订阅放,版本号强调的是变更次数,即使该节点的值没有变化,只要有更新操作,依然会使版本号变化. 客户端第一次脸上注册中心,订阅时会获取全量的数据,后续则通过监听器时间进行更新.服务治理中心会处理所有service层的订阅,service被设置成特殊层.此外,服务治理中心除了订阅当前节点,还会订阅这个节点下的所有子节点. 缓存机制 Dubbo的注册中心实现了通用的缓存机制,在抽象类AbstractRegistry中实现.AbstractRegistry类结构关系如图: 消费者或服务治理中心获取注册信息后会做本地缓存.内存中会有一份,保存在Properties对象里,磁盘上也会持久化一份文件,通过file对象引用,在AbstractRegistry抽象类中有如下定义: 123private final Properties properties = new Properties();private File file;private final ConcurrentMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt; notified = new ConcurrentHashMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt;(); 内存中缓存notified是ConcurrentHashMap里面又嵌套了一个Map,外层Map的key是消费者的URL,内存Map的key是分类,包含providers,consumers,routes,configurators四种.value则是对应的服务列表,对于没有服务提供者提供服务的URL,它会以特殊的empty://前缀开头 缓存的加载 在服务初始化的时候,AbstractRegistry构造函数会从本地磁盘文件中把持久化的注册数据读到Properties对象里,并加载到内存缓存中 Properties保存了所有服务提供者的URL,使用URL#serviceKey()作为key,提供者列表,路由规则列表,配置规则列表等作为value.由于value是列表,当存在多个的时候使用空格隔开.还有一个特殊的key.registies,保存所有的注册中心地址.如果在应用启动过程中,注册中心无法连接或宕机,则Dubbo框架会自动通过本地缓存加载Invokers. 缓存的保存与更新 缓存的保存有同步和异步两种方式.异步会使用线程池异步保存,如果线程在执行过程中出现异常,则会再次调用线程池不断重试 12345if (syncSaveFile) &#123; doSaveProperties(version);&#125; else &#123; registryCacheExecutor.execute(new SaveProperties(version));&#125; AbstractRegistry#notify方法中封装了更新内存缓存和更新文件缓存的逻辑.当客户端第一次订阅获取全量数据,或者后续由于订阅得到新数据时,都会调用该方法进行保存. 重试机制 com.alibaba.Dubbo.registry.support.FailbackRegistry继承了AbstractRegistry,并在此基础上增加了失败重试机制作为抽象能力.zookeeperRegistry和RedisRegistry继承该抽象方法后直接使用即可. FailbackRegistry抽象类中定义了一个ScheduledExecutorService,每经过固定间隔,调用FailbackRegistry.retry()方法.另外,该抽象类中海油五个较为重要的集合: 集合名称 集合介绍 Set failedRegistered 发起注册失败的URL集合 Set failedUnregistered 取消注册失败的URL集合 ConcurrentMap&gt;failedSubscribed 发起订阅失败的监听器集合 ConcurrentMap&gt;failedUnsubscribed 取消订阅失败的监听器集合 ConcurrentMap&gt;&gt;failedNotified 通知失败的URL集合 在定时器中调用retry方法的时候,会把这五个集合分别遍历和重试,重试成功则从集合中移除.FailbackRegistry实现了subscribe,unsubscribe等通用方法,里面调用了未实现的模板方法,会由子类实现.通过方法会调用这些模板方法,如果捕获到异常,则会把URL添加到对应的重试集合中,以供定时器去重试 设计模式 Dubbo注册中心具有良好的扩展性,用户可以在其基础上快速开发出符合自己业务需求的注册中心. 这种扩展性与Dubbo中使用的设计模式密不可分. 模板模式 整个注册中心的逻辑部分使用了模板模式 AbstractRegistry实现了Registry接口中的注册,订阅,查询,通知等方法,还实现了磁盘文件持久化注册信息这一通用方法.但是注册,订阅,查询,通知等方法只是简单地把URL加入对应的集合,没有具体的注册或订阅逻辑. FailbackRegistry又继承了AbstractRegistry,重写了父类的注册,订阅,查询和通知等方法,并且添加了重试机制.此外,还添加了四个未实现的抽象模板方法. 以订阅为例,FailbackRegistry重写了subscribe方法,但只实现了订阅的大体逻辑及异常处理等通用性的东西.具体如何订阅,交给继承的子类实现.这就是模板模式的具体实现. 工厂模式 所有注册中心实现,都是通过对应的工厂创建的.工厂类之间的关系: AbstractRegistryFactory实现了RegistryFactory接口的getRegistry(URL url)方法,是一个通用实现,主要完成了加锁,以及调用抽象模板方法createRegistry(URL url)创建具体实现等操作,并缓存在内存中.抽象模板方法会由具体子类继承并实现. 虽然没种注册中心都有自己具体的工厂类,但是在什么地方判断,应该调用哪个工厂类实现,要在RegistryFactory接口中判断,该接口中有一个Registry getRegistry(URL url)方法,该方法上有@Adaptive({“protocol”})注解: 12345@SPI("Dubbo")publicinterface RegistryFactory&#123; @Adaptive(&#123;"protocol"&#125;) Registry getRegistry(URL url);&#125; 这个注解会自动生成代码实现一些逻辑,它的value参数会从URL中获取protocol键的值,并根据获取的值来调用不同的工厂类.如,当url.protocol = redis时,获得RedisRegistryFactor实现类.]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-1-总体大图]]></title>
    <url>%2Fdubbo-1%2F</url>
    <content type="text"><![CDATA[总体分层 总体分为业务层(Biz),RPC层,Remote层 进一步划分可以分成10层,左边的是具体的分层,右边是该层中比较重要的接口 Dubbo核心组件 层次名 作用 Service 业务层 包括业务代码的接口与实现,即开发者实现的业务代码 config 配置层 主要围绕ServiceConfig(暴露服务配置)和ReferenceConfig(引用服务配置)两个实现类展开,初始化配置信息可以理解为该层管理了整个Dubbo配置 proxy 服务代理层 在Dubbo中,无论生产者还是消费者,框架都会生成一个代理类,整个过程对上层是透明的.当调用一个远程交口时,看起来就像是调用了一个本地接口一样,代理层会自动做远程调用并返回结果,即让业务层对远程调用无感 cluster 集群容错层 该层主要负责:远程调用失败时的容错策略(如失败重试,快速失败);选择具体调用节点时的负载均衡策略(如随机,一致性Hash等);特殊调用路径的路由策略(如某个消费者只会调用某个特定的生产者) monitor 监控层 这一层主要负责监控统计调用次数和调用时间等 protocol 远程调用层 封装RPC调用具体过程,Protocol是Invoker暴露和引用的主功能入口,它负责管理Invoker的整个生命周期.Invoker是Dubbo的核心模型,框架中所有其他模型都向它靠拢,或者转换成它.允许它发起invoke调用,它可能是执行一个本地的接口实现,也可能是一个远程的实现,还可能一个集群实现 exchange 信息交换层 建立Request-Response模型,封装请求响应模式,如把同步请求转化为异步请求 transport 网络传输层 把网络传输抽象为统一接口,如Mina和Netty虽然接口不一样,但是Dubbo在它们上面又封装了统一接口.用户也可以根据其扩展接口添加更多的网络传输方式 Serialize 序列化层 负责管理整个框架网络传输时的序列化/反序列化工作 Dubbo总体调用过程 服务提供方 首先服务提供者在框架启动时,会初始化服务实例,通过Proxy组件调用具体协议(Protocol),把服务端要调用的接口封装成Invoker,然后转换成Exporter,这个时候框架会打开服务端口等并记录服务实例到内存中,最后通过Register把服务元数据注册到注册中心 Proxy Dubbo只需要引用一个接口就可以调用远程的服务,并且只需要像调用本地方法一样调用即可.其实Dubbo框架为我们生成了代理类,调用的方法其实是Proxy组件生成的代理方法,会自动发起调用返回结果. Protocol 协议是对数据格式的一种约定.它可以把我们对接口的配置根据不同的协议转换成不同的Invoker对象.如DubboProtocol可以把XML文件中一个远程接口的配置转换成一个DubboInvoker. Exporter 用于暴露到注册中心的对象,它的内部属性持有了Invoker对象,可以认为它是在Invoker上包了一层 Register 把Exporter注册到注册中心 服务调用方 消费放会在启动时会通过Registry在注册中心订阅服务端的元数据(包括IP和端口),这样就可以得到服务提供方暴露的服务了. 首先,调用过程也是从一个Proxy开始的,Proxy持有了一个Invoker对象,然后触发invoker调用.在invoker调用过程中,需要使用Cluster负责集群容错.Cluster在调用之前会通过Director获取所有可以调用的远程服务Invoker列表.由于可以调用的远程服务有很多,此时如果用户配置了路由规则(如制定某些方法调用某个特定节点),那么还会根据路由规则将Invoker列表过滤一遍. 然后,可选择的Invoker可能还会有很多,决定要调用哪一个的话要通过LoadBalance方法做负载均衡,最终选出一个拿来调用的Invoker.这个Invoker在调用之前优惠经过一个过滤器链,这个过滤器链通常是处理上下文,限流,计数等. 接着,会使用Client做数据传输,如我们常见的Netty Client等.传输之前肯定要做一些私有协议的构造,此时就会用到Codec接口.构造完成后,就会对数据包进行序列化,然后传输到服务提供者端.提供者接收到数据包,也会使用Codec处理协议头以及一些半包,粘包等.处理完成后再对完整的数据报文做反序列化处理. 随后,这个Request会被分配到ThreadPool中进行处理,Server会处理这些Request,根据请求查找对应的Expoter(它内部持有Invoker).Invoker是被装饰器模式一层一层套了非常多的Filter的,因此在调用最终的实现类之前,又会经过一个服务提供者的过滤连. 最终,我能得到了具体接口的真是实现并调用,再原路把结果返回.]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo笔记-0-概述]]></title>
    <url>%2Fdubbo-0%2F</url>
    <content type="text"><![CDATA[Dubbo思想 微内核 + 富插件 Dubbo特性 分类 特性 面向接口代理的高性能RPC调用 提供高性能的基于代理的远程调用能力,服务以接口为粒度,为开发者屏蔽远程调用的底层细节 服务与自动发现 支持多种注册中心服务,服务实例上下线实时感知 运行期流量调度 内置条件,脚本等路由策略,通过配置不同的路由规则,轻松实现灰度发布,同机房优先等功能 负载均衡 内置多种负载均衡策略,只能感知下游节点的健康状况,逐渐减少调用延迟,提高系统吞吐量 高度可扩展能力 微内核 + 富插件,所有核心能力(如Protocol,Transport,Serialization被设计为扩展点,平等对待内核实现和第三方实现) 可视化的服务治理与运维 提供丰富服务治理,运维工具,随时查询服务元数据,服务健康状态及调用统计,实时下发路由策略,调整配置参数 Dubbo解决什么问题 高性能,透明的RPC调用 Dubbo可以让开发者像调用本地的方法一样调用远程服务,而不需要显式在代码中指定是远程调用,整个过程对上层开发者透明,Dubbo会自动完成后续操作,如负载均衡,路由,协议切换,序列化等,开发者只需要接受对应的调用结果即可 服务的自动注册与发现 自动负载均衡与容错 Dubbo提供了完整的集群容错机制,可以实现软件层面的负载均衡,以此降低硬件的压力,Dubbo还提供了调用失败的各种容错机制,如Failover,Failefase,结果集合并等. 动态流量调整 在应用运行时,某些服务节点可能因为硬件原因需要减少负载,或者某些节点需要人工手动下线,又或者需要实现单元化的调用,灰度功能;Dubbo提供了管理控制台,用户可以在界面上动态地调整每个服务的权重,路由规则,禁用/启用,实现运行时的流量调度 依赖分析与调用统计 当应用规模进一步提升,服务间的依赖关系变得错综复杂,甚至分不清那个应用要在哪个应用之前启动,架构师都不能完整地描述应用的架构关系.服务的调用量越来越大,服务的容量问题就暴露出来,这个服务需要多少机器支撑?什么时候该加机器?Dubbo可以接入三方APM做分布式链路追踪与性能分析,或者使用已有的独立监控中心来监控接口的调用次数及好事,用户可以根据这些数据反推出系统容量]]></content>
      <categories>
        <category>Dubbo笔记</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方舟编译器]]></title>
    <url>%2FArkCompiler%2F</url>
    <content type="text"><![CDATA[方舟编译器大概是这个意思? 不是很清楚它编译的时机是什么…是app安装的时候? 2019年8月9日20:48:27补充,看了华为开发者大会,编译的时机是发布前]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里一面笔记]]></title>
    <url>%2Finterview-ali-1%2F</url>
    <content type="text"><![CDATA[没答上来的问题 01 Q: dubbo他内部的通信协议是什么? A: 不知道 事后: 太深了,以后慢慢来吧. 02 Q: 万一我们数据库操作成功了,但是返回给客户端的时候网络波动了,应该怎么办 A: 答的乱七八糟… 事后: 白井姐姐: 返回的时候,如果网络波动了,没有合法的关闭连接的话,服务端会察觉到,察觉到的话就回滚… wasup: 用PUT方法 03 Q: 依赖注入详细点是如何做的?bean互相依赖,应该怎么办? A: 不知道… 事后: 好像是什么,三重缓存? 04 Q: 成绩表,找出三门课以上不及格的同学,写出sql A: 子查询中先查出所有同学不及格科目的数量,子查询外面将超过三个的筛选出来. Q: 有没有不用子查询的方法? A: 答的乱七八糟… 事后: 用having字句… 05 Q: 联合查询 A: 懵逼 事后: 再看看联合索引吧… 06 Q: 项目使用的事务隔离级别? A: ReadCommitted Q: ReadCommitted有什么问题? A: 幻读 事后: 落了不可重复读… 07 Q: JDBC属于哪层网络协议? A: 不知道… 08 Q: 根据hash计算在桶中的位置的时候,为什么要前16位与后16做异或运算? A: 不做异或运算啊,他做与运算 事后: 我是傻逼,当时脑子蒙了 09 Q: concurrentHashMap取出来的东西一定是我们想要的吗? A: 不是,但是想不到这个场景了… 事后: 如果一个线程把某个键删了,另一个线程再取会出错. 10 Q: volatile一定是安全的吗? A: 不是,忘记这个场景了… A: 需要保证我们的操作的原子性. Q: 有什么场景? A: 比如有一个数,我们多个线程加它 Q: 如何保证原子性? A: 使用J.U.C.atomic.atomicInteger Q: 他内部是怎么实现原子性的呢? A: 不好意思我没了解到那么深入 事后: 应该大胆一点,答加锁的. 回去又翻了一下深入理解jvm,讲到了我们一个int的加法,虽然代码是看只有一行,即使编译出来只有一条字节码指令,这条指令在解释器里面也可能需要转换成若干条本地机器指令,所以不能保证原子性,要加锁. 11 Q: 有什么问题要问我的? A: 巴拉巴拉… 事后: 应该把上面不会的问题再挨个问一遍? emm 自己还是理论上的知识比较看重…问的项目里的**怎么**的都有点力不从心. emmm 2019年8月10日19:58:52 挂了 很多东西,感觉都是因为是刚学的,还没有完全融入自己的思想,还需要更多的沉淀. 应对面试时,不会的问题一定要好好思考. 比如,这次阿里面的场景题:如果返回数据的时候网络波动了怎么办,和问AtomicInteger内部原理的时候 自以为会的问题也不要张口就来,做好容错. 比如,这次问&quot;bean是不是new出来的&quot;,当时回的&quot;是&quot;,虽然后来又补了句&quot;不他是由processor初始化才&quot;,但没说到点子上(指反射),这种时候应该先答&quot;我想一下&quot;,不能被问题牵着鼻子走 1@RequestHeader(value="token") String token 1234Long operatorId = redisTool.getUserIdByToken(token);if(operatorId.equals(-1L))&#123; return ErrorEnum.VERIFY_FAILED.getResult();&#125;]]></content>
      <tags>
        <tag>面试</tag>
        <tag>阿里巴巴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五种IO模型]]></title>
    <url>%2Fio-model%2F</url>
    <content type="text"><![CDATA[IO分为两步: 等待数据准备好 数据搬迁 五种IO模型包括: 阻塞IO, 非阻塞IO, 信号驱动IO, IO多路转接, 异步IO 阻塞式IO blocking I/O 在内核将数据准备好之前一直阻塞 非阻塞IO noblocking I/O 调用程序发起系统调用之后不断轮询询问内核数据有没有准备好. 没有准备好时不会阻塞程序 信号驱动IO signal blocking I/O 当数据报准备好时,内核会给调用程序发送一个信号 在等待信号期间调用程序不会阻塞 IO多路转接 I/O multiplexing 类似于非阻塞型I/O,只不过轮询不是用户线程去执行,而是内核去轮询.内核监听程序监听到数据准备好后,调用内核函数复制数据到用户态. 异步IO asynchronous I/O 异步IO依赖信号处理程序来进行通知. 不过前面都是数据准备阶段的阻塞和非阻塞,异步IO模型通知的是IO操作已完成,而不是数据准备完成. 异步IO才是真正的非阻塞,主进程只负责做自己的事情,等IO操作完成.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java与线程]]></title>
    <url>%2Fjava-and-thread%2F</url>
    <content type="text"><![CDATA[线程的实现 使用内核线程实现 内核线程(Kernel-Level Thread, KLT) 就是直接由 操作系统内核(Kernel) 支持的线程,这种线程由内核来完成线程切换,内核通过操纵调度器(Scheduler)对线程进行调度,并负责将线程的任务映射到各个处理器上. 每个内核可以视为内核的一个分身,这样操作系统就有能力同时处理多件事情,支持多线程的内核就叫做多线程内核(Multi-Threads Kernel). 程序一般不会直接去使用内核线程,而是去使用内核线程的一种高级接口, 轻量级进程(Light Weight Process, LWP) 轻量级进程就是我们通常意义上所讲的线程. 由于每个轻量级进程都由一个内核线程支持,因此只有先支持内核线程,才能有轻量级进程. 这种轻量级线程与内核线程之间1:1的关系被称为一对一的线程模型. 由于内核线程的支持,每个轻量级进程都成为一个独立的调度单元,即使有一个轻量级进程在系统调用中阻塞了,也不会影响到整个进程的工作. 由于基于内核线程实现,所以各种线程操作,如创建,析构以及同步,都需要进行系统调用,而系统调用的代价是相对较高的,需要在 用户态(User Mode) 和 内核态(Kernel Mode) 中来回切换. 其次,每个轻量级进程都需要有一个内核线程的支持,因此轻量级进程要消耗一定的内核资源,因此一个系统支持轻量级进程的数量是有限的. 使用用户线程 从广义上讲,一个线程只要不是内核线程,就可以认为是 用户线程(User Thread) . 而从狭义上讲,用户线程指的是完全建立在用户空间的线程库上,系统内核不能感知到线程存在. 用户线程的建立,同步,销毁和调度完全在用户态中完成,不需要内核的帮助.如果程序实现得当,这种线程不需要切换到内核态,因此操作可以是非常快速且低消耗的,也可以支持规模更大的线程数量.部分高性能数据库中的多线程就是由用户线程实现的.这种进程与用户线程之间1:N的关系成为一对多的线程模型. 使用用户线程的优势在于不需要系统内核支援,劣势也在于没有系统内核的支援,所有的线程操作都需要用户程序自己去处理.线程的创建,切换和调度都是需要考虑的问题,而且由于操作系统制霸处理器资源分配到进程,那诸如阻塞如何处理,多处理器系统之如何将线程映射到其他处理器上这类问题解决起来异常困难,甚至不可能完成.除了以前在不支持多线程的操作系统中(如DOS)的多线程程序与少数有特殊需求的程序外,现在使用用户线程的程序越来越少了,Java,Ruby等语言都曾经使用过用户线程,最终又都放弃使用它. 使用用户线程加轻量级进程混合实现 在这种混合实现下,既存在用户线程,也存在轻量级进程.用户线程还是完全建立在用户空间中,因此用户线程的创建,切换,析构等操作依然廉价,并且可以支持大规模的用户线程并发.而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁,这样可以使用内核提供的线程调度功能及处理器映射,并且用户线程的系统调用要通过轻量级线程来完成,大大降低了整个进程被完全阻塞的风险. 在这种混合模式下,用户线程与轻量级进程的数量比是不定的,即为N:M的关系 Java线程的实现 对于Sun JDK来说,它的Windows版与Linux版都是使用一对一的线程模型实现的,一条Java线程就映射到一条轻量级进程之中,因为Windows和Linux系统提供的线程模型是一对一的. Java线程调度 线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是 协同式线程调度(Cooperative Threads-Sheduling) 和 抢占式线程调度(Preemptive Threads-Sheduling) 如果使用协同式调度的多线程系统,线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上. 协同式多线程的最大好处是是实现简单,而且由于线程要把自己的事情干完后才会进行线程切换,切换操作对线程自己是可知的,所以没有什么线程同步的问题. 它的最大坏处也很明显:线程执行时间不可控制,甚至如果出现一个线程编写有问题,一直不告知系统进行线程切换,那么程序就会一直阻塞在那里. 如果使用抢占式的多线程系统,那么每个线程将有系统来分配执行时间,线程的切换不由线程本身来决定(在Java中,Thread.yield()可以让出执行时间,但是要获取执行时间的话,线程本身是没什么办法的).在这种实现线程调度的方式下,线程的执行时间是系统可控的,也不会有一个线程导致整个进程阻塞的问题,Java使用的线程调度方式就是抢占式调度. 线程状态 新建(New) 创建后尚未启动的线程处于这种状态 运行(Runable) Runable包括了操作系统线程转台中的Running和Ready,也就是处于此转台的线程有可能正在执行,也有可能正在等着CPU给它分配时间 无限期等待(Waiting) 处于这种转态的线程不会被分配CPU时间,它们要等待被其他线程显式地唤醒.以下方法会让线程进入无限期等待状态: 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待(Timed Waiting) 处于这种转态的线程不会被分配CPU执行时间,不过无须等待被其他线程显式地唤醒,在一定时间之后它们由系统自动唤醒.以下方法会让线程进入限期等待状态: Thread.sleep()方法 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Thread.join()方法 LockSupport.parkNanos()方法 LockSupport.parkUntil()方法 阻塞(Blocked) 线程被阻塞了,&quot;阻塞转态&quot;与&quot;等待状态&quot;的区别是:阻塞状态在等待着获取到一个排他锁,这个时间将在另外一个线程放弃这个锁的时候发生;而等待状态则是在等待与短时间,或者唤醒动作的发生.在线程等待进入同步区域的时候,线程将进入这种状态 结束(Terminated) 已终止线程的线程状态,线程已经结束执行 线程安全 当多个线程访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步,或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果,那么这个对象是线程安全的. 这个定义比较严谨,它要求线程安全的代码都具备一个特征:代码本身封装了所有必要的保障手段(如同步互斥等),令调用者无需关心多线程的问题,更无须自己采取任何措施来保证多线程的正确调用. 在大多数场景中,我们都会将这个定义弱化一些,如果把&quot;调用这个对象的行为&quot;限定为&quot;单次调用&quot;,这个定义的其他描述也能够成立的话,我们就称它是线程安全的了. Java中的线程安全 按照线程安全的&quot;安全程度&quot;由强至弱来排序,我们可以将Java语言中的各种操作共享的数据分为以下五类:不可变,绝对线程安全,相对线程安全,线程兼容和线程对立 不可变 不可变(Immutable) 对象一定是线程安全的,无论是对象的方法实现还是方法的调用者,都不需要再采取任何的线程安全保障措施,只要一个不可变的对象被正确地构建出来(没有发生this引用逃逸的情况),那其外部的可见状态永远也不会改变,永远也不会看到它在多个线程之中处于不一样的状态.&quot;不可变&quot;带来的安全性是最简单最纯粹的. Java语言中,如果共享数据是一个基本数据类型,那么只要在定义时使用final关键字修饰它就可以保证它是不可变的.如果共享数据是一个对象,那就要保证对象的行为不会对其状态产生任何影响才行.如java.lang.String的对象,它是一个典型的不可变对象,我们调用它的substring(),replace和concat()这些方法都不会影响它原来的值,只会返回一个新构造的字符串对象. 保证对象行为不影响自己状态的途径有很多种,其中最简单的就是把对象中带有状态的变量都声明为final,这样在构造函数结束之后,它就是不可变的. 绝对线程安全 绝对的线程安全满足上面严格的线程安全的定义,一个类要达到&quot;不管运行时环境如何,调用者都不需要任何额外的同步措施&quot;通常需要付出很大的,甚至有时候是不切实际的代价.在Java API中标注自己是线程安全的类,大多数都不是绝对的线程安全. 相对线程安全 相对的线程安全就是我们通常所讲的线程安全,它需要保证对这个对象单独操作是线程安全的,我们在调用的时候不需要额外的保障措施,但是对于一些特定顺序的连续调用,就可能需要在调用端使用额外的同步手段来保证调用的正确性. 在Java中,大部分的线程安全类都属于这种类型,如Vector,HashTable,Collection的synchronizeCollection()方法包装的集合等. 线程兼容 线程兼容是指对象本身并不是线程安全的,但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用.我们平常说一个类不是线程安全的,绝大多数时候指的都是这一种情况. Java API中大部分的类都是属于线程兼容的. 线程对立 线程对立是指无论调用端是否采取了同步措施,都无法在多线程环境中并发使用的代码. 线程对立很少出现. 线程安全的实现方法 互斥同步 互斥同步(Mutual Exclusion &amp; Synchronization) 同步是指在多个线程并发访问共享数据时,保证共享数据在同一个时刻只被一个(或者是一些,使用信号量的时候)线程使用. 而互斥是实现同步的一种手段,临界区(Critical Section) , 互斥量(Mutex) 和 信号量(Semaphore) 都是主要的互斥实现方式. 互斥是因,同步是果;互斥是方法,同步是目的. Synchronized 在Java中,最常用的互斥同步手段就是synchronized关键字. synchronized关键字经过变异之后,会在同步块前后分别行程 monitorenter 和 monitorexit这两个字节码指令 这两个字节码指令都需要一个reference类型的参数来指明要锁定的对象. 如果Java程序中的synchronized明确指定了对象,那就是这个对象的reference 如果没有明确指定,那就根据synchronized修饰的是实例方法还是类方法,去取对应的对应的对象实例或Class对象作为锁对象. 在执行monitorenter指令时,首先会尝试获取对象的锁,如果这个对象没被锁定,或者当前进程已经拥有了那个对象的锁,把锁的计数器加1 在执行monitorexit指令时会将锁计数器减1,当计数器为0时,锁就被释放. 如果获取对象锁失败,那当前线程就要阻塞等待,知道对象锁被另外一个线程释放为止. 虚拟机规范在堆monitorenter和monitorexit的行为描述中,有两点是需要注意的: synchronized同步块对同一条线程来说是可重入的,不会出现自己把自己锁死的情况. 同步块在已进入线程执行完之前,会阻塞后面其他线程的进入.因Java的线程是映射到轻量级进程中的,如果需要阻塞或唤醒一个线程,都需要操作系统来帮忙完成,这就需要从用户态转换到核心态,因此状态需要消耗很多的处理器时间.所以synchronized是Java语言中一个重量级(Heavyweight)的操作.而虚拟机本身会进行优化,比如在通知操作系统阻塞进程之前加入一段自旋等待过程,避免频繁在用户态与内核态之间切换. JUC 也可以通过JUC包中的 重入锁(ReentrantLock) 来实现同步.ReentrantLock与synchronized很相似,他们都具备一样的线程重入特性,只是代码写法上有点区别,一个表现为API层面的互斥锁,另一个表现为远胜于法层面的互斥锁. ReentrantLock相比synchronized增加了一些高级功能,主要为以下三种: 等待可中断 当持有锁的线程长期不释放锁的时候,正在等待的线程可以选择放弃等待,改为处理其他事情,可中断特性对处理执行时间非常长的同步块很有帮助. 公平锁 公平锁是指多个线程在等待同一个锁的时候,必须按照申请锁的时间顺序来依次获得锁.而非公平锁在释放时,任何一个等待锁的线程都有机会获得锁. 锁绑定多个条件 一个ReentrantLock可以同时绑定多个Condition对象,而在synchronized中,锁对象的wait(),notify()或notifyAll()方法可以实现一个隐含的条件,如果要和多于一个的条件关联的时候,就不得不额外添加一个锁,而ReentrantLock则无需这样做,只需要多次调用newCondition()方法即可. 互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题.因此这种同步也成为阻塞同步(Blocking Synchronize).从处理问题的方式上说,互斥同步属于一种悲观的并发策略,总是认为只要不去加锁就肯定会出问题,无论共享数据是否真的会出现竞争,它都要进行加锁,用户态与核心态转换,维护锁计数器合集检查是否有阻塞的线程需要唤醒等操作. 非阻塞同步 非阻塞同步(Non-Blocking Synchronize) 是基于冲突检测的乐观并发策略,通俗地讲,就是先进行操作,如果没有其他线程征用共享数据,那操作就成功了,如果共享数据有征用,产生了冲突,那就再采取其他的补偿措施(最常见的补偿措施是不断重试,直至成功).这种乐观的策略不需要将线程挂起. 无同步方案 要保证线程安全,并不是一定就要进行同步.同步只是保证共享数据争用时的正确性手段,如果一个方法本来就不涉及共享数据,那么它自然就无须任何同步措施去保证正确性,因此会有一些代码天生就是线程安全的. 可重入代码 可重入代码(Reentrant Code) 这种代码也叫作纯代码(Pure Code) ,可以在代码执行的任何时刻中断它,转而去执行另外一段代码,而在控制权返回后,原来的程序不会出现任何错误.相对线程安全来说,可重入性是更基本的特性,它可以保证线程安全. 可重入代码有一些共同的特征,例如不依赖存储在堆上的数据和公用的系统资源,用到的状态都由参数传入,不调用非可重入的方法等. 我们可以通过一个简单的原则来判断代码是否具有可重入性:如果一个方法它的返回结果是可以预测的,只要输入了相同的数据,就都能返回相同的结果,那它就满足可重入性. 线程本地存储 线程本地存储(Thread Local Storage) 指的是,如果一段代码中所需要的数据必须与其他代码共享,那就看看这些共享数据的代码是否能保证在同一个线程中执行,如果能保证,我们就可以把共享数据的可见范围限制在同一个线程之内,这样,无须同步也能保证线程之间不出现数据争用的问题. ThreadLocal Java中的java.lang.ThreadLocal类就是来实现线程本地存储的. 锁优化 自旋锁与自适应自旋锁 互斥同步对性能最大的影响就是阻塞的实现,挂起线程和回复线程的操作都需要转入内核态中完成,这些操作给系统的并发性能带来了很大的压力.同时,共享数据的锁定状态只会持续很短的一段时间,为了这段时间去挂起和回复线程并不值得. 如果物理机器上有一个以上的处理器,能让两个或以上的线程同时并行执行,我们就可以让后面请求锁的线程稍等一下但不放弃处理器的执行时间(即以一些CPU资源为代价,换来的是省去了内核态与用户态的切换),看看持有锁的线程是否很快就会释放锁.为了让线程等待,我们只需让线程执行一个忙循环(自旋),这项技术就是自旋锁. 自旋等待本身虽然避免了线程切换的开销,但它是要占用处理器时间的,因此,如果锁被占用的时间很短,自旋等待的效果就会非常好,反之,如果锁被占用的时间很长,那么自旋的线程只会白白消耗处理器资源,而不会做任何有用的工作,反而会带来性能上的浪费. 因此,自旋等待的时间必须要有一定的限度,如果自旋超过了限定的次数仍然没有成功获得锁,就应当使用传统的阻塞式的方式去挂起线程了. 自适应的自旋锁意味着自旋的时间不再固定了,而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定. 如果在同一个锁对象上,自旋等待刚刚成功获得过锁,并且持有锁的线程正在运行中,那么虚拟机就会认为这次自旋也很有可能再次成功,进而它将允许自旋等待持续相对更长的时间. 锁清除 锁清除是指虚拟机即时编译在运行时,对一些代码上要求同步,但是被检测到不可能存在共享数据竞争的锁进行消除.锁清除的主要判断依据来源于逃逸分析的数据支持,如果判断在一段代码中,堆上的所有数据都不会逃逸出去从而被其他线程访问到,那就把他们当做线上数据对待,认为它们是线程私有的,同步加锁自然就无须进行. 锁粗化 如果一系列的连续操作都对同一个对线反复加锁和解锁,那即使没有线程竞争,频繁地进行互斥同步操作也会导致不必要的性能损耗. 例如: 1234567public String concatString(String s1, String s1, String s3)&#123; StringBuilder sb = new StringBuilder(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString():&#125; 如果JVM探测到这样的一连串对同一个对象(sb)加锁的操作,将会把加锁同步的范围扩展(粗化)到整个操作序列的外部. 轻量级锁 操作系统互斥量来实现的传统锁被称为重量级锁,而轻量级锁是相对于重量级锁来讲的. 轻量级锁并不是用来代替重量级锁的,它的本意是在没有多线程竞争的前提下,减少传统的重量级锁使用操作系统互斥量产生的性能消耗. 对象头中有2bit用来存储锁标志位, 偏向锁]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>深入理解JVM</tag>
        <tag>jvm</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2Falgorithm-sort%2F</url>
    <content type="text"><![CDATA[复习一下排序算法 概览 排序算法 时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n2) O(n) O(n2) O(1) in-place 稳定 选择排序 O(n2) O(n2) O(n2) O(1) in-place 不稳定 插入排序 O(n2) O(n) O(n2) O(1) in-place 稳定 希尔排序 O(nlogn) O(nlongn) O(nlogn) O(1) in-place 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) out-place 稳定 快速排序 O(nlogn) O(nlogn) O(n2) O(logn) in-place 不稳定 堆排序 O(n logn) O(n logn) O(n logn) O(1) in-place 不稳定 计数排序 O(n + k) O(n + k) O(n + k) O(k) out-place 稳定 桶排序 O(n + k) O(n + k) O(n2) O(n + k) out-place 稳定 基数排序 O(n * k) O(n * k) O(n * k) O(n + k) out-place 稳定 冒泡排序 冒泡排序对数组进行两层遍历,每一步比较相邻的两项,如果这两项排序错了则对其进行交换 代码 1234567891011121314// 冒泡排序public static void bubble(int[] arr) &#123; int temp; int len = arr.length; for (int i = len - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 评价 冒泡排序通常被认为是最低效的排序方法 但是冒泡排序如果在某次遍历中发现没有交换值,就可以提前结束 优化代码 1234567891011121314151617181920// 优化的冒泡排序public static void bubbleEnhance(int[] arr) &#123; int temp; int len = arr.length; boolean changed; for (int i = len - 1; i &gt;= 0; i--) &#123; changed = false; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; changed = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if(!changed)&#123; break; &#125; &#125;&#125; 选择排序 选择排序对数组进行两层遍历,每次遍历找到最小的项,遍历完成后再把最小的项放到正确的位置 代码实现 12345678910111213141516// 选择排序public static void selection(int[] arr)&#123; int temp,currentMinIndex; int len = arr.length; for(int i = 0; i &lt; len - 1; i++)&#123; currentMinIndex = i; for(int j = i + 1; j &lt; len; j++)&#123; if(arr[currentMinIndex] &gt; arr[j])&#123; currentMinIndex = j; &#125; &#125; temp = arr[currentMinIndex]; arr[currentMinIndex] = arr[i]; arr[i] = temp; &#125;&#125; 插入排序 插入排序总是保持一个位置靠前的以排好的子表,然后每一个新数据项被插入到前边的子表里 代码实现 123456789101112131415// 插入排序public static void insertion(int[] arr) &#123; int currentValue, position; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; currentValue = arr[i]; position = i; while (position &gt; 0 &amp;&amp; currentValue &lt; arr[position - 1]) &#123; arr[position] = arr[position - 1]; position -= 1; &#125; arr[position] = currentValue; &#125;&#125; 希尔排序 希尔排序又叫&quot;缩小间隔排序&quot;,它以插入排序为基础,将原来要排序的列表划分为一些字列表,再对每一个子列表执行插入排序 划分子列表的方法是希尔排序的关键.我们并不是将原始列表分成含有连续元素的子列,而是确定一个特别的分量&quot;i&quot;,这个i更准确地说是划分的间隔.然后把每间隔为i的所有元素选出来组成子列表,然后对每个子序列进行插入排序,最后当i=1时,对整体进行一次插入排序 代码实现 12345678910111213141516171819202122# 希尔排序def shellSort(alist): n = len(alist) gap = n // 2 while gap &gt; 0: for i in range(gap): gapInsetionSort(alist, i, gap) gap = gap // 2 return alist# # start子数列开始的起始位置， gap表示间隔def gapInsetionSort(alist,startpos,gap): #希尔排序的辅助函数 for i in range(startpos+gap,len(alist),gap): position=i currentvalue=alist[i] while position&gt;startpos and alist[position-gap]&gt;currentvalue: alist[position]=alist[position-gap] position=position-gap alist[position]=currentvalue 归并排序 归并排序是一种递归算法,它持续地将一个列表分成两半进行排序. 快速排序 通过一趟排序将要排序的数据分成独立的两部分,其中一部分的数据比另外一部分的所有数据都要小,然后按此方法对这两部分数据分别进行快速排序. 12345678910111213141516171819202122232425262728293031323334353637public void quickSort(int[] arr, int start, int end)&#123; if(end &lt;= start)&#123; return; &#125; int p = partition(arr, start, end); quickSort(arr,start,p - 1); quickSort(arr,p + 1,end);&#125;public int partition(int[] arr, int start, int end) &#123; System.out.println("============↓↓↓开始执行↓↓↓============="); System.out.println("本次执行数组: " + Arrays.toString(Arrays.copyOfRange(arr,start,end))); float pos = r.nextFloat(); int posInt = (int) (pos * (end - start) + start); int tmp = arr[posInt]; System.out.println("本次选定基准: arr[" + (posInt - start) + "] = " + tmp); arr[posInt] = arr[start]; arr[start] = tmp; int pivot = arr[start]; int j = start; int i = start + 1; while (i &lt; end) &#123; if (arr[i] &lt;= pivot) &#123; tmp = arr[j + 1]; arr[j + 1] = arr[i]; arr[i] = tmp; j += 1; &#125; i += 1; &#125; tmp = arr[j]; arr[j] = arr[start]; arr[start] = tmp; System.out.println("本次执行完事后数组: " + Arrays.toString(Arrays.copyOfRange(arr,start,end))); return j;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库中的各种锁]]></title>
    <url>%2Fdatabase-lock%2F</url>
    <content type="text"><![CDATA[概述 分类方法 锁 锁模式 乐观锁, 悲观锁 范围锁 行锁, 表锁 算法锁 临间锁, 间隙锁, 记录锁 属性锁 共享锁, 排他锁 状态锁 意向共享锁, 意向排他锁 行锁 一锁锁一行或多条记录,mysql的行锁是基于索引加载的,所以行锁是要加在索引响应的行上,即命中索引 锁冲突概率低,并发性高,但是会有死锁的情况出现 表锁 一锁锁一张表,表锁响应的是非索引字段,即全表扫描 记录锁 记录锁是在行锁上衍生出来的锁 记录锁锁的是表中的某一条记录,记录锁的出现条件是必须是精准命中索引并且索引是唯一索引,如主键id. 间隙锁 间隙锁又称为区间锁,每次锁定都是锁定一个区间,隶属行锁 既然间隙锁隶属行锁,那么间隙锁的触发条件必然是命中索引的 当我们使用范围查询而不是相等条件查询时,查询条件命中索引]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务隔离和Spring事务传播特性]]></title>
    <url>%2Ftransaction-isolation%2F</url>
    <content type="text"><![CDATA[事务隔离 事务的四大特性 原子性 一致性 隔离性 持久性 四种事务隔离级别 Read Uncommitted 读取未提交内容 会出现脏读 Read Committed 读取提交内容 Nonrepeatable Read 不可重复读 Read Committed满足了隔离的定义: 一个事务只能看到其他事务已提交的操作 因为两次读取数据库某条数据时,数据可能会不一致(两次读取之间,该数据被其他事务改动),所以也被称为Nonrepeatable Read (这个是mysql默认的事务隔离级别) Repeatable Read 可重读 确保同一事务获取到的数据是一致的 不过会导致另一个问题: 幻读 Serializable 可串行化 最高级别的事务隔离,通过强制事务排序使之不可能相互冲突,从而解决幻读问题.简而言之,它是在每个读的数据上加上共享锁.在这个级别可能导致大量的超时现象和锁竞争 总结 隔离级别 脏读 不可重复读 幻读 Read Uncommitted √ √ √ Read Committed x √ √ Repeatable Read x x √ Serializable x x x Spring事务传播特性 required Propagation.REQUIRED 方法被调用是自动开启事务,在事务范围内则使用同一事务,否则开启新事务 requires_new Propagation.REQUIRES_NEW 无论如何自身都会开启新事务 supports Propagation.SUPPORTS 自身不会开启事务,在事务范围内则使用相同事务，否则不使用事务. not_supported Propagation.NOT_SUPPORTED 自身不会开启事务,在事务范围内使用挂起事务,运行完毕恢复事务. mandatory Propagation.MANDATORY 自身不开启事务,必须在事务环境中否则报错. never Propagation.NEVER 自身不会开启事务,在事务范围内使用抛出异常. nested Propagation.NESTED 如果一个活动的事务存在,则运行在一个嵌套的事务中.如果没有活动事务,按照required执行. 名词解释 脏读 Dirty Read 读取其他事务未提交的执行结果 幻读 Phantom Read 幻读是指用户在读取某一行数据时,另一个事务又在该范围内插入了新行,当用户再次读取该范围数据行时,会出现新的&quot;幻影行&quot;]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法笔记]]></title>
    <url>%2Fnote-algorithm%2F</url>
    <content type="text"><![CDATA[数据结构 编程能力 算法 排序算法 搜索算法 图论 动态规划 基础技巧 分治 倍增 二分 贪心 t160:相交链表 滑动窗口]]></content>
  </entry>
  <entry>
    <title><![CDATA[一次反射的应用]]></title>
    <url>%2Fonce-reflect%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;public class JdbcGetAll &#123; // 传入表名和类名和Connection对象,会将给定表中的每条数据转换成给定的类的实例. // 要求,表的字段的字段名和数据类型要和类的字段名和类型一一对应 public List getAll(String tableName, String className, Connection conn) &#123; // 从给定的类名获得类传至该变量 Class thisClass; // 类的字段的数组 Field[] thisFields; // 类的字段的Map,方便根据字段名获取到Field对象 HashMap&lt;String, Field&gt; thisFieldsMap = new HashMap&lt;&gt;(); // 类的构造器 Constructor thisConstructor = null; // 表的字段名的集合 var COLUMN_NAMEs = new ArrayList&lt;String&gt;(); // 用于盛放生成的对象的数组,最终返回该对象 var thisInstances = new ArrayList(); try &#123; thisClass = Class.forName(className); thisConstructor = thisClass.getConstructor(); thisFields = thisClass.getFields(); for (var field : thisFields) &#123; thisFieldsMap.put(field.getName(), field); &#125; &#125; catch (ClassNotFoundException e) &#123; System.out.println("No class called '" + className + "'"); return null; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; // 获取到表的字段的sql语句 var sql = "select COLUMN_NAME from information_schema.COLUMNS where table_name = '" + tableName + "'"; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; pstmt = conn.prepareStatement(sql); rs = pstmt.executeQuery(); while (rs.next()) &#123; var COLUMN_NAME = rs.getString("COLUMN_NAME"); COLUMN_NAMEs.add(COLUMN_NAME); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; // 获取表的数据 sql = "select * from " + tableName; try &#123; pstmt = conn.prepareStatement(sql); rs = pstmt.executeQuery(); // 遍历所有记录,为每条记录生成一个类实例 while (rs.next()) &#123; try &#123; // 从类的构造器创建新的实例 var thisInstance = thisConstructor.newInstance(); // 遍历所有表的字段 for (var COLUMN_NAME : COLUMN_NAMEs) &#123; // 获取到表的字段名对应的对象字段 var field = thisFieldsMap.get(COLUMN_NAME); // 获取到该条记录该条字段的值 var o = rs.getObject(COLUMN_NAME); // 为对象的字段设置值 field.set(thisInstance, o); &#125; thisInstances.add(thisInstance); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUitl.close(pstmt, conn); &#125; return thisInstances; &#125; public static void main(String[] args) &#123; Connection conn = JdbcUitl.getConnection("address", 3306, "dbName", "root", "password"); var jdbcGetAll = new JdbcGetAll(); List res = jdbcGetAll.getAll("teacher", "Teacher", conn); System.out.println("结果集中共含有" + res.size() + "个元素: &#123;"); for (var re : res) &#123; System.out.println(" " + re); &#125; System.out.println("&#125;"); &#125;&#125; JdbcUtil类的代码 123456789101112131415161718192021222324252627282930import java.sql.*;public class JdbcUitl &#123; public static Connection getConnection(String address,int port,String dbName,String userName,String passWord)&#123; Connection conn = null; try &#123; conn = DriverManager.getConnection("jdbc:mysql://" + address + ":" + port + "/" + dbName,userName,passWord); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static void close(PreparedStatement pstmt,Connection conn)&#123; if(pstmt!=null)&#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解JVM》笔记-2-垃圾收集器与内存分配策略]]></title>
    <url>%2Fjvm-understanding-gc%2F</url>
    <content type="text"><![CDATA[对象已死吗 引用计数法 引用计数算法(Reference Counting) 给对象添加一个引用计数器,每当有一个地方引用它时,计数器值就加1;当引用失效时,计数器值减1;任何时刻计数器值为0的对象不可能再被使用. 引用计数法实现很简单,判定效率也很高.但是至少主流的Java虚拟机没有选用引用计数法管理内存的. 其主要原因是它很难解决对象之间相互引用的问题. 可达性分析算法 主流商用语言(如Java,C#)的主流实现中,都是通过可达性分析算法(Reachability Analysis) 来判定对象是否存活的. 这个算法的基本思路是通过一系列成为&quot;GC Root&quot;的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain) ,当一个对象到GC Roots没有任何引用链相连时,则证明此对象是不可用的. 如图,对象object5,object6,object7虽然相互有关联,但是它们到GC Roots是不可达的,所以它们将会被判定是可回收对象. 可作为GC Roots的对象 虚拟机栈(帧栈中的本地变量表)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(即一般说的Native方法)引用的对象 再谈引用 无论是引用计数还是可达性分析算法,判断对象是否存活都与&quot;引用&quot;有关. Java的引用分为4种,这四种引用强度依次逐渐减弱: 强引用(Strong Reference) 软引用(Soft Reference) 弱引用(Weak Reference) 虚引用(Phantom Reference) 强引用 强引用就是指在代码中普遍存在的,类似Object obj = new Object();这类的引用. 只要强引用还在,垃圾收集器永远不会回收掉被引用的对象. 软引用 软引用用来描述一些还有用但并非必需的对象. 对于软引用关联着的对象,在系统将要发生内存溢出异常之前,将会把这些对象列进回收范围之中进行二次回收.如果这次回收还没有足够的内存,才会抛出内存溢出异常. 软引用通过SoftReference类实现. 弱引用 弱引用也是用来描述非必需的对象的. 它的强度比软引用还要更弱一些. 只被弱引用关联的对象只能生存到下一次垃圾收集发生之前.当垃圾收集器工作时,无论当前内存是否足够,都会回收掉只被弱引用关联的对象. 弱引用通过WeakReference类实现. 虚引用 虚引用也称为幻影引用或者幽灵引用,它是最弱的一种引用关系. 一个对象是否被虚引用关联完全不会对它的生存构成影响,也无法通过一个虚引用来取得一个对象实例. 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知. 虚引用通过PhantomReference实现. 生存还是死亡 此部分作废,finalize()方法已过时 即使在可达性分析算法中不可达的对象,也并非是&quot;非死不可&quot;的. 要真正宣告一个对象的死亡要经历以下过程: 对上图的解释: 是否有必要执行finalize()方法: 当对象没有覆盖finalize()方法或finalize()方法已经被虚拟机调用过,虚拟机将会视为&quot;没有必要执行finalize()方法&quot;. 执行finalize(): finalize()方法由一个有虚拟机自动建立的,低优先级的Finalizer线程去执行. 这里所谓的&quot;执行&quot;,是指虚拟机会触发这个方法,但不承诺会等待它运行结束.这么做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环,这时如果等待它运行结束,将很可能会导致F-Queue中其他对象处于永久等待,甚至导致整个内存回收系统崩溃. 若在执行对象的finalize()方法中,将对象自身与引用链上任何一个对象建立关联,则可以在第二次标记中判断为可达,从而避开被回收. 执行过一次finalize()方法的对象在面临下一次垃圾回收时,虚拟机将不会再次执行finalize()方法,而是直接将其回收. 回收方法区 很多人认为方法区(或HotSpot中的永久代)没有垃圾收集,Java虚拟机规范中说过可以不要求方法区实现垃圾收集,而且在方法区中进行垃圾收集的性价比一般比较低:在堆中,尤其是在新生代中,常规应用进行一次垃圾收集一般可以回收70%~95%的空间,而永久代的垃圾收集效率远低于此. 永久代的垃圾回收主要回收两部分:废弃常量和无用的类 废弃常量 回收废弃常量与回收堆中的对象非常类似. 以常量池中字面量的回收为例,假如一个字符串&quot;abc&quot;已经进入了常量池了,但是当前系统中没有任何一个String对象叫做&quot;abc&quot;,如果这时进行垃圾回收,这个&quot;abc&quot;常量将会被系统清理出常量池. 常量池中的其他类(接口),方法,字段的符号引用也与此类似. 无用的类 同时满足以下3个条件,才能是无用的类: 该类的所有实例均已被回收,即Java堆中不存在该类的任何实例. 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法. 虚拟机可以对满足上述3个条件的无用类进行回收,但不是像对象一样必须进行回收.HotSpot虚拟机提供了参数进行控制. 垃圾收集算法 标记-清除算法 标记-清除算法(Mark-Sweep) 最基础的收集算法. 算法分为两个阶段.首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象.它的标记过程就是上面的对象标记判定. 之所以说它是最基础的收集算法,是因为后续的收集算法都基于这个思路并对其不足进行改进而得到的.它的不足有两个: 效率问题 标记和清除两个过程效率都不高 空间问题 标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时,无法找到足够的连续内存,而不得不再进行一次垃圾收集动作. 复制算法 复制算法是为了解决效率问题被提出来的. 复制算法将内存按容量划分为大小相等的两块,每次只使用其中的一块,当这一块内存用完了,就将还存活的对象复制到另一块上面,然后再把已使用过的内存空间一次清理掉.这样使得每次都是对整个半区进行内存回收,内存分配的时候也不比考虑内存碎片等复杂情况,只要移动堆顶指针,按顺序分配内存即可,实现简单运行高效. 这种算法的代价是将内存缩小为原来的一半,未免太高了一点. 现代的商用虚拟机都采用这种收集算法来回收新手代,IBM公司的专门研究表明,新生代中的对象98%是&quot;朝生夕死&quot;的,所以并不需要按照1:1的比例来划分内存空间,而是将内存分为一块较大的Eden空间和两块较小的Survior空间,每次使用一块Eden和其中一块Survior. 当回收时,将Eden和Survior中还存活着的对象一次性复制到另外一块Survior空间,最后清理掉Eden和刚刚用过的Survior空间. HotSpot虚拟机默认Eden和Survior的大小比例是8:1,每次新生代中可用的内存空间为整个空间的90%,只有10%的内存会被浪费. 当Survior空间不够用时,需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion) 复制算法在对象存活率较高时就要进行较多的复制操作,效率会变低,而且需要额外的空间进行分配担保,所以在老年代中一般不能直接采用复制算法. 标记-整理算法 标记-整理算法(Marking-Compact) 是根据老年代的特点提出来的. 标记过程仍与标记-清除算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉边界以外的内存. 分代收集算法 当前商业虚拟机的垃圾收集都采用分代收集算法(Generational Collocation) .这种算法并没有什么新的思想,只是根据对象存活周期将不同的内存划为几块. 一般是把Java堆分为新生代和老年代,这样就可以根据各个年代的特点采用最适当的收集算法. 在新生代中,每次垃圾收集都会有大批对象死去,只有少量存活,那就选用复制算法,只需要付出少量存活对象的复制成本就可以完成收集; 而老年代因为对象存活率高,没有额外的空间对它进行分配担保,就必须使用标记-清除或者标记-整理算法来进行回收. HotSpot的算法实现 上面从理论上介绍了对象存活判定算法和垃圾收集算法,而在HotSpot虚拟机上实现这些算法时,必须对算法的执行效率有严格考量,才能保证虚拟机高效运行. 枚举根节点 在可达性分析时,从GC Roots节点找引用链这个操作中,可视为GC Roots的节点主要在全局性引用(例如常量或类静态属性)与执行上下文(如栈帧中的本地变量表)中,现在很多应用仅仅方法区就有数百兆,如果要逐个检查这里么的引用,那必然会消耗很多时间. 另外,可达性分析对执行时间的敏感还体现在GC停顿上,因为这项分析工作必须在一个能确保一致性的快照中进行.这里&quot;一致性&quot;的意思是指在整个分析期间不能出现对象引用关系还在不断变化的情况.这一点不满足的话分析结果准确性就无法得到保证.这点是导致GC进行时必须停顿所有Java执行线程(Sun将这件事情称作&quot;Stop The World&quot;)的其中一个重要原因. 目前主流的Java虚拟机使用的都是准确式GC,所以当执行停下来后,并不需要一个不漏地检查完所有执行上下文和全局的引用位置.虚拟机应当是有方法直接得知哪些地方存放着对象引用. 在HotSpot的实现中,是使用一组称为OopMap的数据结构来达到这个目的的. 在类加载完成的时候,HotSpot就把对象内什么偏移量上是什么类型的数据计算出来,在JIT编译过程中,也会在特定的位置记录下栈和寄存器中哪些位置是引用.这样,GC在扫描时就可以直接得到这些信息了. 安全点 在OopMap的帮助下,HotSpot可以快速且准确地完成GC Roots的枚举,但有一个问题: 可能导致引用关系变化,或者说OopMap内容变化指令非常之多,如果为每一条指令都生成对应的OopMap,那将会需要大量的额外空间,这样GC的空间成本将会变得很高. 实际上,HotSpot着实没有为每条指令都生成OopMap,前面已经提到,只是在特定的位置记录了这些信息,这些位置被称为安全点(Safepoint) ,即程序执行时并非在所有地方都能停下来开始GC,只有在到达安全点时才能暂停. Safepoint的选定既不能太少以致于让GC等待时间太长,也不能过于频繁以致于过分增大运行时负荷. 所以,安全点的选定基本上是以程序&quot;是否具有让程序长时间执行的特征&quot;为标准进行选定的,因为每条指令执行的时间都非常短暂,程序不太可能因为指令流长度太长这个原因而过长时间运行,&quot;长时间执行&quot;的最明显的特征就是指令序列复用,例如方法调用,循环跳转,异常跳转等,所以具有这些功能的指令才会产生Safepoint. 对于Safepoint,另一个需要考虑的问题是如何在GC发生时让所有线程(这里不包括执行JNI调用的线程)都跑到最近的安全点上再停顿下来. 这里有两种方案可供选择:抢先式中断(Preemptive Suspension) 和主动式中断(Voluntary Suspension) 抢先式中断 抢先式中断不需要线程的执行代码主动去配合,在GC发生时,首先把所有线程全部中断,如果发现有线程的地方不在安全点上,就恢复线程,让它跑到安全点上. 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件. 主动式中断 主动式中断的思想是当GC需要中断线程的时候,不直接对线程操作,仅仅简单地设置一个标志,各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己中断挂起. 对标志进行轮询的时机和安全点出现的时机是重合的,在其基础上加上创建对象需要分配内存的时机. 安全区域 使用Safepoint似乎已经完美解决了如何进入GC的问题,但实际情况却并不一定. Safepoint机制保证了程序执行时,在不太长的时间内就会遇到可进入GC的Safepoint. 但是,程序&quot;不执行&quot;的时候呢?所谓的程序不执行就是没有分配CPU的时间,典型的例子就是线程处于Sleep状态或者Blocked状态,这时候线程无法响应JVM的中断请求,走到Safepoint中断挂起,JVM显然不太可能等待线程被分配CPU的时间.对于这种情况,就需要安全区域(Safe Region) 来解决. 安全区域是指在一段代码中,引用关系不会发生变化,在这个区域中的任意地方开始GC都是安全的. 在线程执行到Safe Region中的代码时,首先标识自己已经进入了Safe Region,那样,当在这段时间里JVM要发起GC时,就不用管标识为Safe Region状态的线程了.在线程要离开Safe Region时,它要检查系统是否已经完成了根节点枚举(或者是整个GC过程),如果完成了,那线程继续执行,否则线程就必须等待直到收到可以安全离开Safe Region的信号为止. 垃圾收集器 垃圾收集算法是内存回收的方法论,垃圾收集器是内存回收的具体实现. Java虚拟机规范中对垃圾收集器应该如何实现没有任何规定,因此不同的厂商,不同版本的虚拟机所提供的的垃圾收集器都可能有很大差别,并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器. 这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机(这个版本中正式提供了商用的G1收集器),这个虚拟机包含的所有收集器如下图: 上图展示了7种不同分代的收集器,两个收集器之间的连线代表它们可以搭配使用. 虚拟机所处的区域,则表示它是属于新生代还是老年代收集器. Serial收集器 Serial收集器是最基本,发展历史最悠久的收集器,曾经(JDK 1.3.1之前)是虚拟机新生代收集的唯一选择. 这个收集器是一个单线程收集器,但它的单线程的意义并不仅仅说明他只会使用一个CPU或一条收集线程去完成垃圾收集工作,更重要的是在它进行垃圾收集时,必须暂停其他所有的工作线程,直到它收集结束,这对很多应用来说是无法接受的. 对于&quot;Stop The World&quot;带给用户的不良体验,虚拟机的设计者们表示完全理解,但也表示非常委屈:&quot;你妈妈给你打扫房间的时候,肯定也会让你老老实实地在椅子上或者房间外面待着,如果她一边打扫,你一边丢纸屑,这房间还能打扫完?&quot;这确实是一个合理的矛盾. HOtSpot虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行.从Serial到Parallel再到CMS乃至G1,一个个收集器越来越优秀,用户线程的停顿时间在不断缩短,但是扔没办法完全消除. Serial收集器一直是虚拟机运行在Client模式下的默认新生代收集器,它相对于其他收集器的单线程的优点是:简单而高效. 对于限定单个CPU的环境来说,Serial收集器没有线程交互的开销,专心做垃圾收集自然可以获得更高的单线程收集效率. 在用户的桌面应用场景中,分配给虚拟机管理的内存一般来说不会很大,收集几十兆甚至一两百兆的新生代,停顿时间完全可以控制在几十毫秒最多一百毫秒内,只要不是频繁发生,这点停顿是完全可以接受的. 所以,Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择. ParNew收集器 ParNew收集器其实就是serial收集器的多线程版本,除了使用多条线程进行垃圾收集之外,其余行为包括Serial收集器可用的所有控制参数,收集算法,Stop The World,对象分配规则,回收策略等都与Serial收集器完全一样,在实现上,这两种收集器也共用了相当多的代码. ParNew收集器除了多线程之外,其他与Serial收集器相比并没有太多创新之处,但它却是很多运行在Server模式下的虚拟机中首选的新生代收集器,其中有一个与性能无关但是很重要的原因是,除了Serial收集器外,只有它能与CMS收集器配合工作. ParNew收集器在单CPU情况中绝对不会有比Serial收集器更好的效果.但随着CPU数量的增加,它对于GC是系统资源的有效利用还是很有好处的. Parallel Scavenge收集器 Parallel Scavenge收集器是一个新生代收集器,它也是使用复制算法的收集器,又是并行的多线程收集器. Parallel Scavenge收集器的特点是它的关注点与其他收集器不同,CMS等收集器的关注点是尽可能地缩短垃圾收集时用户停顿的时间,而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput). 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值,即 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) 停顿时间越短就越适合需要与用户交互的程序,良好的响应速度能提升用户体验. 而高吞吐量可以高效地利用CPU时间,尽快完成程序的运算任务,主要适合在后台运算而不需要太多交互的任务. 由于与吞吐量关系密切,Parallel Scavenge收集器也经常被称为&quot;吞吐量优先&quot;收集器 Serial Old收集器 Serial Old是Serial收集器的老年代版本.它同样是一个单线程收集器,使用标记-整理算法. 这个收集器的主要意义也是在于给Client模式下的虚拟机使用. 如果再Server模式下,那么它还有两大用途: 给JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用 作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure时使用 Parallel Old收集器 Parallel Old是Parallel Scavenge收集器的老年代版本,使用多线程和标记-整理算法. 由于老年代的Serial Old收集器在服务端拖累,使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化效果,由于单线程的老年代无法充分利用服务器多CPU的处理能力,在老年代很大而且硬件比较高级的环境中,这种组合还不一定有ParNew加CMS的组合给力. 直到Parallel Old处理器出现后,&quot;吞吐量优先&quot;收集器终于有了比较名副其实的应用组合,在注重吞吐量以及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器. CMS收集器 CMS(Concurrent Mark Sweep)收集器 是一种以获取最短回收停顿时间为目标的收集器. 目前很大一部分Java应用集中在互联网站或者B/S架构的系统服务器上,这类应用尤其重视服务器的响应速度,希望系统停顿时间最短,以给用户带来较好的体验.CMS收集器就非常符合这类应用的需求. 从名字(Mark Sweep)就能看出,CMS是基于标记-清除算法实现的,它的运作过程相对复杂一点,整个过程分为四个步骤: 初始标记(CMS initial mark) 初始标记和重新标记两个步骤仍需要Stop The World. 初始标记仅仅只是标记一下GC Roots能关联到的对象,速度很快 并发标记(CMS concurrent mark) 并发标记阶段就是进行GC Roots Tracing的过程 重新标记(CMS remark) 重新标记为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录.这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记停顿时间短 并发清除(CMS concurrent sweep) 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作,所以,从总体上说,CMS收集器的内存回收过程是与用户线程一起并发执行的. CMS是一款优秀的收集器,它的主要优点在名字上已经体现出来了:并发收集,低停顿,Sun公司的一些官方文档中也称之为并发低停顿收集器(Concurrent Low Pause Collector) 但是CMS还远达不到完美的程度,她又以下3个明显的缺点: 1-CMS收集器对CPU资源十分敏感 在并发阶段,它虽然不会导致用户线程停顿,但是会因为占用了一部分CPU资源而导致应用程序变慢,总吞吐量会降低. 2-CMS收集器无法处理浮动垃圾 CMS收集器无法处理浮动垃圾(Floating Garbage),可能会出现&quot;Concurrent Mode Failure&quot;失败而导致另一次Full GC的产生. 由于CMS并发清理阶段用户线程还在运行着,伴随程序运行自然会还有新的垃圾不断产生,这一部分垃圾出现在标记过程之后,CMS无法在当次收集中处理掉它们,只好留在下一次GC时再清理掉.这一部分垃圾就称为浮动垃圾. 也是由于在垃圾收集阶段用户线程还需要运行,那也就还需要预留有足够的内存空间给用户线程使用,因此CMS收集器不能像其他收集器那样等到老年代几乎被填满了再进行收集,需要预留一部分空间提供并发收集时的程序运作使用. 3-空间碎片过多 CMS是基于标记-清除算法实现的收集器,这意味着手机结束时会有大量空间碎片产生.空间碎片过多时,将会给大对象分配带来很大的麻烦,往往会出现老年代内存还有很大空间剩余,但无法找到足够大的连续空间来分配当前对象,不得不提前触发一次Full GC. G1收集器 内存分配与回收策略 Java体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题: 给对象分配内存和回收分配给对象的内存. 对象的内存分配,往大方向讲,就是在堆上分配,对象主要分配在新生代的Eden区上,如果启动了本地线程分配缓冲,将按线程优先在TLAB上分配.少数情况下也可能会直接分配在老年代中,分配的规则并不是百分之百固定的,其细节取决于当前使用的是哪一种垃圾收集器组合,还有虚拟机中与内存相关的参数配置的设置. 对象优先在Eden分配 大多数情况下,对象在新生代Eden中分配.当Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC. 大对象直接进入老年代 Java大对象需要大量连续的内存空间. 经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来放置它们. 虚拟机提供了一个-XX:PretenureSizeThreshold参数,令大于这个设置值的对象直接在老年代分配,这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制. 长期存活的对象进入老年代 虚拟机采取了分代收集的思想来管理内存,那么内存回收时就必须能识别哪些对象应放在新生代,哪些对象应放在老年代.为此,虚拟机给每个对象定义了一个年龄(Age)计数器. 如果对象在Eden出生并经过一次Minor GC后仍然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1. 对象在Survivor中每熬过一次Minor GC,对象的年龄就增加1. 当它的年龄增加到一定程度(默认15)就会被晋升到老年代中. 动态对象年龄的判定 为了能更好地适应不同程序的内存状况,虚拟机并不是永远地要求对象年龄达到PretenureSizeThreshold才能晋升老年代.如果再Survivor中相同年龄所有对象大小的总和大于Survior空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代. 空间分配担保 在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间,如果这个条件成立,那么Minor GC可以确保是安全的.如果不成立,则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败. 如果允许,那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小. 如果大于,则会尝试进行一个Minor GC,即时可能出现风险. 如果小于,或者HandlePromotionFailure不允许冒险,那这时要给为进行一次Full GC.]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>深入理解JVM</tag>
        <tag>jvm</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解JVM》笔记-1-Java内存区域]]></title>
    <url>%2Fjvm-understanding-memory%2F</url>
    <content type="text"><![CDATA[Java内存区域 程序计数器 程序计数器(Program Counter register) 是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器.字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令.分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器. 为了切换线程后恢复到正确的执行位置,每条线程都需要有一个独立的线程私有的程序计数器. 如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是一个Native方法,这个计数器值则为空. 异常情况 此内存区域是唯一一个没有任何OutOfMemoryError情况的区域 Java虚拟机栈 Java虚拟机栈(Java Virtual Machin Stacks) 也是线程私有的,它的生命周期与线程相同. 虚拟机栈描述的是Java方法执行的内存模型: 每个方法在执行的同时都会创建一个栈帧(Stack Frame). 栈帧用于存储局部变量表,操作数栈,动态链接,方法出口等信息. 局部变量表 局部变量表存放了编译器可知的各种基本数据类型(byte,boolean,short,int,long,double,float,char),对象引用,和returnAdress类型(指向了一条字节码指令的地址). 64位的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型均只占用一个. 局部变量表所需的内存空间在编译期间完成分配,在进入一个方法时,这个方法需要在栈中分配多大的局部空间是完全确定的. 异常情况 Java虚拟机栈有两种异常状况: 如果线程请求的栈深度大于虚拟机允许的深度,将抛出StackOverflowError异常; 如果虚拟机栈无法申请到足够的内存,将抛出OutOfMemoryError异常. 本地方法栈 本地方法栈为虚拟机使用到的Native方法服务,其余与Java虚拟机栈相似. Java堆 对大多数应用来说,Java堆 是占内存最大的一块. java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例 .这一点在java虚拟机规范中的描述是: 所有对象实例以及数组都要在堆上分配. Java堆是垃圾收集器管理的主要区域. 从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer) (简称TLAB ).TLAB如何划分都和存放内容无关,无论哪个区域,存储的都仍然是对象实例,进一步划分是为了更好地回收内存 ,或者更快地分配内存 . 异常情况 Java堆可以出在物理上不连续的空间中,只要逻辑上是连续的即可.在实现时,主流的虚拟机都是按照可扩展来实现的. 如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常. 方法区 方法区(Method Area) 是线程共享的内存区域,它用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据. 这一区域的内存回收目标主要是针对常量池的回收和对类型的卸载. 运行时常量池 运行时常量池(Runtime Constant Pool) 是方法区的一部分. Class文件中有一项信息是常量池(Constant Pool Table) ,用于存放编译器生成的各种字面量 和符号引用 ,这部分内容将在类加载后进入方法区的运行时常量池中存放. 运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性, Java语言并不要求常量一定只有编译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入仿佛运行时常量池,运行期间 也可能进将新的常量放入池中(这种特性被开发人员利用得比较多的是String类的intern()方法). 异常情况 当方法区无法满足内存分配的需求时,将抛出OutOfMemoryError异常. HotSpot虚拟机中的对象 对象的创建 1-类加载检查 当虚拟机遇到一条new指令时,首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已被加载,解析和初始化过.如果没有,那必须先执行响应的类加载过程. 2-分配内存 对象所需的内存的大小在类加载完成后便可以完全确定,为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来. 如果Java堆中内存是绝对规整的,则使用指针碰撞(Bump the Pointer) 如果Java堆中内存并不是规整的,就要使用空闲列表(Free List) 3-空间置零 内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头),如果使用TLAB,这一工作过程也可以提前至TLAB分配时进行. 这一操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用,程序能访问到这些字段的数据类型所对应的的零值. 4-对象头设置 接下来,虚拟机要对对象进行必要的设置,例如这个对象时哪个类的实例,如何才能找到类的元数据信息,对象的哈希码,对象的GC分代年龄等信息. 这些信息存放在对象的对象头(Object Header) 之中. 5-init 在上面的工作都完成之后,从虚拟机的视角来看,一个新的对象已经产生了,但从Java程序的角度来看,对象的创建才刚刚开始: init方法还没有执行,所有的字段都还为零.所以,执行new指令之后会接着执行init方法,把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才算完全产生出来. 对象的内存布局 对象在内存中的存储的分布可用分为3块区域: 对象头(Header),实例数据(Instance Data)和对齐填充(Padding) 对象头 对象头包括两部分信息: 1-Mark Word 存储对象自身的运行时数据,如哈希码,GC分代年龄,锁状态标志,线程持有的锁,偏向进程ID,偏向时间戳等. 2-类型指针 对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例. 另外,如果对象是一个Java数组,那在对象头中还必须有一块用于记录数组长度的数据. 实例数据 实例数据部分是对象真正存储的有效信息,也是在程序代码中所定义的各种类型的字段内容. 无论是从父类继承下来的,还是在子类中定义的字段内容,都需要记录起来. 这部分的存储顺序会收到虚拟机分配策略参数(FieldAllocationStyle)和字段在Java源码中定义顺序的影响. HotSpot虚拟机默认的分配策略为longs/doubles,ints,shorts/chars,bytes/booleans,OOP(Ordinary Object Pointers),从分配策略中可以看出,相同宽度的字段总是被分配到一起. 在满足这个前提条件的情况下,在父类中定义的变量会出现在子类之前. 如果CompactFields参数值为true(默认为true),那么子类中较窄的变量也可能会插入到父类变量的空隙之中. 对齐填充 对齐填充并不是必然存在的,也没有特别的含义,它仅仅起着占位符的作用. 这个占位符的存在是因为,HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍 对象的访问定位 Java程序需要通过栈上的reference数据来获取到堆上的具体对象. 对象访问方式取决于虚拟机实现.目前主流的访问方式有使用句柄和直接指针两种. 通过句柄访问对象 Java堆中将会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自的具体地址信息. 使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行文)时只会改变句柄中的实例数据指针,而reference本身不需要改变. 通过直接指针访问对象 Java堆对象的布局中必须考虑如何放置访问类型数据的相关类型,而reference中存储的直接就是对象地址. 使用直接指针访问方式的最大好处就是速度更快,它节省了一次指针定位的时间开销. HotSpot使用的是直接指针.]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>深入理解JVM</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于养生的思考]]></title>
    <url>%2Fthinking-health%2F</url>
    <content type="text"><![CDATA[一天睡6小时会比一天睡8小时拥有多2小时清醒的时间,可以说前者比后者多1/8的时间,一年下来,前者比后者多“活着”一个月. 熬夜对身体不好,会死得早.不过,看似死得早,实际上,比看上去死的晚的人少活的,可能只是风烛残年的一小段时间,熬夜的人将这部分生命透支了,换取的是年轻的生命. 这里引出了一个思考: 年轻的生命,和老来的生命,哪个更有价值?需要由此来判断透支是否划算. 我现在还很年轻,我觉得老年人的生命没有意思.以我现在对老年人的心境的理解是,做什么都没有激情,体会不到兴奋,现在的我认为这种生命舍弃也罢,换取年轻时能体验刺激,做事有激情的时间. 不过,这个评判来自现在的我.或许老了的我,虽无法体验到激情,不会兴奋,但能从浇花,散步中体会到有价值的东西呢? 对于这个问题,我现在的观点是:不管将来的我怎么想,我现在按我现在的评判行动即可.老了如果后悔的话,就拿&quot;年轻的我做出的方针是为了使年轻的我很开心&quot;来安慰自己.]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[interview-baidu-2]]></title>
    <url>%2Finterview-baidu-2%2F</url>
    <content type="text"><![CDATA[百度二面印象很深刻,还是记一下 面试官很开朗,很爱笑,跟他聊天空气都活泼起来了]]></content>
      <tags>
        <tag>面试</tag>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nuxt的理解]]></title>
    <url>%2Fnuxt-understanding%2F</url>
    <content type="text"><![CDATA[nuxt nuxt允许将一部分vue的生命周期运行在服务端,在服务端生成部分渲染好的页面之后返回给客户端 nuxt和vue的生命周期 nuxt文档没有说明白服务端渲染中vue生命周期中的哪些部分是运行在服务端,哪些运行在客户端的… 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;section class=&quot;container&quot;&gt; &#123;&#123;p&#125;&#125; &lt;br&gt; &#123;&#123;t&#125;&#125; &lt;/section&gt;&lt;/template&gt;&lt;script&gt; import axios from &apos;axios&apos; export default &#123; data () &#123; return &#123; p: &apos;p&apos;, t: &apos;t&apos; &#125; &#125;, asyncData (&#123; req, params &#125;) &#123; // We can return a Promise instead of calling the callback return axios.get(&apos;https://api.ggemo.com/test&apos;) .then((res) =&gt; &#123; return &#123; posts: res.data &#125; &#125;) &#125;, created () &#123; this.p = this.posts.data.text &#125;, mounted () &#123; console.log(&quot;p before changed: &quot;,this.p) this.p = &apos;p mounted&apos; console.log(&quot;p changed: &quot;,this.p) this.t = &apos;t mounted&apos; &#125; &#125;&lt;/script&gt; 这样渲染出来的html文件的body部分为 1234567891011121314151617181920212223242526&lt;body data-n-head=""&gt;&lt;div data-server-rendered="true" id="__nuxt"&gt;&lt;!----&gt; &lt;div id="__layout"&gt; &lt;div&gt; header &lt;section class="container"&gt; 成功 successed &lt;br&gt; t &lt;/section&gt; footer &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;window.__NUXT__ = &#123; layout: 'default', data: [&#123; posts: &#123; status: 0, data: &#123; text: '成功 successed' &#125; &#125; &#125;], error: null, serverRendered: true&#125;&lt;/script&gt;&lt;script src="/_nuxt/runtime.js" defer&gt;&lt;/script&gt;&lt;script src="/_nuxt/pages_index.js" defer&gt;&lt;/script&gt;&lt;script src="/_nuxt/pages_index.42262e91659a4eb99aae.hot-update.js" defer&gt;&lt;/script&gt;&lt;script src="/_nuxt/vendors.app.js" defer&gt;&lt;/script&gt;&lt;script src="/_nuxt/app.js" defer&gt;&lt;/script&gt;&lt;/body&gt; 在页面上的渲染效果为 其中https://api.ggemo.com/test中的内容为{ posts: { status: 0, data: { text: ‘成功 successed’ } } } created钩子中的 this.p的值,在传给客户端之前就已经被渲染进了html源码 而mounted中的 this.p的值和this.t的值的更改是在客户端被执行的 由此可见,vue的created钩子运行在了服务端,mounted钩子运行在了客户端 nuxt官网的图片: Render应该是执行vue生命周期中beforeMount之前的钩子]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-deploy]]></title>
    <url>%2Fdjango-deploy%2F</url>
    <content type="text"><![CDATA[最终的命令是这样的: 1uwsgi --http :8000 --chdir /root/ggemo_django/ggemo_django --home=/usr/local/python3 --wsgi-file /root/ggemo_djgo/ggemo_django/wsgi.py 期间有不少坑. 要在wsgi.py中将项目地址加入python运行环境 1sys.path.append(os.path.split(os.path.dirname(__file__))[0]) 之后,会提示sqlite版本不够,下载下来新版本后,python的sqlite3库识别不到新的sqlite.之后按照https://superuser.com/questions/1425212/where-does-django-look-for-sqlite-instance-sqlite-3-8-3-or-later-is-required?rq=1说的,将export LD_LIBRARY_PATH=&quot;/usr/local/lib&quot;原封不动写入环境变量,就好了.]]></content>
      <tags>
        <tag>ggemo日志</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务薅羊毛]]></title>
    <url>%2Fhaoyangmao-cloudService%2F</url>
    <content type="text"><![CDATA[免费 腾讯云 https://cloud.tencent.com/act/free 下面的更多产品与服务 重点总结 产品 免费额度 对象存储 企业用户每月1TB标准存储空间，个人用户每月50GB标准存储空间，6个月免费体验时长 CDN 每月10G免费流量，新用户更有连续6个月50GB免费流量 鉴黄 2000张/天 DDoS 防护 抵御2G DDos攻击 七牛云 https://www.qiniu.com/events/free 重点总结 产品 免费额度 对象存储 • 标准存储免费空间 10 GB• 每月免费上传流量 无上限• 10 万次 PUT/月，100 万次 GET/月 CDN 10 GB/月 内容安全 • 免费鉴黄额度 6 万张• 免费鉴暴恐额度 6 万张• 免费政治敏感人物识别额度 6 万张 阿里云 https://free.aliyun.com/ntms/free/personal.html 重点总结 产品 免费额度 短信服务 100条 华为云 https://activity.huaweicloud.com/free_product/index.html 百度智能云]]></content>
  </entry>
  <entry>
    <title><![CDATA[anime-want2watch]]></title>
    <url>%2Fanime-want2watch%2F</url>
    <content type="text"><![CDATA[寒蝉鸣泣之时 无头骑士异闻录 火影忍者 光之美少女]]></content>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第16章-Unity中的渲染优化]]></title>
    <url>%2Fshader-r-optimalize%2F</url>
    <content type="text"><![CDATA[影响性能的因素 CPU负责保证帧率,GPU负责分辨率先关的一些处理 CPU 过多的draw call 复杂的脚本或者物理模拟 GPU 顶点处理 过多的顶点 过多的逐顶点计算 片元处理 过多的片元(既可能是由于分辨率造成的,也可能是由于overdraw造成的) 过多的逐片元计算 宽带 使用了尺寸很大且未压缩的纹理 分辨率过高的帧缓存 对于CPU来说,限制它的主要原因是每一帧中draw call的数目. CPU每次通知GPU渲染之前,都要提前准备好顶点数据(如位置,法线,颜色,纹理坐标等),然后调用一系列API将它们放到GPU的指定位置,最后,调用一个指令,通知GPU开始渲染. 而调用绘制命令时,就会产生一个drawcall.过多的drawcall会造成CPU的性能瓶颈,这是因为每次调用drawcall是,CPU往往都需要 改变很多渲染状态的设置,而这些操作是非常耗时的.如果一帧中需要的drawcall过多的话,就会导致CPU把大部分时间都花费在提交drawcall上面. 当然,其他操作也可能造成CPU瓶颈,例如物理,布料模拟,蒙皮,粒子模拟等,这些都是计算量很大的操作. 而对于GPU来说,它负责整个渲染流水线.他从处理CPU传递过来的模型数据开始,进行顶点着色器,片元着色器等一系列工作,最后输出到屏幕上的每个像素.因此,GPU性能瓶颈和需要处理的定点数,屏幕分辨率,显存等因素有关. 而相关的优化策略可以从减少处理的数据规模(包括顶点数目和片源数目),减少运算复杂度等方面入手. 了解了上面的基本内容后,本章节后续会涉及的优化技术有: GPU优化 使用批处理技术减少drawcall数 GPU优化 减少需要处理的顶点数目 优化几何体 使用模型的LOD(Level of Detail)技术 使用遮挡剔除(Occlusion Culling)技术 减少需要处理的片元数目 控制绘制顺序 警惕透明物体 减少实时光照 减少计算复杂度 使用Shader的LOD技术 代码方面的优化 节省内存带宽 减少纹理大小 利用分辨率缩放 减少drawcall数目 批处理(batching)是经常看到的优化技术.批处理的实现原理就是为了减少每一帧出现的drawcall数目. 为了把一个对象渲染到屏幕上,CPU需要检查哪些光源影响了该物体,绑定shader并设置它的参数,再把渲染命令发送给GPU. 当场景包含大量对象时,这些操作就会非常耗时.一个极端的例子是,如果我们需要渲染1000个三角形,把它们按1000个单独的网格进行渲染所花费的时间要远大于渲染一个包含了1000个三角形的网格.在这两种情况下,GPU性能消耗其实并没有多大的区别,但CPU的drawcall数目会成为性能瓶颈. 因此,批处理的思想很简单,就是在每次调用drawcall时尽可能多的处理多个物体. 使用同一材质的物体可以一起批处理.这是因为,对于使用同一材质的物体,他们之间的不同仅仅在于顶点数据上的差距. 我们可以把这些顶点合并在一起发给GPU,就可以完成一次批处理. Unity中支持两种批处理:一种是动态批处理,一种是静态批处理. 对于动态批处理来说,优点是一切处理都是由Unity自动完成的,不需要我们做任何操作,而且物体是可以移动的,但缺点是,限制很多,可能一不小心就会破坏了这种机制,导致Unity无法动态批处理一些使用了相同材质的物体. 而对于静态批处理来说,它的优点是自由度很高,限制很少;但缺点是可能会占用更多的内存,而且经过静态批处理后的所有物体都不可以再移动了(即便在脚本中尝试改变物体的位置也是无效的). 动态批处理 如果场景中有一些模型共享了同一个材质并满足一些条件,Unity就会自动把它们进行批处理,从而只花费一个drawcall就可以渲染所有模型. 动态批处理的基本原理是,每一帧都可以进行批处理的模型网格进行合并,再把合并后的模型数据传递给GPU,然后使用同一材质对其渲染. 除了实现方便,动态批处理的另一好处是,经过批处理的物体仍然可以移动,这是由于在处理每帧时Unity都会重新合并一次网格. 虽然Unity动态批处理不需要我们进行额外的工作,但只有满足条件的模型和材质才可以被动态批处理.需要注意的是,随着Unity版本的变化,这些条件也有一些改变. 在本节中,我们给出一些主要的条件限制: 能够进行动态批处理的网格的顶点属性规模要小于900. 例如,如果shader中需要使用顶点位置,发信和纹理坐标这三个顶点属性,那么要想让模型能够被动态批处理,它的顶点数目不能超过300.需要注意的是,这个数字在未来有可能会发生变化,因此不需要依赖这个数据. 一般来说,所有对象都需要使用同一个缩放尺度 一个例外情况是,如果所有物体都是用了不同的非统一缩放,那么它们也是可以被动态批处理的.但在Unity5中,这种对模型缩放的限制已经不存在了. 使用光照纹理(lightmap)的物体需要小心处理. 这些物体需要额外的渲染参数,例如,在光照纹理上的索引,偏移量和缩放信息等.因此,为了让这些物体可以被动态批处理,我们需要保证它们指向光照纹理中的同一个位置(?) 多Pass的Shader会中断批处理. 在前向渲染中,我们有时需要使用额外的pass来为模型添加更多的光照效果,但这样一来模型就不会被动态批处理了. 动态批处理的限制比较多,例如很多时候,我们的模型数据往往会超过900的顶点属性限制.这种时候依赖动态批处理来减少drawcall显然已经不能满足我们的需求了. 静态批处理 相对于动态批处理来说,静态批处理适用于任何大小的几何模型. 它的原理是.只在运行开始阶段,把需要进行静态批处理的模型合并到一个新的网格中,这意味着模型不可以在运行时被移动.但由于他只需要进行一次合并操作,比动态批处理更加高效. 静态批处理的一个缺点在于,他往往需要更大的内存来存储合并后的几何结构. 这是因为,如果在静态批处理前一些物体共享了相同的网格,那么在内存中每一个物体都会对应一个该网格的复制品,即一个网格会变成多个网格再发给GPU.如果这类使用同一网格的对象很多,那么这就会成为一个性能瓶颈了. 例如,如果再一个使用了1000个相同树模型的森林中使用了静态批处理,那么就会使用1000倍的内存,这会导致严重的内存影响. 这种时候,解决方法要么忍受这种牺牲内存换取性能的做法,要么不使用静态批处理,而使用动态批处理技术(但要小心控制模型的顶点数和属性数目),或者自己编写批处理方法. 在内部实现上,Unity首先将这些静态物体变换到世界空间下,然后为他们构建一个更大的顶点和索引缓存. 对于使用了同一材质的物体,静态批处理只需要调用一个drawcall就可以绘制全部物体. 而对于使用了不同材质的物体,静态批处理同样可以提升渲染性能,尽管这些物体仍然需要调用多个drawcall,但静态批处理可以减少这些drawcall之间的状态切换,而这些切换往往是费时的操作. 共享材质 从之前的内容可以看出,无论是动态批处理还是静态批处理,都要求模型之间需要共享同一个材质.但不同的模型之间总会需要不同的渲染属性,例如,使用不同的纹理,颜色等.这时,我们需要一些策略 来尽可能地合并材质. 如果两个材质之间只有使用的纹理不用,我们可以把这些纹理合并到一张更大的文立中,这张更大的纹理被称为一个图集(atlas). 一旦使用了同一张纹理,我们就可以使用同一个材质,再使用不同的采样坐标对纹理采样及可. 但有时,除了纹理不同外,不同的物体在材质上还有一些微笑的参数变化,例如,颜色不同,某些浮点属性不同.但是,不管动态批处理还是静态批处理,它们的掐你都是要使用同一个材质. 是同一个,而不是使用了同一种shader的材质,也就是说它们指向的材质必须是同一个实体.这意味着,只要我们调整了参数,就会影响到所有使用这个材质的对象.那么想要微小的调整,一个常用的方法就是使用网格的顶点数据(最常见的就是顶点颜色数据)来存储这些参数. (这里还有一段较详细的,以后再看) 批处理的注意事项 尽可能选择静态批处理,但时刻小心对内存的消耗,并且记住经过静态批处理的物体不可以再被移动 如果无法进行静态批处理,而要使用动态批处理的话,那么请小心上面提到的各种限制. 例如,尽可能让这样的物体少并且尽可能让这些物体包含少量的顶点属性和顶点数目. 对于游戏中的小道具,例如捡拾的金币等,可以使用动态批处理 对于包含动画这类物体,我们无法全部使用静态批处理,但其中如果有不动的部分,可以把这部分标识为&quot;Static&quot; 除了上述的提示外,在使用批处理时还有一些需要注意的地方. 由于批处理需要把多个模型变换到世界空间下再合并它们,因此,如果shader中存在一些基于模型空间下的坐标的运算,那么往往会得到错误的结果.一个解决方法是在shader中使用DisableBatching标签强制使用该Shader的材质不被批处理. 另一个需要注意的是,使用半透明材质的物体 通常需要使用严格的从后往前的绘制顺序来保证透明混合的正确性.对于这些物体,Unity会首先保证它们的绘制顺序,再尝试对它们进行批处理.这意味着,当绘制顺序无法满足时,批处理无法在这些物体上被成功应用. 减少需要的顶点数目 优化几何体 Unity中显示的顶点数目往往要多余建模软件里显示的顶点数.通常Unity中显示的数目要大很多.我们真正应该关心的是Unity中显示的数目. 三维软件更多的是站在我们人类的角度理解顶点的,即组成几何体的每一个点就是一个单独的点. 而Unity是站在GPU的角度上去计算顶点的. 在GPU看来,有时需要把一个顶点拆分成两个或更多的顶点.这种将顶点一分为多的原因主要有两个:一是为了分离纹理坐标(uv splits),另一个是为了**产生平滑的边界88(smoothing splits).它们的本质,其实都是对于GPU来说,顶点的每一个属性和顶点之间必须是一对一的关系.而分类纹理坐标,是因为建模时的一个顶点的纹理坐标有多个. 例如,对于一个正方体,它的六个面之间虽然使用了一些相同的点,但在不同面上,同一个顶点的纹理坐标可能并不相同.对于GPU来说,这是不可理解的.因此,它必须把这个顶点拆分成多个具有不同纹理坐标的顶点. 而平滑边界也是类似,不同的是,此时一个顶点可能会对应多个法线信息和切线信息.和通常是因为我们要决定一个边时一条硬边(hard edge)还是一条平滑边(smooth edge) 对于GPU来说,它本质只关心有多少个顶点.因此,尽可能减少顶点数其实才是我们真正需要关心的事情.因此,最后一条几何体优化建议是:移除不必要的硬边以及纹理衔接,避免边界平滑和纹理分离. 模型的LOD算法 另一个减少顶点数的方法是使用LOD技术.这种技术是,当一个物体离摄像机很远时,模型上的很多细节是无法被察觉到的.因此,LOD允许当对象逐渐远离摄像机时,减少模型上的面片数量,从而提高性能. 在Unity中,我们可以使用LOD Group组件来为一个物体构建一个LOD.我们需要为同一个对象准备多个包含不同细节程度的模型,然后把他们赋给LOD Group组件中的不同等级,Unity就会自动判断当前位置上需要使用哪个等级的模型 遮挡剔除技术 遮挡剔除(Occlusion culling)可以用来消除那些在其他物体后面看不到的物件,这意味着资源不会浪费在那些看不到的顶点上.进而提升性能. 我们需要把遮挡剔除和摄像机的视锥体剔除(Frustum Culling)区分开来. 视锥体剔除只会剔除掉那些不在摄像机的视野范围内的对象,但不会判断视野中是否有物体被其他物体挡住.而遮挡剔除会使用一个虚拟的摄像机来遍历场景,从而构建一个潜在氪金的对象集合层级结构. 在运行时刻,每个摄像机将会使用这个数据来识别哪些物体是可见的,而哪些物体被其他物体挡住不可见.使用遮挡剔除技术,我们需要进行一系列额外的处理工作,具体步骤参见Unity手册相关内容(docs.unity3d/Manual/OcclusionCulling.heml) 模型的LOD技术和遮挡剔除技术可以同时减少CPU和GPU的负荷.CPU可以提交更少的drawcall,而GPU需要处理的顶点和片元数目也减少了. 减少需要处理的片元数目 另一个造成GPU瓶颈的是需要处理过多片元.这部分优化的重点在于减少overdraw.简单来说,overdraw指的就是 同一个像素被绘制多次. Unity中Scene视图左上方的下拉菜单中选中Overdraw即可查看overdraw. 实际上,这里的视图只是提供了查看物体相互遮挡的层数,并不是真正的最终屏幕绘制的overdraw.也就是说,可以理解为它显示的是,如果没有任何深度测试和其他优化策略时的overdraw. 这种视图通过吧所有游戏对象都渲染成一个透明的轮廓,透过查看透明颜色的累积程度来判断物体之间的遮挡. 控制绘制顺序 为了最大限度避免overdraw,一个重要的优化策略就是控制绘制顺序. 由于深度测试的存在,如果我们可以保证物体都是从前往后绘制的,那么就可以很大程度上减少overdraw.这是因为,在后面绘制的物体由于无法通过深度测试,因此就不会再进行后面的渲染处理. 在Unity中,那些渲染队列数目小于2500(如&quot;Background&quot;“Geometry&quot;和&quot;AlphaTest”)的对象都被认为是不透明(opaque)的物体,这些物体总体上是从前往后绘制的,而使用其他的队列(如&quot;ransparent&quot;&quot;Overlay&quot;等)的物体则是从后往前绘制的.这意味着,我们可以尽可能地把物体的队列设置为不透明的渲染队列,而尽量避免使用半透明队列. 好无聊了这块以后再来看 时刻警惕欧明物体 减少实时光照和阴影]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp笔记-装箱与拆箱]]></title>
    <url>%2Fcsnote-2%2F</url>
    <content type="text"><![CDATA[官方指南翻译 官方指南: Boxing and Unboxing (C# Programming Guide) 装箱是把一个值类型转换为object类型或转换为任何实现了该值类型接口的类型的过程.当CLR装箱一个值类型时,它将这个值封装进一个System.Object并且存在堆中.拆箱将这个值从这个object中取出来.装箱是隐式的,拆箱是显式的.装箱和拆箱的概念是C#类型系统统一视图的基础.C#类型系统中,一任何类型的值都可以被当做object. 在下面的例子里,int值i被装箱,并赋值给objecto 123int i = 123;// 下面一行装箱了i.object o = i; 然后objecto可以拆箱并赋值给变量i 12o = 123;i = (int)o; // 拆箱 下面的例子解释了装箱在C#中的应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// String.Concat 例子// 42和true必须被装箱Console.WriteLine(String.Concat("Answer", 42, true));// List 例子// 新建一个objects的list存放各种各样类型的元素List&lt;object&gt; mixedList = new List&lt;object&gt;();// 往这个list中天际一个stringmixedList.Add("First Group:");// 往这个list中添加一些intfor (int j = 1; j &lt; 5; j++)&#123; // 每个添加进这个list的j都会被装箱 mixedList.Add(j);&#125;// 添加另一个string和更多intmixedList.Add("Second Group:");for (int j = 5; j &lt; 10; j++)&#123; mixedList.Add(j);&#125;// 显示这个list中的所有元素. 用var声明循环中的所有变量, 然后编译器会分配它的类型foreach (var item in mixedList)&#123; Console.WriteLine(item);&#125;// 下面的循环将第一批的int的平方加起来// 这些list的元素是objects,在被拆箱之前不能乘和加// 这个拆箱必须是显式的var sum = 0;for (var j = 1; j &lt; 5; j++)&#123; // 下面的语句会引起一个编译错误: // Operator '*' cannot be applied to operands of type 'object' and 'object'. //sum += mixedList[j] * mixedList[j]); // 当列表元素拆箱后,计算不会引起编译错误 sum += (int)mixedList[j] * (int)mixedList[j];&#125;// 显示的结果是 30, 1 + 4 + 9 + 16.Console.WriteLine("Sum: " + sum);// Output:// Answer42True// First Group:// 1// 2// 3// 4// Second Group:// 5// 6// 7// 8// 9// Sum: 30 性能 因为涉及到一个简单的分配, 所以装箱和拆箱在计算上是昂贵的. 当一个值类型被装箱时, 一个新的object就会被指派和创建. 在较小的程度上, 拆箱需要的花费在计算上也是很昂贵. 更多信息请浏览性能 装箱 装箱用来将值类型存到垃圾回收(GC)堆中. 装箱隐式地将值类型转换为object类型或转换为任何实现了该值类型接口的类型. 将一个值类型装箱会在堆中指派一个object实例并将这个值拷贝进这个新的object. 考虑下下面这个值类型变量的声明: 1int i = 123; 下面的语句隐式地对变量i进行了拆箱: 12// 拆箱将i的值拷贝进object oobject o = i; 上面语句的结果是,在栈上创建一个对象o的引用, 引用了在堆上的int类型的值. 这个值是一个分配到变量i上的值类型的拷贝. i和o这两个变量的区别可以用下面这张装箱变换的图来形象的解释: 装箱也可以像下面这样显式的执行, 不过显式的装箱永远不会用到: 12int i = 123;object o = (object)i; // 显式的装箱 描述 这个例子用装箱将一个int变量i转换成一个objecto. 然后,如果存放在变量i中的值从123变为456… 下面的例子表明了,圆本 的值类型和装箱后的object使用不同的内存地址, 所以可以存储不同的值. 例子 123456789101112131415161718192021class TestBoxing&#123; static void Main() &#123; int i = 123; // 装箱将i的值拷贝进object o object o = i; // 改变i的值 i = 456; // i的改变不会影响到o中值的变化 System.Console.WriteLine("The value-type value = &#123;0&#125;", i); System.Console.WriteLine("The object-type value = &#123;0&#125;", o); &#125;&#125;/* 输出: The value-type value = 456 The object-type value = 123*/ 拆箱 拆箱显式地将object类型或任何实现了该值类型接口的类型转换为一个值类型. 一个拆箱操作由下面两部分组成: 确定这个object实例是一个给定值类型的装箱. 将这个实例中的值拷贝给一个值类型变量. 下面的语句展示了装箱和拆箱操作: 123int i = 123; // 一个值类型object o = i; // 装箱int j = (int)o; // 拆箱 下面的图是上面语句的演示: 为了确保拆箱在运行时能成功, 被拆箱的东西必须是一个之前被装箱创建的object的引用. 尝试去拆箱null会引发一个NullReferenceException.尝试拆箱一个不相容的类型会引发一个InvalidCastException 例子 下面的例子示范了一个不正确的引发了InvalidCastException的拆箱的例子: 12345678910111213141516171819class TestUnboxing&#123; static void Main() &#123; int i = 123; object o = i; // 隐式装箱 try &#123; int j = (short)o; // 尝试拆箱 System.Console.WriteLine("Unboxing OK."); &#125; catch (System.InvalidCastException e) &#123; System.Console.WriteLine("&#123;0&#125; Error: Incorrect unboxing.", e.Message); &#125; &#125;&#125; 上面的程序会输出: Specified cast is not valid. Error: Incorrect unboxing. 如果你将int j = (short) o;改为int j = (int) o;, 这个转换就会成功, 会输出Unboxing OK.]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>csharp</tag>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp笔记-值类型与引用类型]]></title>
    <url>%2Fcsnote-1%2F</url>
    <content type="text"><![CDATA[之前玩python的时候就有点在意但是没仔细学…只知道python是简单值传值,复杂值传引用. C#中的值类型和引用类型 C#中的所有Object的派生类都是引用类型 byte，short，int，long，float，double，decimal，char，bool和struct统称为值类型 这里注意,结构体为值类型而类都是引用类型. 值类型和引用类型的区别 以下部分参考了知乎这篇文章并加上自己的理解 值类型的数据存储在内存的栈中,引用类型的数据存储在内存的堆中.而内存单元中只存放堆中对象的地址,因此值类型存取速度快,引用类型存取速度慢 值类型表示实际数据,引用类型表示指向存储在内存堆中的数据的指针或引用 值类型继承自System.ValueType,引用类型继承自System.Object 栈的内存分配是自动释放；而堆在.NET中会有GC来释放 值类型没法继承,没法用接口来引用(虽然泛型+接口解决部分问题) 以下参考知乎:C# 引用类型相比于值类型意义何在? - Nanry的回答 - 知乎 百度百科引用类型的解释: 引用类型 由类型的实际值引用（类似于指针）表示的数据类型。如果为某个变量分配一个引用类型，则该变量将引用（或“指向”）原始值。不创建任何副本。引用类型包括类、接口、委托和装箱值类型。 值类型并不是在程序启动时就全部分配在栈上的,而是一直在入栈出栈操作,所以正常情况下由于入栈出栈的操作,不会超过栈空间的限制,超过了就是引起非常内存访问了(如果是static是不是一开始就全部分配在栈上呢?) C#的值类型就是存在栈中的.值类型是轻量级的类型,因为在大多数情况下,值类型的的实例都分配在线程栈中,因此它不受垃圾回收的控制,缓解了托管堆中的压力,减少了应用程序的垃圾回收的次数,提高性能.(栈中存的数据可以自动清理,堆中的数据要依靠GC) 顺便,有一种编程技巧极其容易因为栈空间不足而导致非常内存访问的情况,那就是递归.如果你在一个递归方法中使用了值类型,并且递归次数过多,经常会发生栈溢出的异常。 下面是两个,上面的那个答主提到的扩展阅读,以后再看 一看就懂：图解C#中的值类型、引用类型、栈、堆、ref、out 栈大小和内存分部问题 顺便引出的以后再看的问题: 栈和堆 尾递归优化]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>csharp</tag>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMVCC设计模式的理解]]></title>
    <url>%2Fnote-AMVCC%2F</url>
    <content type="text"><![CDATA[对比以前前端MVVM设计模式做出理解 MVVM MVVM在view层负责根据数据展示视图,如v-if,v-for标签的作用. view层会响应事件,调用model层方法,如@click标签等. model层则负责所有数据的操作. MVC Unity中的MVC的view层根据数据展示视图 view层会响应事件,之后通知Controller层,对事件进行响应. MVC像是把MVVM的model拆成model和controller两层. controller层会使用和更改数据,但不会存储数据.存储数据交给model层. 个人理解,这样做的好处是条理更清晰,比如所有取数据,都在APP.Model.someData,并且在Unity中调整变量值的地方更加集中,容易管理.Unity传统的EC模型相对于MVC,在脚本之间互相调用和互相传参十分麻烦. Controller的switch-case 这里的&quot;避免庞大的switch-case&quot;仅为代码书写上,不会显得太多switch-case,实际执行的逻辑上还是该多少还是多少.]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载翻译 Unity with MVC-How to Level Up Your Game Development]]></title>
    <url>%2Funity-with-mvc-how-to-level-up-your-game-development%2F</url>
    <content type="text"><![CDATA[Unity with MVC: How to Level Up Your Game Development的翻译 没有找到好的国内的unity mvc的资料,国外的找到了这个. 自己翻译下,功力尚浅望轻喷.(页面最下面有评论板块) 原文地址: https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development (以括号开头和结尾的代码块为译者的注释和吐槽,比如这行和下面一行) (这个标题说是MVC,实际上讲的是MVC的一个变种: AMVCC模式) 程序猿经常从经典的Hello World着手开始学习.从那开始,项目越做越大.每个新挑战都指向一个重要的课题: 项目越大,就越乱. 不久后,就可以看到大小团队不会随意的不顾一切的做项目.代码应该被维护且能长时间持续使用.你工作过的公司不会只要你联系方式而是每次需要修或改善代码的时候叫你(然而你不希望这样). 这就是软件设计模式存在的理由;他们利用简单的规则来操控一个软件工程的整体架构.他们使一个或多个程序猿把一个大项目的部分分开成一些核心部分来写,并且用一个标准化的方法来组织,使得遇到不熟悉的代码的部分时能消除混乱. 如果所有人都遵守这些规则,就会使传统代码能更好的维护和操纵,并且新的代码可以更灵活地添加进去.规划开发的方法论花费的时间更少.因为问题是多种多样的,所以设计模式不存在最强杀招.必须仔细考虑每个模式的优点和缺点,然后找到最适合拿来解决手头的问题的. 在这份教程中,我会结合我在Unity游戏开发平台和Model-View-Controller(MVC)模式上的经验.在我七年的开发,在与我乱成一锅粥的游戏开发的正面对决中,我利用设计模式得到了很好的代码结构和开发速度. 我一开始会讲一些uninty的基础架构:Entity-Component模式.然后我会解释MVC如何适应它,并且用一些模拟的项目来解释它. 动机 在软件相关的文献中,我们可以找到一大堆关于设计模式的.纵然他们有一系列规则,开发者仍然经常需要做一些小的改动来使设计模式更能适应他们独特的问题. 这种&quot;程序编制的自由性&quot;证明了我们找不到一个单一的,确定的方法来设计软件.所以,这篇文章不应是解决你问题的终极方案,而是展示两种流行的设计模式:Entity-Component和Model-View-Controlle的效益和发展潜力. Entity-Component模式 Entity-Component(EC)是一种设计模式,我们首先定义组成应用的元素们的层级(Entities),然后定义将要被包含的特征和数据(Components).在更多的&quot;程序猿&quot;看来,一个Entity可以是一个包含了有0个或多个Components的对象.让我们这样描述一个Entity: some-entity [component0, component1, …] 这里是一个简单的EC树的例子: 1234567891011- app [Application] - game [Game] - player [KeyboardInput, Renderer] - enemies - spider [SpiderAI, Renderer] - ogre [OgreAI, Renderer] ui [UI] - hud [HUD, MouseInput, Renderer] - pause-menu [PauseMenu, MouseInput, Renderer] - victory-modal [VictoryModal, MouseInput, Renderer] - defeat-modal [DefeatModal, MouseInput, Renderer] EC在缓解多重继承的问题方面是一个好的模式,当一个复杂的类结构引出问题时,例如钻石问题: 一个类D,继承自两个类,B和C,而B和C继承自同一个类A,这时就会引发冲突,因为B和C会不同地修改A的属性. 因为在游戏开发中继承应用很广泛,所以这种问题会很常见. 通过分解小的Component的属性和数据操作器,可以使他们可以附加在不同的Entitiy上并重用,而不用依赖于复杂的继承关系(顺便,这不只是C#或JavaScript,Unity常用的语言的特征). Entity-Component模式的不足 EC在OOP之上的一个层面,EC有利于整理和更好的组织你的代码架构.然而,在大项目中,我们仍然&quot;太过随意&quot;然后我们会发现自己身处一个&quot;属性海洋&quot;,可能会费一段艰苦的时光来找到对的Entity和Component,或搞清楚它们应该如何相互影响.一个给定的任务中会有无穷种Entity和Component的组合方式. 一个摆脱混乱的途径是在Entity-Component之上添加一些的额外的参考.比如,我喜欢的一种考虑软件的方式是将其差分成三种不同的类别: 一些处理原数据,允许创建,读取,更新,删除和查找(也就是CRUD) 另一些实现一些接口来和其他元素相互作用,检测他们范围内相关的事件并且当发生时触发通知 最后,一些元素负责接收这些通知,制定事务逻辑决策,并决定如何操作数据 幸运的是,我们已经有表现得符合这些需求的设计模式了. Model-View-Controller(MVC)模式 Model-View-Controller pattern(MVC)模式将软件分成三个主要模块:Models (数据CRUD), Views (界面/事件检测)和Controllers (决策/处理).MVC实现起来足够灵活,即使是建立在ECS或OOP之上. 游戏和UI的开发有通常的工作流程: 等待用户输入,或其他的触发条件,向合适的地方发送这些通知,决定如何响应,并做出相应的数据操作.这些行为清楚地表现了MVC应用的兼容性. 这种方法论引入了其他的抽象层,会对软件规划有帮助,并且让新来的程序猿能掌控一个就算很大的代码库.通过将思考过程分离成数据,接口和决策,可以减少开发者必须通过查找来添加或修改功能的源文件. Unity和EC 让我们仔细看看unity预先给我们了什么. Unity是一个建立在EC上的开发平台,所有的Entity都是GameObject的实例,它们的属性可以使他们&quot;可见&quot;,“可移动”,“可交互”,等等,都是由继承Component的类提供的. Unity editor的Hierarchy面板和Inspector面板提供了装配你的应用的强大的方法,用比通常情况下更少的代码来附加组件,配置它们的初始化状态和引导你的游戏. 尽管如此,我们讨论过的,我们会遇到&quot;太多属性&quot;的问题并且发现我们身处一个庞大的层级中,属性分散在各个地方,使开发者更加难以存活. 按MVC的方式思考,我们可以按事物的功能将它们分类,使我们的应用的结构像下面这个例子这样: 将MVC打造进游戏开发环境 现在我要介绍两种简单的 一般的MVC模式的变种,可以将其打造进我曾用MVC建立Unity项目时遇到的特殊的情况: MVC的类容易散布在代码里 在Unity中,开发者通常必须拖拽对象来获取它们,或者使用类似GetComponent( … )的笨重的查找语句来获取对象 如果Unity崩溃了或者一些bug使所有的拖拽来的引用丢失了,会使该死的引用丢失接连发生. 必须使用一个独特的根引用对象,通过它来使Application中的所有对象可获取和重新获得. 一些元素封装了一些 一般的,需要高度重用的,不能自然地分类到Model,View或Controller中的功能.我简单地叫它们组件.它们也是Entity-Component中的&quot;Components&quot;的概念.但是在MVC框架中仅仅作为辅助者. 例如,一个Rotator组件,只会按照角速度旋转物体,但不会通知,存储,或决定任何事. 为了帮助缓解两种问题,我提出了一种魔改的设计模式,我叫它AMVCC,或Application-Model-View-Controller-Component. Application 你的应用的单独的入口,是所有决定性的实例和依赖应用的数据的容器 MVC 到目前为止你应该知道的. 😃 Component 可复用的,小的,容易被包含的脚本 例子: 10 Bounces 作为一个简单的例子,让我们来看下一个简单的叫10 Bounces的游戏,在此我会使用AMVCC模式的核心要素 这个游戏的结构很简单: 一个带有一个SphereCollider和一个Rigidbody的Ball(将会在&quot;Play&quot;之后开始下落),一个当做地面的Cube和5个搭建AMVCC的脚本. Hierarchy 在写代码之前,我通常会从hierarchy开始并创建我的类和物件的大纲.通常遵守这个新的AMVCC风格. 我们可以看到,view GameObject包含了所有的可见的元素,和其他的包含了View 脚本的物件(???). model和controller组件在一些小项目中通常只包含他们各自的脚本.在大项目中,他们会包含 包含了各自的脚本的GameObjects. 当其他人拿到你的项目希望看到: 数据: 查看application &gt; model &gt; … 逻辑/工作流程: 查看application &gt; controller &gt; … 渲染/接口/监听器: 查看application &gt; view &gt; … 如果所有的团队都遵从这些简单的规则,传统项目将不再成为问题(我谔谔) 需要注意的是,Component没有固定的容器,它们非常灵活,可以在开发者空闲的时候附加到不同的元素上. 写脚本 注意:下面的脚本都是真实世界的实现的抽象版本.一个详细的实现对渲染不太好.然而,如果你想浏览更多,点击这里查看我的个人的Unity MVC框架,Unity MVC.你可以找到大多数应用需要的实现AMVCC结构框架需要的核心class. 让我们来看一下构成10 Bounces的脚本的结构. 在开始之前,因为和常见的Unity的工作流程不同,让我们先简略地阐明脚本和GameObjects是如何共同工作的.在Unity中,“组件”,在Entity-Component的概念中,由MonoBehaviour类表现.一个组件要在运行时存在,开发者需要将其拖拽入一个GameObject(在Entity-Component模式中的&quot;Entity&quot;)或者用AddComponent()命令.在此之后,脚本就会被实例化并且准备好在执行时使用. 首先,我们定义Application类(AMVCC中的&quot;A&quot;),作为主要的类,包含所有实例化的游戏元素的引用.我们也可以创建一个辅助的基类叫Element,让我们能拿到Application实例和他的子元素的MVC实例.(子元素的MVC实例是什么鬼啊晕了晕了) 考虑到这一点,让我们开始定义Application类(AMVCC中的&quot;A&quot;),将要包含一个独特的实例.在它里面,三个变量model,view,和controller,将在运行时给我么提供所有的MVC实例的接入点.这些变量需要是包含 想要的脚本的public引用的MonoBehaviour. 之后,我们也要创建一个辅助基类叫做Element,来给我们提供Application的实例. 注意这两个类都要继承MonoBehaviour,他们是将要被附加到GameObject “Entities&quot;上的&quot;组件”. 1234567891011121314151617181920// BounceApplication.cs// 所有元素的基础类都在这个应用中public class BounceElement : MonoBehaviour&#123; // 应用和所有实例的入口. public BounceApplication app &#123; get &#123; return GameObject.FindObjectOfType&lt;BounceApplication&gt;(); &#125;&#125;&#125;// 10 Bounces 入口.public class BounceApplication : MonoBehaviour&#123; // MVC根实例的引用. public BounceModel model; public BounceView view; public BounceController controller; // Init things here void Start() &#123; &#125;&#125; 我们可以在BounceElement中创建MVC的核心类,BounceModel,BounceView和BounceController通常会是更多专门的实例的容器,不过我们这个例子比较简单,所以只有View有嵌套结构.Model和Controller可以各自用一个脚本来完成: 123456789// BounceModel.cs// 包含这个应用的所有相关数据.public class BounceModel : BounceElement&#123; // 数据 public int bounces; public int winCondition;&#125; 12345678// BounceView .cs// 包含这个应用的所有相关视图.public class BounceView : BounceElement&#123; // ball的引用 public BallView ball;&#125; 123456789// BallView.cs// 记录Ball的视图和属性.public class BallView : BounceElement&#123; // 只有这个是必须的.物理部分在工作的其他部分实现. // 碰撞体的回调函数. void OnCollisionEnter() &#123; app.controller.OnBallGroundHit(); &#125;&#125; 123456789101112131415161718192021// BounceController.cs// 控制应用工作流程.public class BounceController : BounceElement&#123; // 处理Ball的碰撞事件 public void OnBallGroundHit() &#123; app.model.bounces++; Debug.Log("Bounce "+app.model.bounces); if(app.model.bounces &gt;= app.model.winCondition) &#123; app.view.ball.enabled = false; app.view.ball.GetComponent&lt;Rigidbody&gt;().isKinematic=true; // 使ball停下 OnGameComplete(); &#125; &#125; // 处理胜利的情况 public void OnGameComplete() &#123; Debug.Log("Victory!!"); &#125;&#125; 创建好了所有的脚本之后,我们继续配置和附加它们. 层级布局会类似这样: 1234567- application [BounceApplication] - model [BounceModel] - controller [BounceController] - view [BounceView] - ... - ball [BallView] - ... 拿BounceModel做例子,我们看下它在Unity里是什么样子的: 所有的脚本都设定好并且运行之后,我们会在Console Panel中看到这样的输出: (别忘记给ball添加Rigidbody和给ball和ground添加碰撞体) 通知 就像上面这个例子,一个球碰到地板的时候会执行app.controller.OnBallGroundHit()函数.无论如何,在应用中的所有通知都用这种方法并不是&quot;错误&quot;的,但是,以我的经验,在AMVCC的Application类中用一个简单的通知系统能得到更好的结果. 让我们修改BounceApplication结构来实现: 123456789101112131415161718// BounceApplication.csclass BounceApplication &#123; // 遍历所有Controller并作为通知数据的代表 // 这个方法很容易找到,因为每个类都是"BounceElement",都有一个"app"实例 public void Notify(string p_event_path, Object p_target, params object[] p_data) &#123; BounceController[] controller_list = GetAllControllers(); foreach(BounceController c in controller_list) &#123; c.OnNotification(p_event_path,p_target,p_data); &#125; &#125; // Fetches all scene Controllers. public BounceController[] GetAllControllers() &#123; /* ... */ &#125;&#125; 然后,我们需要一个新的脚本让所有开发者添加通知的事件名,这些事件会在运行时进行调度. 123456789101112// BounceNotifications.cs// 这个类将所有的事件名定义为static.class BounceNotification&#123; public const string BallHitGround = "ball.hit.ground"; public const string GameComplete = "game.complete"; /* ... */ public const string GameStart = "game.start"; public const string SceneLoad = "scene.load"; /* ... */&#125; (上面代码块中的&quot;const&quot;原文中皆为static,按原文写编译出错) 显而易见,通过这种方式,程序的可读性增加了,因为开发者不需要在所有的源码中找controller.OnSomethingComplexName方法来理解运行时会产生什么样的行为.只需查看一个文件,就可以理解这个应用的所有行为. 现在,我们只需要改变BallView和BounceController来适应这种新系统: 123456789// BallView.cs// 记录Ball的视图和属性.public class BallView : BounceElement&#123; // 只有这个是必须的.物理部分在工作的其他部分实现. // 碰撞体的回调函数. void OnCollisionEnter() &#123; app.Notify(BounceNotification.BallHitGround,this); &#125;&#125; 12345678910111213141516171819202122232425262728// BounceController.cs// 控制应用工作流程.public class BounceController : BounceElement&#123; // 处理Ball的碰撞事件 public void OnNotification(string p_event_path,Object p_target,params object[] p_data) &#123; switch(p_event_path) &#123; case BounceNotification.BallHitGround: app.model.bounces++; Debug.Log("Bounce " + app.model.bounces); if(app.model.bounces &gt;= app.model.winCondition) &#123; app.view.ball.enabled = false; app.view.ball.GetComponent&lt;RigidBody&gt;().isKinematic=true; // 使ball停下 // 通知自身,说不定有其他其他controller响应 app.Notify(BounceNotification.GameComplete,this); &#125; break; case BounceNotification.GameComplete: Debug.Log("Victory!!"); break; &#125; &#125;&#125; 大项目将会由很多通知.所以为了避免一个庞大的switch-case结构,可以创建不同的controller来处理不同范围的消息. 实际项目中的AMVCC 上面的例子展示了一个AMVCC模式的应用场合.为了使你的思维方式能符合MVC的三个元素,而且按一个有序的层级展示entity应该明确这种技能. 在大项目中,开发者需要面对更多的复杂的场景,并且不好的决定一些事物是该放到View层还是Controller层,或者遇到一个给定的class需要更加彻底地分散到更小的模块. 翻阅的规则 (by Eduardo) 并不存在什么&quot;普遍的MVC整理规则&quot;.但是有一些简单的规则,我遵守它们来帮我决定一些事物是Model,View,Controller,还是需要分解成更小的模块. Class的分类 Model 包含一个应用的核心数据或状态,比如player的health,或是枪的ammo(弹药) 序列化的,并行的,和/或这两种的变种 加载/保存数据(本地或者网络) 在运行中通知Controller 为游戏的有限状态机保存游戏状态 不会接触到Views View 从Model层中获取数据来为用户展示实时的游戏状态.比如,一个View层的方法player.Run()会在内部调用model.speed显示player的行为 不会改动Model层 严格的实现自身类的功能.比如: 一个PlayerView不应该实现输入检测或更改游戏状态 一个View应该表现得像是有通知重要事件的接口的黑盒子 不存储核心数据(比如速度,血量,…) Controller 不存储核心数据 会过滤掉 不希望有的View 发来的通知 更新和使用Model的数据 管理Unity的场景的工作流 Class的层级 既然这样,我不需要遵守太多的步骤.通常,当我需要给变量名加太多的&quot;前缀&quot;时,我就会意识到需要把类分解,或同个元素有太多的变种(如MMO游戏中的Player类或FPS游戏中的Gun类). 比如,一个单个的包含了Player数据的Model会有很多playerDataA, playerDataB,…; 一个处理Player通知的Controller会有很多OnPlayerDidA,OnPlayerDidB,…. 我们想要减小代码体积并且去掉player和OnPlayer前缀. 因为只用数据理解起来很简单,所以我们用一个Model类来做例子. 在写代码时,我通常先用一个单个的Model类包含游戏中的所有数据. 12345678910111213141516171819// Model.csclass Model&#123; public float playerHealth; public int playerLives; public GameObject playerGunPrefabA; public int playerGunAmmoA; public GameObject playerGunPrefabB; public int playerGunAmmoB; // Ops Gun[C D E ...] will appear... /* ... */ public float gameSpeed; public int gameLevel;&#125; 很容易看出,游戏越复杂,变量数会更多.当它够复杂时,我们可能会以一个庞大的包含了model.playerABCDFoo的类来告终.嵌套的元素会简化代码完成,并且使数据有变种的空间. 1234567// Model.csclass Model&#123; public PlayerModel player; // Player数据的容器 public GameModel game; // Game数据的容器&#125; 1234567// GameModel.csclass GameModel&#123; public float speed; // 游戏运行速度 (影响游戏难度) public int level; // 当前载入的游戏关卡/阶段&#125; 12345678// PlayerModel.csclass PlayerModel&#123; public float health; // Player 血量 (在0.0 和 1.0之间) public int lives; // Player 死后"retry"的次数. public GunModel[] guns; // 当前Player在游戏中可切换的枪的数组&#125; 123456789// GunModel.csclass GunModel&#123; public GunType type; // 列举枪的类型 public GameObject prefab; // 枪的3D Asset模板 public int ammo; // 当前子弹数 public int clips; // 可能的再装填弹药的次数&#125; 有了这些类的配置,开发者可以在某时直观地操纵源码中的一个概念.让我们假设一个武器和它们的配置非常多的FPS游戏.GunModel实际上被包含在一个类中,这个类也可以从一系列Prefabs中为各个种类创建实例并将其存储起来方便以后用到. 相比之下,如果所有的枪的信息都包含在一个单独的GunModel中,如gun0Ammo,gun1Ammo,gun0Clips等等,然后当用户需要存储Gun数据的时候,将要需要存储整个Model,即便它还包含了不需要的Player数据.在这种情况下,很明显用一个新的GunModel类会比较好. 就像所有事物都会有优缺点一样.有时人会不必要地过分划分并且增加代码复杂度.只有经验能磨炼你的为你的项目寻找MVC分类的技能. 解锁新的游戏开发特殊能力: 在Unity游戏中使用MVC模式 结论 除此之外还有大量的软件设计模式.在这篇文章中,我尝试着展示了在过去的项目中对我帮助最大的一个.开发者应该一直在吸收新的知识的同时一直保持怀疑.我希望这篇教程能帮助你学习新的东西,并与此同时,成为一个你形成自己的开发风格的跳板. 同时,我真的希望你去多多查找其他的模式来找到最适合你的那个.一个好的出发点是这篇wikipedia文章,里面有出色的模式列表和他们的特征. 如果你喜欢AMVCC模式并且想要尝试它,不要忘了尝试下我的库,Unity MVC,这里包含了所有的,创建AMVCC应用的核心类. 关于作者 https://www.toptal.com/resume/eduardo-dias-da-costa 关于译者 https://blog.ggemo.com/]]></content>
      <tags>
        <tag>unity</tag>
        <tag>设计模式</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lua-study]]></title>
    <url>%2Flua-study%2F</url>
    <content type="text"><![CDATA[Lua语法基础 Lua令牌标记 Lua程序由各种标记组成,标记可是关键字,标识符,常量,字符串或符号. 1io.write("Hello World, from",_VERSION,"\n") 注释 Lua的注释以—开头结尾 12--- 这里是注释print("23333") Lua变量 根据变量范围,Lua变量有三种类型: 全局变量 所有变量被声明为全局变量,除非明确声明为局域变量 局域变量 当变量指定类型为local时,其单位受函数范围的限制 表字段 这是一种特殊类型的变量,可以保存nil之外的任何对象 Lua变量声明和定义 变量定义告诉解释器为变量创建存储的位置和数量,变量具有可选类型,并且包含该类型一个活多个变量的列表(吐槽: 要跟python列表弄混了) 1type variable_list 这里,type是可选的本地或全局类型.而variable_list可以包含一个或多个由逗号分隔的标识符名称. 123local i,jlocal ilocal a,c 变量可以在声明时初始化: 1234567local a, b = 0, 1c, d = 2, 3e,f = 4print(e,f)--- 4 nil--- 注意这里只赋给了e,没有赋给f Lua可以像py那样平行赋值 12345a = 0b = 1a, b = b, aprint(a, b)--- 1 0 Lua数据类型 Lua是一种动态类型语言,即 变量没有类型,只有值有类型 数据类型: 值类型 描述 nil 用于区分值与某些数据或没有数据(类似js里的null或py里的None?) boolean boolean number 表示实数(双精度浮点)数字 string 表示字符数组 function 表示用C语言或Lua编写的方法 userdata 表示任意C语言数据 thread 表示独立的执行线程,用于实现协同程序 table 表示普通数组,符号表,集合,记录,图形,树等,并实现关联数组.它可以保存任何nil以外的值 type函数 12print(type(0))---number 默认情况下,在分配值或初始化之前,所有变量都指向nil. Lua字符串 Lua字符串可以用三种形式初始化 单引号之间的字符串 1'lua' 双引号之间的字符串 1"lua" [[和]]之间的字符串 12[[lua hhhhhhhhaaaaaaa]] [[和]]之间的字符串可以换行,类似py的三个引号的字符串 字符串操作 方法 作用 string.upper(“Some String”) 返回参数的大写表示 string.lower(“Some String”) 返回参数的小写表示 string.gsub(“Some String”, “S”, “啊”) 类似py的replace string.find(“Some String”, “S”) 返回mainStr中,findStr的起始位置和结束位置.我佛辣,这个lua怎么索引都是从1开始的 string.reverse(“Some String”) 返回参数的倒序字符串 string.format(“Some String %d %s”,12,“ccc”) 格式化字符串 string.char(“Some String”)和string.byte(“Some String”) 不解释 string.len(“Some String”) 返回长度ntm不是有#运算符了么??? string.rep(“Some String”,2) 返回参数字符串重复n次后的结果 … …运算链接两个字符串 Lua数组 1234567array = &#123;"a", "b"&#125;print(array[0])--- nilprint(array[1])--- aprint(array[2])--- b Lua数组的索引是从1开始的… Lua数组接受负数和0索引 1234array = &#123;&#125;array[-1] = 10print(array[-1])--- 10 Lua运算符 算术运算符 以下是Lua语言支持的所有算术运算符.假设变量A=10, B=20 运算符 描述 示例 + 两相加操作数 A + B : 30 - 第一个减去第二个操作数 A - B : -10 * 将两个操作数相乘 A * B : 200 / 第一个操作数除以第二个操作数 A / B : 2 % 模数运算符,去整除后的余数 B % A : 0 ^ 指数运算符,取指数幂值 A ^ 2 : 100 - 一元运算符,充当否定 -A : -10 关系运算符 关系运算符 ==, &gt;, &lt;, &gt;=, &lt;=等,跟其他语言差不多. 注意不等于是~=,而非!= 逻辑运算符 and, or, not,和python用起来差不多,只是lua的not只能用于处理布尔值,没有像python那样的a not == b,只能not a == b 杂项运算符 运算符 描述 示例 … 连接两个字符串.惊了,连接字符串不能用+的,只能用这个… “草草草”…“我饿饿” : 草草草我饿饿 # 返回字符串或表长度的一元运算符 #“abc” : 3 Lua的循环 while循环 1234while(condition)do statement(s)end 1234567a = 10while( a &lt; 20 )do print("value of a:", a) a = a + 1end (惊了,lua不支持a += 1这种) for循环 1234for init, max/min value, incrementdo statement(s)end 上面代码中: init首先执行,只执行一次,此步骤允许声明和初始化任何循环控制变量(什么任何?) 接下来执行max/min.这是循环继续执行的最大值或最小值.它在内部创建条件检查,以比较初始值和最大/最小值 在执行for循环体之后,控制流会跳回increment/decrement语句.此语句用于更新循环控制变量. 再次评估条件.如果为真,则循环执行并且过程自身重复(循环体,然后递增步骤,然后再次调节).条件变为false后,for循环终止 1234for i = 1, 10, 1do print(i)end …这语法…我佛辣 顺便试了一下,lua用不着游标卡尺… repeat…until循环 与在顶部测试循环条件的for和while不同,lua的repeat…until循环在底部检查循环的条件. repeat…until循环类似while循环,但是repeat…until循环保证至少执行一次. 123456x = 100repeat x = x + 1 print(x)until x &gt; 10---101 循环控制声明 有break,好像没有continue Lua流程控制 1234if(boolean)then dosomethingend 123456if(boolean)then dosomethingelse dosomethingend 123456789if(boolean)then dosomgthingelseif(boolean)then dosomethingelse sosomethingend 注意: elseif后面需要then,else后面没有 Lua函数 Lua中编程语言中的方法定义一般形式如下: 1234567optional_function_scope function function_name( argument1, argument2, argument3........, argumentn)function_bodyreturn result_params_comma_separatedend 可选函数范围 使用local关键字来限制函数范围或者忽略该部分,使之成为一个全局函数 函数名称 函数的实体名称 参数 函数主体 返回 示例:max函数 12345678910function max(num1, num2) if (num1 &gt; num2) then result = num1; else result = num2; end return result;endprint(max(1,255)) 可变参数函数 使用…作为参数在lua中创建具有可变参数的函数. 12345678910function average(...) result = 0 local arg = &#123;...&#125; for i,v in ipairs(arg) do result = result + v end return result/#argendprint("The average is",average(0)) Lua迭代器 迭代器泛型 迭代器泛型提供集合中每个元素的键值对. 12345678array = &#123; "a", "b" &#125;for k, v in ipairs(array)do print(k, v)end--- 1 a--- 2 b 上面这个例子使用了Lua提供的默认的ipairs迭代器 在Lua中,使用函数来表示迭代器.基于这些迭代器函数中的状态维护,有两种主要类型: 无状态迭代器 这类迭代器不会保留任何状态. md.这个教程写的什么jb,以后再看 Lua表 表是lua中唯一可用的数据结构.使用表可用创建不同的类型,比如数组和字典. Lua使用关联数组,不仅可用数字编制索引,还可以使用除nil之外的字符串编制索引. 123a = &#123;&#125;a["a"] = 233print(a["a"]) 表示和用法 表称为对象,它既不是值也不是变量.Lua是哟构造函数{}来创建一个空表. 表操作 表连接 使用concat函数连接表 table.concat (table [, sep [, i [, j]]]) 12345678910fruits = &#123; "bbb", "ccc", "ddd" &#125;print(table.concat(fruits))--- bbbcccdddprint(table.concat(fruits, ", "))--- bbb, ccc, dddprint(table.concat(fruits, ", ", 2, 3))--- ccc, ddd 插入和删除 table.insert (table, [pos,] value) table.remove (table [, pos]) 1234567891011121314151617arr = &#123; "bbb", "ccc", "ddd" &#125;table.insert(arr,"aaa")print(table.concat(arr," "))--- bbb ccc ddd aaatable.insert(arr,1,"eee")print(table.concat(arr," "))--- eee bbb ccc ddd aaatable.remove(arr)print(table.concat(arr," "))--- eee bbb ccc dddtable.remove(arr, 3)print(table.concat(arr," "))--- eee bbb ddd 排序 12345arr = &#123; "e", "b", "d", "c", "a" &#125;print(table.concat(arr," "))table.sort(arr)print(table.concat(arr," "))]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs-learning]]></title>
    <url>%2Fcs-learning%2F</url>
    <content type="text"><![CDATA[C#数据类型 值类型 类型 描述 范围 默认值 bool 布尔值 True或False False byte 8位无符号整数 0到255 0 sbyte 8位有符号整数 -128到127 char 16位Unicode字符 U +0000 到U +ffff ‘\0’ decimal 128位精确的十进制值,28~29有效位数 (-7.9 * 10 ^ 28)/10 ^ (0 到 28) 0.0M short ushort int uint double float long ulong 引用类型 Object类型 对象(Object)类型是C#通用类型系统中所有数据类型的终极基类. Object类可以被分配给任何其他类型的值.但是在分配之前,需要先进行类型转换. 当一个值类型转换为对象类型时,被称为装箱,当一个对象类型转换为值类型时,被称为拆箱 12object obj;obj = 100; // 这是装箱 Dynamic类型 动态(Dynamic)类型变量可以存储任何类型 1dynamic a = 20; String类型 字符串(String)类型允许给变量分配任何字符串值. C#的字符串只能是双引号,不能单引号. 字符串前面加@,则该字符串的转义符()将被当做普通字符对待(就像python字符串前面加r似的) 12345Console.WriteLine("a\nb");// a// bConsole.WriteLine(@"a\nb");// a\nb 指针类型 **指针类型(Pointer types)**变量存储另一种类型的内存地址. 当一个代码块使用 unsafe 修饰符标记时，C#允许在函数中使用指针变量。不安全代码或非托管代码是指使用了指针变量的代码块。 1char* cptr; 类型转换 类型转换从根本上说是类型铸造,或者说是把数据从一种类型转换到另一种类型. 在C#中,类型转换有两种形式: 隐式类型转换 这些转换是C#默认的以安全方式进行的转换,不会导致数据的丢失.如,从小的整数转换为大的整数,从派生类转换为基类 显式类型转换 即强制类型转换.需要强制转换运算符,可能会造成数据丢失 类型转换方法 1234int i = 1;bool b = Convert.ToBoolean(i);Console.Write(b);// True 循环 foreach循环 使用foreach可以迭代数组或者一个集合对象 123456int[] i = new int[] &#123;114, 514, 1919, 810&#125;;foreach (var a in i)&#123; Console.Write(a); // 1145141919810&#125; 封装 Public Private Protected 允许子类访问它的基类的成员函数和成员变量. Internal 允许一个类将其成员变量和成员函数暴露给当前函数中的其他函数和对象 方法 定义 1234&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)&#123; Method Body&#125; 参数传递 方式 描述 值参数 复制参数的实际值给函数的形参.实参和形参使用的内存不同.形参值改变时不会影响实参. 引用传递 复制参数内存位置的引用给形参.当形参值改变时,会改变实参 输出参数 这种方式可以返回多个值(?) 按值传递 传参的默认方式. 123456789101112131415161718192021public void swap(int x, int y)&#123; int temp; temp = x; x = y; y = temp;&#125;static void Main(string[] args)&#123; Program program = new Program(); int x = 5, y = 6; Console.WriteLine($"&#123;x&#125;,&#123;y&#125;"); // 5,6 program.swap(x, y); Console.WriteLine($"&#123;x&#125;,&#123;y&#125;"); // 5,6&#125; 按引用传递 在C#中,使用ref关键字声明引用参数. 12345678910111213141516171819202122public void swap(ref int x, ref int y)&#123; int temp; temp = x; x = y; y = temp;&#125;static void Main(string[] args)&#123; Program program = new Program(); int x = 5, y = 6; Console.WriteLine($"&#123;x&#125;,&#123;y&#125;"); // 5,6 program.swap(ref x,ref y); Console.WriteLine($"&#123;x&#125;,&#123;y&#125;"); // 6,5&#125; 按输出传递参数 return语句可用于只从函数中返回一个值.但是,可以使用*输出参数来从函数中返回多个值. 输出参数会把方法输出的数据赋值给自己,其他方面与引用参数类似. 1234567891011121314151617public int divmod(int a, int b, out int c)&#123; int div = (int) (a / b); int mod = a % b; c = mod; return div;&#125;static void Main(string[] args)&#123; Program program = new Program(); int x = 11, y = 3; int div, mod; div = program.divmod(x, y, out mod); Console.WriteLine($"&#123;div&#125;,&#123;mod&#125;"); // 3,2&#125; 可空类型 C#提供了一个特殊的数据类型,nullable类型,可空类型可以表示其基础值正常范围内的值,在加上一个null值. 例如Nullable,读作可空的Int32. 在处理数据库和其他包含可能未赋值的元素的数据类型时,将null赋值给数值类型和布尔型的功能特别有用. 可空类型的声明 可空类型的声明语法如下: 1Int32? x; Null合并运算符 Null合并运算符用于定义可空类型和引用类型的默认值. Null合并运算符为类型转换定义了一个预设值,以防可空类型为Null. Null运算符吧操作数类型隐式转换成另一个可空(或不可空)的值类型的操作数的类型. 如果第一个数为null,则运算符返回第二个操作数的值,否则返回第一个操作数的值. 123456789int? a = 1;int x = a ?? 233;Console.WriteLine(x);// 1int? b = null;int y = b ?? 233;Console.WriteLine(y);// 233 数组 数组声明 1int[] a = new int[10]; 数组赋值 数组声明时赋值 声明时赋值可以省略数组大小. 12int[] a = new int[4] &#123;0, 1, 2, 3&#125;;int[] b = new int[] &#123;0, 1, 2, 3&#125;; 数组引用赋值 12int[] a = new int[4];a[1] = 2; 复制数组 这种情况下,目标和源会指向相同的内存位置. 12int[] a = new int[] &#123;0, 1, 2, 3&#125;;int[] b = a; 遍历数组 12345int[] a = new int[] &#123;0, 1, 2, 3&#125;;foreach (int v in a)&#123; Console.WriteLine(v);&#125; 结构体 12345678910struct A&#123; public int a; public String s; public int func(int x) &#123; return x + a; &#125;&#125;; 枚举 枚举是一组命名整型常量.枚举是使用enum关键字声明的. C#枚举是值类型,即 枚举包含自己的值,且不能继承或传递继承. 123var x = A.a;Console.WriteLine(x);// 0 类 析构函数 在程序结束前执行(大概?) 1234567class A&#123; ~A() &#123; Console.WriteLine("Cancel."); &#125;&#125; 类的静态成员 使用static关键字把类成员定义为静态. 当我们声明一个类成员为静态时,无论多少个类被创建,只会有一个改进静态类成员的副本. 静态变量用于定义常量,他们的值可以通过直接调用类而不需要创建类的实例来获取(无法通过实例来访问,只能通过类访问). 静态变量可以在成员函数或类的定义外部进行初始化,也可以在类的定义内部进行初始化.]]></content>
      <tags>
        <tag>废弃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第12章-屏幕后处理效果]]></title>
    <url>%2Fshader-r-screen-post-processing-effects%2F</url>
    <content type="text"><![CDATA[屏幕后处理效果(screen post-processing effects)是游戏中实现屏幕特效的常见方法. 建立一个基本的屏幕后处理脚本系统 屏幕后处理,指的是在渲染完整个场景得到屏幕图像后,再对这个图像进行一系列操作,实现各种屏幕特效. 这种技术可以为游戏添加很多的艺术效果.,例如景深(Depth of Field), 运动模糊(Motion Blur)等. 因此,想要实现屏幕后处理的基础在于得到渲染后的屏幕图像,即抓取屏幕,而Unity为我们提供了这样一个方便的接口:OnRenderImage函数: MonoBehaviour.OnRenderImage (RenderTexture src, RenderTexture dest) 当我们在脚本中声明此函数后,Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中,通过函数中的一系列操作后,再把目标渲染纹理,即第二个参数对应的渲染纹理显示到屏幕上. 在OnRenderImage函数中,我们通常是利用Graphics.Blit函数来完成对渲染纹理的处理. public static void Blit(Texture src, RenderTexture dest) public static void Blit(Texture src, RenderTexture dest, Material mat, int pass = -1) public static void Blit(Texture src, Material mat, int pass = -1) 其中,src对应了源纹理, 在屏幕后处理技术中,这个参数就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理. 参数dest是目标渲染纹理,如果它的值为null就会直接将结果显示在屏幕上. 参数mat是我们使用的材质,这个材质使用的Unity Shader将会进行各种屏幕后操作,而src纹理将会被传递给Shader中名为_MainTex的纹理属性. 参数pass的默认值为-1, 表示将会依次调用Shader内的所有Pass.否则,只会调用指定索引的Pass. 在默认情况下,OnRenderImage函数会在所有的不透明和透明的Pass执行完毕后被调用,一遍对场景中所有游戏对象产生影响.但有时,我们希望在不透明Pass执行完毕后就立即调用OnRenderImage函数,从而不对透明物体产生任何影响.此时,我们可以在OnRenderImage函数前添加ImageEffectOpaque属性来实现这样的目的.(将在13.4节遇到) 因此,要在Unity中实现屏幕后处理效果,过程通常如下: 首先 我们需要在摄像机中添加一个用于屏幕后处理的脚本. 在这个脚本中,我们会实现OnRenderImage函数来获取当前屏幕的渲染纹理. 然后 再调用Graphics.Blit函数使用特定的UnityShader来对当前图像进行处理,再把返回的渲染纹理显示到屏幕上. 对于一些复杂的屏幕特效,我们可能需要多次调用Graphics.Blit函数来对上一步的输出结果进行下一步处理… 但是,在进行屏幕后处理之前,我们需要检查一系列条件是否满足,例如当前平台是否支持渲染纹理和屏幕特效,是否支持当前使用的Unity Shader等. 为此,我们创建了一个用于屏幕后处理效果的基类,在实现各种屏幕特效时,我们只需要继承自该积累,在实现派生类中不同的操作即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using UnityEngine;using System.Collections;// 使在编辑器状态下也可以执行该脚本来查看效果[ExecuteInEditMode][RequireComponent (typeof(Camera))]public class PostEffectsBase : MonoBehaviour &#123; // 为了提前检查各种资源和条件是否满足,我们在Start函数中调用CheckResource函数 protected void CheckResources() &#123; bool isSupported = CheckSupport(); if (isSupported == false) &#123; NotSupported(); &#125; &#125; // Called in CheckResources to check support on this platform protected bool CheckSupport() &#123; if (SystemInfo.supportsImageEffects == false || SystemInfo.supportsRenderTextures == false) &#123; Debug.LogWarning("This platform does not support image effects or render textures."); return false; &#125; return true; &#125; // Called when the platform doesn't support this effect protected void NotSupported() &#123; enabled = false; &#125; protected void Start() &#123; CheckResources(); &#125; // 一些屏幕特效可能需要更多的设置,例如设置一些默认值等,可以重载Start,CheckResources或CheckSupport函数. // 由于每个品目后处理效果通常需要指定一个Shader来创建一个用于处理渲染纹理的材质,因此基类中也提供了这种方法: // Called when need to create the material used by this effect // CheckShaderAndCreateMaterial函数接受两个参数,第一个参数制定了该特效需要使用的Shader,第二个参数则是用于后期处理的材质. // 该函数首先检查Shader的可用性,检查通过之后就返回一个使用了该Shader的材质,否则返回null protected Material CheckShaderAndCreateMaterial(Shader shader, Material material) &#123; if (shader == null) &#123; return null; &#125; if (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader) return material; if (!shader.isSupported) &#123; return null; &#125; else &#123; material = new Material(shader); material.hideFlags = HideFlags.DontSave; if (material) return material; else return null; &#125; &#125;&#125; 在下面一节我们就会看到如何继承PostEffect.cs来创建一个简单的用于调整屏幕的亮度,饱和度和对比度的特效脚本. 调整屏幕的亮度,饱和度和对比度. 新建一个脚本,名BrightnessSaturationAndContrast.cs 12345678910111213141516171819202122232425262728293031323334353637383940using UnityEngine;using System.Collections;// 首先,继承PostEffectsBase类public class BrightnessSaturationAndContrast : PostEffectsBase &#123; // 声明使用的Shaser,并据此创建相应的材质. public Shader briSatConShader; // 指定的Shader private Material briSatConMaterial; // 创建的材质 public Material material &#123; // material的get函数调用了基类的CheckShaderAndCreateMaterial函数来得到对应的材质 get &#123; briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial); return briSatConMaterial; &#125; &#125; // 调整亮度,饱和度和对比度的参数. [Range(0.0f, 3.0f)] public float brightness = 1.0f; [Range(0.0f, 3.0f)] public float saturation = 1.0f; [Range(0.0f, 3.0f)] public float contrast = 1.0f; // 定义OnRenderImage函数来进行真正的特效处理 void OnRenderImage(RenderTexture src, RenderTexture dest) &#123; if (material != null) &#123; material.SetFloat("_Brightness", brightness); material.SetFloat("_Saturation", saturation); material.SetFloat("_Contrast", contrast); Graphics.Blit(src, dest, material); &#125; else &#123; Graphics.Blit(src, dest); &#125; &#125;&#125; 每当OnrenderI函数被调用时,它会检查材质是否可用.如果可用,就把参数传递给材质,再调用Graphics.Blit进行处理; 否则,直接把原图像显示到屏幕上,不做任何处理. 之后是Shader的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Shader "Unity Shaders Book/Chapter 12/Brightness Saturation And Contrast" &#123; Properties &#123; _MainTex ("Base (RGB)", 2D) = "white" &#123;&#125; // 声明用于调整亮度,饱和度和对比度的属性.这些值将会由脚本传递而得 // 事实上,我们可以省略这些属性声明,因为对于屏幕特效来说,它们使用的材质都是临时创建的,我们不需要在材质面板上调整参数,而是直接从脚本你传递给UnityShader _Brightness ("Brightness", Float) = 1 _Saturation("Saturation", Float) = 1 _Contrast("Contrast", Float) = 1 &#125; SubShader &#123; Pass &#123; // 屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片,为了防止它对其他物体产生影响,我们需要设置相关的渲染状态: // 关闭深度写入,为了防止其挡住在其后面渲染的物体 // 这些状态设置是屏幕后处理的Shader的标配 ZTest Always Cull Off ZWrite Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" sampler2D _MainTex; half _Brightness; half _Saturation; half _Contrast; struct v2f &#123; float4 pos : SV_POSITION; half2 uv: TEXCOORD0; &#125;; // 顶点着色器比较简单,只需进行必要的顶点变换并把正确的纹理传递给片元着色器 // TODO: 疑问:屏幕后渲染不是把模型都渲染到屏幕空间后再进行的么?为什么要把顶点坐标变换到剪裁空间? // 这里的appdata_img是unity内置的结构体,他只包含了图像处理时必须的顶点坐标和纹理坐标等变量. 可以在UnityCG.cginc中找到它的声明 // 抄下来://struct appdata_img//&#123;// float4 vertex : POSITION;// half2 texcoord : TEXCOORD0;// UNITY_VERTEX_INPUT_INSTANCE_ID//&#125;; v2f vert(appdata_img v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed4 renderTex = tex2D(_MainTex, i.uv); // Apply brightness fixed3 finalColor = renderTex.rgb * _Brightness; // Apply saturation fixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b; fixed3 luminanceColor = fixed3(luminance, luminance, luminance); finalColor = lerp(luminanceColor, finalColor, _Saturation); // Apply contrast fixed3 avgColor = fixed3(0.5, 0.5, 0.5); finalColor = lerp(avgColor, finalColor, _Contrast); return fixed4(finalColor, renderTex.a); &#125; ENDCG &#125; &#125; Fallback Off&#125; 边缘检测 边缘检测的原理是利用一些边缘检测算子对图像进行卷积(convolution)操作. 什么是卷积 在图像处理中,卷积指的是使用一个卷积核(kernel)对一张图片中的每个像素进行一些列操作. 卷积核通常是一个四方形网格结构,该区域的每个方格都有一个权重值.当对图像中的某个像素进行卷积时,我们会把卷积核的中心置于该像素上. 如图所示,翻转核之后再以此计算何种每个元素和其覆盖的图像的像素值的乘积并求和,得到的结果就是该位置的新像素值. 这样的操作虽然简单,但可以实现很多常见的图像处理效果,如图像模糊,边缘检测等. 例如,如果我们想多图像进行均值模糊,可以使用一个3x3的卷积核,核内每个元素的值均为1/9. 常见的边缘检测算子 如果相邻像素之间存在差别明显的颜色,亮度,纹理等属性,我们会认为它们之间应该有一条边界. 这种相邻像素之间的插值可以用梯度(gradient)来表示,可以想象得到,边缘处的梯度绝对值会比较大. 基于这样的理解,有几种不同的边缘检测算子(即用于边缘检测的卷积核)被先后提出来. 卷积操作的神奇之处在于卷积核. 它们都包含两个方向的卷积核,分别用于检测水平方向和竖直方向上的边缘信息. 在进行边缘检测时,我们需要对每个像素分别进行一次卷积计算,得到两个方向上的梯度值G(x)和G(y),而整体的梯度可按下面的公式计算而得: G = sqrt(G(x)**2 + G(y)**2) 由于开根号操作比较复杂,出于性能考虑,我们有时候会使用绝对值操作来代替开根号操作: G = |G(x)| + |G(y)| 得到梯度G后,我们就可以据此来判断哪些像素对应了边缘:梯度越大,越有可能是边缘. 实践: Sobel边缘检测算子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Shader "Unity Shaders Book/Chapter 12/Edge Detection" &#123; Properties &#123; _MainTex ("Base (RGB)", 2D) = "white" &#123;&#125; _EdgeOnly ("Edge Only", Float) = 1.0 _EdgeColor ("Edge Color", Color) = (0, 0, 0, 1) _BackgroundColor ("Background Color", Color) = (1, 1, 1, 1) &#125; SubShader &#123; Pass &#123; ZTest Always Cull Off ZWrite Off CGPROGRAM #include "UnityCG.cginc" #pragma vertex vert #pragma fragment frag sampler2D _MainTex; // XXX_TexelSize是Unity为我们提供的访问XXX纹理对应的每个纹素的大小. // 由于卷积需要对相邻区域内的纹理进行采样,因此我们需要利用_MainTex_TexSize来计算各个相邻区域的纹理坐标. uniform half4 _MainTex_TexelSize; fixed _EdgeOnly; fixed4 _EdgeColor; fixed4 _BackgroundColor; struct v2f &#123; float4 pos : SV_POSITION; // 位数为9的纹理数组,对应的是使用Sobel算子采样是需要的9个邻域纹理坐标 half2 uv[9] : TEXCOORD0; &#125;; v2f vert(appdata_img v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); half2 uv = v.texcoord; // _MainTex_TexelSize.xy和移动量相乘之后,才得到真正的坐标(大概这个意思) o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1); o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1); o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1); o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0); o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0); o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0); o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1); o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1); o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1); return o; &#125; // 取亮度值的函数 fixed luminance(fixed4 color) &#123; return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; &#125; // 使用Sobel算子对原图进行边缘检测的函数 half Sobel(v2f i) &#123; // 水平和竖直方向上的卷积核 const half Gx[9] = &#123;-1, 0, 1, -2, 0, 2, -1, 0, 1&#125;; const half Gy[9] = &#123;-1, -2, -1, 0, 0, 0, 1, 2, 1&#125;; half texColor; half edgeX = 0; half edgeY = 0; // 遍历⑨个像素 for (int it = 0; it &lt; 9; it++) &#123; // 采样之后计算亮度值 texColor = luminance(tex2D(_MainTex, i.uv[it])); // 亮度值与卷积核对应的权重相乘,叠加至各自的梯度值上 edgeX += texColor * Gx[it]; edgeY += texColor * Gy[it]; &#125; // edge越小,梯度越大,该点越可能是边缘 half edge = 1 - abs(edgeX) - abs(edgeY); return edge; &#125; fixed4 frag(v2f i) : SV_Target &#123; half edge = Sobel(i); // 混合 fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge); fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge); return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); &#125; ENDCG &#125; &#125; FallBack Off&#125; 需要注意的是,本例中的边缘检测仅仅利用了屏幕的颜色信息,而实际应用中,物体的纹理,阴影等信息均会影响边缘检测的结果,使得结果包含许多非预期的描边. 为了得到更准确的边缘嘻嘻,我们往往会在屏幕的深度纹理和法线纹理上进行边缘检测.(将会在13章实现) 高斯模糊 模糊的实现有许多种方法,例如均值模糊和中值模糊. 均值模糊同样使用了卷积操作,它只用的卷积核的各个元素值都相等,且相加等于1. 也就是说,卷积后得到的像素值是其邻域中的各个像素的平均值. 而中值模糊是选择邻域内对应所有像素排序后的中值替换掉原有的颜色. 一个更高级的模糊方法是高斯模糊. 高斯滤波 高斯模糊同样使用了卷积计算,它使用的卷积核名为高斯核. 高斯核是一个正方形大小的滤波核,其中每个元素的计算都是基于下面的高斯方程: 其中,打不出来的那个是标准方差(一般取值为1),x,y分别对应了当前位置到卷积核中心的整数距离. 要构建一个高斯核,我们只需要计算高斯核中各个位置对应的高斯值. 为了保证滤波后的图像不会变暗,我们需要对高斯核中的权重进行归一化,即让每个权重除以所有权重的和,这样可以保证所有权重的和为1. 因此,高斯函数中e前面的系数实际不会对结果有任何影响. 如图显示的是一个标准方差为1的5x5大小的高斯核 高斯方程很好的模拟了邻域每个像素对当前处理像素的影响程度–距离越近,影响越大. 高斯核维度越高,模糊程度越大.采用一个NxN的高斯核对图像进行卷积滤波,就需要NxNxWxH(W和H分别是图像的宽和高)次纹理采样.当N的大小不断增加时,采样的次数会变得非常巨大. 幸运的是,我们可以吧这个二维高斯函数拆分成两个一维函数.也就是说,我们可以使用两个一维的高斯核进行滤波,它们得到的结果跟直接使用二维高斯核进行滤波是一样的,但采样次数只需要2xNxWxH. 我们可以观察到,两个一维高斯核中包含很多重复的权重,实际上我们只需要计算三个权重即可. 实践: 高斯模糊 我们使用一个5x5的高斯核对原图进行高斯模糊. 我们将先后调用两个Pass,第一个Pass将会使用竖直方向的一维高斯核对图像进行滤波,第二个Pass再使用水平方向的一维高斯核对图像进行滤波,得到最终图像. 我们还将利用图像缩放来进一步提高性能,并通过调整高斯滤波的次数来控制模糊程度(次数越多,图像越模糊) 绑定在摄像头的C#代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using UnityEngine;using System.Collections;public class GaussianBlur : PostEffectsBase &#123; public Shader gaussianBlurShader; private Material gaussianBlurMaterial = null; public Material material &#123; get &#123; gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial); return gaussianBlurMaterial; &#125; &#125; // 迭代次数,次数越多,模糊程度越高 [Range(0, 4)] public int iterations = 3; // 模糊范围和缩放系数 // 这两项是为性能考虑的 // 模糊范围越大,模糊程度越高,但采样数不会受到影响.但过大的模糊范围可能会造成虚影. // 缩放系数越大,需要处理的像素数越少,同时也进一步提高模糊程度,但过大可能会是图像像素化. [Range(0.2f, 3.0f)] public float blurSpread = 0.6f; [Range(1, 8)] public int downSample = 2; void OnRenderImage (RenderTexture src, RenderTexture dest) &#123; if (material != null) &#123; //先利用缩放对图像进行降采样 int rtW = src.width/downSample; int rtH = src.height/downSample; // 与之前不同,这里使用了RenderTexture.GetTemporary函数分配了一块缓冲区. // 这是因为,高斯模糊需要调用两个Pass,我们需要使用一块中间缓存来存储第一个Pass执行完毕后得到的模糊结果. // 缓冲区的宽高为缩放后的宽高 RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0); buffer0.filterMode = FilterMode.Bilinear; Graphics.Blit(src, buffer0); // 迭代多次 for (int i = 0; i &lt; iterations; i++) &#123; material.SetFloat("_BlurSize", 1.0f + i * blurSpread); RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); // 第一个Pass Graphics.Blit(buffer0, buffer1, material, 0); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); // 第二个Pass Graphics.Blit(buffer0, buffer1, material, 1); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; &#125; Graphics.Blit(buffer0, dest); RenderTexture.ReleaseTemporary(buffer0); &#125; else &#123; Graphics.Blit(src, dest); &#125; &#125;&#125; Shader代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103Shader "Unity Shaders Book/Chapter 12/Gaussian Blur" &#123; Properties &#123; _MainTex ("Base (RGB)", 2D) = "white" &#123;&#125; _BlurSize ("Blur Size", Float) = 1.0 &#125; SubShader &#123; // CGINCLUDE和ENDCG定义的代码不需要包含在任何Pass中,在使用时,只需在Pass中指定需要的顶点和片元着色器即可. // 由于高斯模糊需要定义两个Pass,但他们使用的片元着色器的代码是完全相同的,使用CGINCLUDE可以避免我们编写两个完全一样的frag函数 CGINCLUDE #include "UnityCG.cginc" sampler2D _MainTex; half4 _MainTex_TexelSize; float _BlurSize; struct v2f &#123; float4 pos : SV_POSITION; half2 uv[5]: TEXCOORD0; &#125;; // 竖直方向上的顶点着色器代码 v2f vertBlurVertical(appdata_img v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); half2 uv = v.texcoord; o.uv[0] = uv; // 和_BlurSize相乘控制控制采样距离. o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize; o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize; o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize; o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize; return o; &#125; // 水平方向上的顶点着色器代码 v2f vertBlurHorizontal(appdata_img v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); half2 uv = v.texcoord; o.uv[0] = uv; o.uv[1] = uv + float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize; o.uv[2] = uv - float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize; o.uv[3] = uv + float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize; o.uv[4] = uv - float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize; return o; &#125; fixed4 fragBlur(v2f i) : SV_Target &#123; // 我们只需记录3个高斯权重 float weight[3] = &#123;0.4026, 0.2442, 0.0545&#125;; fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0]; for (int it = 1; it &lt; 3; it++) &#123; sum += tex2D(_MainTex, i.uv[it*2-1]).rgb * weight[it]; sum += tex2D(_MainTex, i.uv[it*2]).rgb * weight[it]; &#125; return fixed4(sum, 1.0); &#125; ENDCG ZTest Always Cull Off ZWrite Off Pass &#123; // 为Pass定义名字,可以在其他Shader中直接通过它们的名字来使用该Shader,而不用编写重复的代码 NAME "GAUSSIAN_BLUR_VERTICAL" CGPROGRAM #pragma vertex vertBlurVertical #pragma fragment fragBlur ENDCG &#125; Pass &#123; NAME "GAUSSIAN_BLUR_HORIZONTAL" CGPROGRAM #pragma vertex vertBlurHorizontal #pragma fragment fragBlur ENDCG &#125; &#125; FallBack "Diffuse"&#125; Bloom效果 Bloom是游戏中常见的一种屏幕效果,这种特效可以模拟真实摄像机的一种图像效果,它让画面中较亮的区域&quot;扩散&quot;到周围的区域,造成一种朦胧的感觉. 实现原理: 我们首先根据一个阈值提取出图像中较亮的区域,把他们存储在一张纹理中,再利用高斯模糊对这张渲染纹理进行模糊处理,模拟光线扩散的效果,最后再将其和原图像进行混合,得到最终效果.]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[油管直播转推流到B站]]></title>
    <url>%2Fyoutube-live-2-bili%2F</url>
    <content type="text"><![CDATA[ffmpeg下载地址: http://ffmpeg.zeranoe.com/builds/ youtube-dl下载地址: http://www.youtube-dl.org/ 123456789101112131415161718192021222324252627282930import os,platformdef liveTrans(fromPath, toPath, ffmpegPath, youtubeDlPATH): getRealFromPathCMD = youtubeDlPATH + " -g " + fromPath realFromPath = os.popen(getRealFromPathCMD).read().strip() if platformName[:7] == "Windows": postCMD = ffmpegPath + ' -i "' + realFromPath + '" -vcodec copy -acodec aac -f flv "' + toPath + '"' else: postCMD = ffmpegPath + ' -i "' + realFromPath + '" -c:v copy -c:a aac -b:a 320k -ar 44100 -strict -2 -f flv "' + toPath + '"' os.system(postCMD)if __name__ == '__main__': platformName = platform.platform() if platformName[:7] == "Windows": ffmpegPATH = r"D:\ProgramFiles\ffmpeg\bin\ffmpeg.exe" youtubeDlPATH = r"D:\ProgramFiles\ffmpeg\bin\youtube-dl.exe" else: ffmpegPATH = "ffmpeg" youtubeDlPATH = "youtube-dl" ffmpegPath = "ffmpeg" youtubeDlPath = "youtube-dl" liveTrans(fromPath="frompath here", toPath="toPath here", ffmpegPath=ffmpegPATH, youtubeDlPATH=youtubeDlPATH) emm,结果windows下报错连接不上youtube那个流的链接…新租的centos倒是可以…不知道是windows下的ffmpeg命令错了还是那个流不走代理… centos下安装ffmpeg和youtube-dl: 12345678yum install -y epel-releasesudo rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7sudo rpm –import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rosudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpmyum install -y ffmpegwget http://youtube-dl.org/latest/youtube-dl -O /usr/local/bin/youtube-dlchmod a+x /usr/local/bin/youtube-dl ffmpeg支持多个输出,linux下postCMD改为这个,边推流边保存到本地. 1postCMD = ffmpegPath + &apos; -i &quot;&apos; + realFromPath + &apos;&quot; -c:v copy -c:a aac -b:a 320k -ar 44100 -strict -2 -f flv &quot;&apos; + toPath + &apos;&quot;&apos; + &apos; -c:v copy -c:a aac -b:a 320k -ar 44100 -strict -2 -f flv &quot;./tmp.flv&quot;&apos; 参考: https://www.bilibili.com/read/cv1083415/ 顺便,ffmpeg裁剪视频(指时间上裁剪): 1./ffmpeg -i inputFilePath -ss 05:00 -c copy outputFilePath]]></content>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第11章-让画面动起来]]></title>
    <url>%2Fshader-r-moving%2F</url>
    <content type="text"><![CDATA[Unity Shader中的内置变量(时间篇) 名称 类型 描述 _Time float4 t是自该场景加载开始所经过的时间,4个分量分别是(t/20, t, 2t, 3t) _SinTime float4 t是时间的正弦值,4个分量的值分别是(t/8, t/4, t/2, t) _CosTime float4 t是时间的余弦值,4个分量的值分别是(t/8, t/4, t/2, t) unity_DeltaTime float4 dt是时间增量,4个分量分别是(dt, 1/dt, smoothDt, 1/smoothDt) 纹理动画 纹理动画在游戏中的应用非常广泛.尤其在各种资源都比较局限的移动平台上,我们往往会使用纹理动画来代替复杂的粒子系统等模拟各种动画效果 序列帧动画 最常见的纹理动画之一就是序列帧动画.序列帧动画的原理非常简单,它像放电影一样,依次播放一系列关键帧图像. 它的优点在于灵活性极强,不需要任何物理计算就能得到非常细腻的动画效果. 想要实现序列帧动画,我们先要提供一张包含了关键帧图像的图像. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Shader "Unlit/11.2"&#123; Properties &#123; _Color("Color Tint", Color) = (1, 1, 1, 1) _MainTex ("Image Sequence", 2D) = "white" &#123;&#125; // 水平方向和竖直方向包含的关键帧的个数 _HorizontalAmount ("Horizontal Amount", Float) = 4.0 _VerticalAmount ("Vertical Amount",Float) = 4.0 _Speed("Speed",Range(1, 100)) = 30 &#125; SubShader &#123; Tags &#123; "RenderType"="Transparent" "Queue"="Transparent" "IgnoreProjector"="True" &#125; Pass &#123; Tags &#123;"LightMode"="ForwardBase"&#125; ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; float _HorizontalAmount; float _VerticalAmount; float _Speed; struct a2v &#123; float4 vertex : POSITION; float2 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; &#125;; v2f vert (a2v v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_TARGET &#123; float time = floor(_Time.y * _Speed); float row = floor(time / _HorizontalAmount); float column = time - row * _HorizontalAmount; half2 uv = i.uv + half2(column, -row); uv.x /= _HorizontalAmount; uv.y /= _VerticalAmount; fixed4 c = tex2D(_MainTex, uv); c.rgb *= _Color; return c; &#125; ENDCG &#125; &#125;&#125; 滚动的背景 很多2D游戏都使用了不同的滚动背景来模拟游戏角色在场景中的穿梭.这些背景往往包含了多个层来模拟一种视差效果.而这些背景的实现往往就是利用了纹理动画. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Shader "Unity Shaders Book/Chapter 11/Water" &#123; Properties &#123; // 河流纹理 _MainTex ("Main Tex", 2D) = "white" &#123;&#125; // 主体颜色 _Color ("Color Tint", Color) = (1, 1, 1, 1) // 波动幅度 _Magnitude ("Distortion Magnitude", Float) = 1 // 波动频率 _Frequency ("Distortion Frequency", Float) = 1 // 波长倒数(这个值越大,波长越小) _InvWaveLength ("Distortion Inverse Wave Length", Float) = 10 // 纹理的移动速度 _Speed ("Speed", Float) = 0.5 &#125; SubShader &#123; // 一些SubShader在使用Unity批处理时会出现问题,这是可以通过DisableBatching标签指明是否对该SubShader使用批处理. // 批处理会合并所有相关的模型,而这些模型各自的模型空间就会丢失.而顶点动画需要在物体的模型空间下进行偏移. Tags &#123;"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" "DisableBatching"="True"&#125; Pass &#123; Tags &#123; "LightMode"="ForwardBase" &#125; ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; float _Magnitude; float _Frequency; float _InvWaveLength; float _Speed; struct a2v &#123; float4 vertex : POSITION; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; &#125;; v2f vert(a2v v) &#123; v2f o; float4 offset; offset.yzw = float3(0.0, 0.0, 0.0); offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude; o.pos = UnityObjectToClipPos(v.vertex + offset); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); o.uv += float2(0.0, _Time.y * _Speed); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed4 c = tex2D(_MainTex, i.uv); c.rgb *= _Color.rgb; return c; &#125; ENDCG &#125; &#125; FallBack "Transparent/VertexLit"&#125; 广告牌 另一种常见的顶点动画就是广告牌技术(Billboarding). 广告牌技术会根据视角方向来旋转一个被纹理着色的多边形(通常就是简单的四边形,这个多边形就是广告牌),使得多边形看起来好像总面对着摄像机. 广告牌技术的本质就是构建旋转矩阵,而我们知道一个矩阵需要三个基向量. 广告牌技术使用的基向量通常就是表面法线(normal),指向上的方向以及指向右的方向. 除此之外,我们还需要一个锚点(anchor location),这个锚点在旋转的过程中是固定不变的,以此来确定多边形在空间中的位置. 广告牌技术的难点在于,如何根据需求来构建3个相互正交的基向量. 计算过程通常是,我们首先会通过初始计算得到目标的表面法线(例如视角方向)和指向上的方向,而两者往往是不垂直的.但是,两者其中之一是固定的,例如模拟草丛时,我们希望广告牌的指向上的方向永远是(0, 1, 0),而法线方向应该随视角变化;而当模拟粒子效果时,我们希望广告牌的法线方向是固定的,即总指向视角方向,指向上的方向则可以发生变化. 我们假设法线方向是固定的,首先,我们根据初始的表面法线和指向上的方向来计算目标方向和指向右的方向(通过叉积操作): right = up X normal 对其归一化后,再由法线方向和指向右的方向计算出正交的指向上的方向: up’ = normal X right 如此,我们就可以得到用于旋转的三个正交基了.上图给出了计算过程的演示. 如果指向上的方向是固定的,计算过程也是类似. 实践: 广告牌 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Shader "Unity Shaders Book/Chapter 11/Billboard" &#123; Properties &#123; _MainTex ("Main Tex", 2D) = "white" &#123;&#125; _Color ("Color Tint", Color) = (1, 1, 1, 1) _VerticalBillboarding ("Vertical Restraints", Range(0, 1)) = 1 &#125; SubShader &#123; Tags &#123;"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" "DisableBatching"="True"&#125; Pass &#123; Tags &#123; "LightMode"="ForwardBase" &#125; ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _VerticalBillboarding; struct a2v &#123; float4 vertex : POSITION; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; &#125;; v2f vert (a2v v) &#123; v2f o; float3 center = float3(0, 0, 0); // 获取摄像机位置 float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1)); // 目标法线 float3 normalDir = viewer - center; // _VerticalBillboarding 调整固定法线还是固定指向上 // 当该值为1时,固定法线,为1时,固定向上方向为(0, 1, 0) normalDir.y =normalDir.y * _VerticalBillboarding; normalDir = normalize(normalDir); // 如果目标法线跟向上方向平行,两者的叉积则会出错. // 这里对目标法线的分量y进行了判断,以得到合适的向上方向. float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0); // 求向上方向和目标法线的垂线,即向右向量,并归一化 float3 rightDir = normalize(cross(upDir, normalDir)); // 因为固定了法线,所以重新求得向上向量 upDir = normalize(cross(normalDir, rightDir)); float3 centerOffs = v.vertex.xyz - center; // 这里卡了我好一会儿,以为是内积求投影来着,然而是分量(一个标量)和正交基相乘 float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z; o.pos = UnityObjectToClipPos(float4(localPos, 1)); o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; fixed4 c = tex2D (_MainTex, i.uv); c.rgb *= _Color.rgb; return c; &#125; ENDCG &#125; &#125; FallBack "Transparent/VertexLit"&#125; 注意事项 批处理 之前说的顶点动画必须关闭批处理,然而关闭批处理就会增多Draw Call,降低性能. 因此我们应该尽量避免使用模型空间下一些绝对位置和方向进行计算. 在广告牌的例子中,为了避免显式使用模型空间的中心点作为锚点,可以利用顶点颜色来存储每个顶点到锚点的距离值(smg),这种做法在商业游戏里很常见. 阴影 到时候再看吧. P239]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线动画推特预览]]></title>
    <url>%2Fazurlane-anime-tweet-preview%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>bot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第9章-更复杂的光照]]></title>
    <url>%2Fshader-r-complex-lighting%2F</url>
    <content type="text"><![CDATA[在之前的学习中,我们的场景之中都只有一个光源,且光源类型是平行光. 但在实际的游戏开发中,我们往往需要更多,更复杂的光源.更重要的是,我们要得到阴影. Unity的渲染路径 在Unity里,渲染路径(Rendering Path)决定了光照是如何应用到Unity Shader中的.因此,如果要和光源打交道,我们需要为每个Pass指定它们的渲染路径,只有为Shader正确地选择和设置了需要的渲染路径,该Shader的光照才会被正确执行. TODO: 看到这里,我就觉得跟我想要应聘的公司的工作不怎么搭了,先跳过]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第8章-透明效果]]></title>
    <url>%2Fshader-r-alpha-effect%2F</url>
    <content type="text"><![CDATA[Unity中,有两种方式实现透明效果: 一种是透明度测试(Alpha Test),这种方法无法得到真正的半透明效果;另一种方法是透明度混合(Alpha Blending) 对于不透明物体,不考虑渲染顺序也能得到正确的排序结果,这是由于强大的深度缓冲(depth-buffer,也称z-buffer)的存在. 在实时渲染中,深度缓冲是用于解决可见性问题的,它会解决哪些物体的哪些部分会被渲染在前面,哪些部分会被遮挡. 如果想要实现透明度效果,需要关闭深度写入. 透明度测试和透明度混合的原理如下: 透明度测试 采用一种&quot;极其霸道&quot;的机制,只要一个片元的透明度不满足条件(通常是小于某个阈值),那么它对应的片元就会被舍弃.被舍弃的片元将不会再做任何处理,也不会对颜色缓冲区造成影响.透明度测试是不需要关闭深度写入的,它和其他不透明物体最大的不同在于它会根据透明度舍弃一些片元.虽然简单,但其产生的效果会很极端:要么完全透明,要么不透明. 透明度混合 这种方法可以得到真正的半透明的效果.他会使用当前片元的透明度作为混合因子,与已经存储到颜色缓冲中的颜色进行混合,得到新的颜色.但是,透明度混合需要关闭深度写入,但没有关闭深度测试,这意味着如果使用透明度混合去渲染一个片元的话时,还是会比较它和当前缓冲区中的深度值.也就是说,对于透明度混合来说,深度缓冲是只读的. 渲染顺序 关闭深度写入很重要 使用透明度混合时,如果不关闭深度写入: 如果一个半透明表面背后的表面本是可以透过前面的表面被我妈看到的,但由于深度测试时判断结果是前面的半透明表面距离摄像机更近,导致后面的表面将会被剔除,我们无法透过半透明表面看到后面的物体了. 但是,我们破坏了深度缓冲的工作机制,而这是一个非常非常糟糕的事情,尽管我们不得不这样做: 关闭深度写入导致渲染顺序变得非常重要 不同的渲染顺序会得到的结果 假设场景里有两个物体:A和B,其中A是半透明物体,B是不透明物体,如图所示 第一种情况:先渲染B,再渲染A 由于不透明物体开启了深度测试和深度写入,而因此我们的深度缓存中没有任何有效数据,因此B首先会写入颜色缓冲和深度缓冲.随后我们渲染透明物体A,仍会进行深度测试,而我们发现A比B距离摄像头更近,所以我们会使用A的带透明度颜色和B的颜色进行混合,得到正确的半透明效果 第二种情况:先渲染A,再渲染B 渲染A时,深度缓冲中没有任何有效数据,因此A直接写入颜色缓冲.但不会写入深度缓冲.等渲染B时,进行深度测试的时候,深度缓冲中没有任何有效数据,会直接覆盖A的颜色,从视觉上来看,B出现在了A的前面,而这是错误的. 因此,渲染引擎一般都会对物体进行排序,再渲染.常见方法是: 先渲染所有不透明物体,并对他们开启深度测试和深度写入; 再把半透明物体按它们距离摄像机的远近排序,然后按照从后往前的顺序渲染这些半透明物体,并开启它们的深度测试(但关闭深度写入); 但是,这种方法仍然存在问题: 第二步中的渲染顺序,是依靠距离摄像机的深度判断的,而深度缓冲中的值其实是像素级别的,但是我们需要对物体级别进行排序.如图,会得到3个物体循环的情况. 尽管总有一些情况打乱我们的阵脚,但由于上述方法足够有效且容易实现,因此大多数游戏引擎都选用的这种方法. Unity Shader的渲染顺序 Unity为解决渲染问题提供了渲染队列(render queue)这一方案.我们可以使用Subshader的Queen标签来决定我们的模型将归于哪个渲染队列. Unity在内部使用了一系列整数索引来表示每个渲染队列,索引号越小就越先被渲染.在Unity5中,Unity提前定义了5个渲染队列. 名称 队列索引号 描述 Background 1000 背景 Geometry 2000 默认渲染队列,大多数物体使用这个队列,不透明物体使用这个队列. AlphaTest 2450 需要透明度测试的物体使用这个队列.在Unity5中它从Geometry队列中被单独分出来,这是因为在所有不透明物体轩然之后再渲染它们更高效. Transparent 3000 这个队列中的物体会在所有Geometry和AlphaTest物体渲染后,再按从后往前的顺序进行渲染.任何使用了透明度混合(例如关闭了深度写入的Shader)的物体都应该使用该队列(???) Overlay 4000 该队列用于实现一些叠加效果.任何需要在最后渲染的物体都应该使用该队列 因此,我们想要通过透明度测试实现透明效果,代码中应该包含类似下面的代码: 123456SubShader &#123; Tags&#123;"Queue" = "AlphaTest"&#125; Pass&#123; // ...... &#125;&#125; 如果我们想通过透明度混合来实现透明效果,代码中应该包含类似下面的代码: 1234567SubShader &#123; Tags&#123;"Queue" = "Transparent"&#125; Pass&#123; ZWrite Off // ...... &#125;&#125; 其中,ZWrite Off用于关闭深度写入.我们可以把它写在Pass或SubShader中. 透明度测试 目测用的不多,先不看 透明度混合 会使用当前片元的透明度作为混合因子,与已经存储在颜色缓冲中的颜色进行混合,得到新的颜色. 为了进行混合,我们需要使用Unity提供的混合命令–Blend. Blend是Unity提供的设置混合模式的命令.想要实现半透明效果就要把当前自身的颜色和已经存在于颜色缓冲中的颜色进行混合,混合时使用的函数就是由该指令决定的. 语义 描述 Blend Off 关闭混合 Blend SrcFactor DstFactor 开启混合,并设置混合因子.片元颜色会乘以SrcFactor,而已存在于颜色缓冲区的颜色会乘以DstFactor,然后把两者相加存入缓存. Blend SrcFactor DstFactor, SrcFactorA DstFactorA 和上面几乎一样,只是使用不同因子来混合透明通道 BlendOp BlendOption 并非是把源颜色和目标颜色简单相加后混合,而是使用BlendOption对它们进行其他操作 在本节中我们使用第二种语义来混合,需要注意的是,这个命令在设置混合因子的同时也开启了混合模式. 实践: 透明度混合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'Shader "Custom/8.4"&#123; Properties &#123; _Color ("Color", Color) = (1,1,1,1) _MainTex ("Albedo (RGB)", 2D) = "white" &#123;&#125; // AlphaScale用来控制整体透明度 _AlphaScale("Alpha Scale",Range(0,1)) = 1 &#125; SubShader &#123; // Queue标签指定队列 // RenderType标签设置为Transparent,用来指明该Shader是一个使用了透明度混合的Shader.RenderType标签通常被用于着色器替换功能. // IgnoreProject标签设为True,意味着整个Subshader不受投影器(Projectors)影响. Tags &#123; "Queue"="TransParent" "IgnoreProject"="True" "RenderType"="Transparent" &#125; Pass&#123; // 把LightMode标签设为ForwardBase,是为了让Unity能够按前向渲染路径的方式为我们正确提供各个光照变量. Tags &#123;"LightMode"="ForwardBase"&#125; // 关闭深度写入 ZWrite Off // 设置混合模式 Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float uv : TEXCOORD2; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); // alpha的值 return fixed4(ambient + diffuse,texColor.a * _AlphaScale); &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125; 当模型自身有复杂的遮挡关系或包含了复杂的非凸网格的时候,就会有各种各样因为排序错误而产生的错误的排序效果. 开启深度写入的半透明效果 上面的问题都是由于关闭了深度写入造成的,因为这样我们无法对模型进行像素级别的深度排序. 这是,我们可以想办法重新利用深度写入,让模型可以想半透明物体一样进行淡入淡出(淡入淡出什么鬼???).这就是下面的内容. 对于上面的问题,一种解决方法是使用两个Pass来渲染模型: 一个Pass开启深度写入,但不输出颜色,它的目的仅仅是为了把该模型写入深度缓冲中; 第二个Pass进行正常的透明度混合,由于上一个Pass已经得到了逐像素的正确的深度信息,该Pass就可以按照像素级别的深度排序的结果进行透明渲染. 但这种方法的缺点在于,多使用一个Pass会对性能造成一定的影响. 代码只需要在上面的那份代码中新加一个Pass即可,加在原Pass的上面 1234Pass&#123; ZWrite On ColorMask 0&#125; ColorMask用于设置颜色通道的写掩码(write mask),它的语义如下: ColorMask RGB | A | 0 | 其他任何R, G, B, A的组合 当ColorMask设为0时,意味着该Pass不写入任何颜色通道,即不会输出任何颜色. ShaderLab的混合命令 上面已经用了Blend命令进行混合,实际上混合还有其他很多用处,不仅仅是透明度混合. 混合的原理 当片元着色器产生一个颜色的时候,可以选择与颜色缓存中的颜色进行混合,这样一来,混合就和两个操作数有关:源颜色(source color)和目标颜色(destination color). 源颜色,用S表示,指的是片元着色器产生的颜色值; 目标颜色,用D表示,指的是从颜色缓冲中读取到的颜色值. 对它们进行混合后得到输出颜色,用O表示,它会重新写入到颜色缓存中. 需要注意的是,当我们谈及混合中的源颜色, 目标颜色和输出颜色时,他们都包含了RGBA四个通道,而并非仅仅的RGB通道. 开启混合 在Unity中,当我们使用Blend(Blend Off除外)命令时,除了设置混合状态外也开启的混合. 混合的等式和参数 混合是一个逐片元的操作,而且它是不可编程的,但是是高度可配置的. 我们可以设置混合时使用的运算操作,混合因子等来影响混合. 从源颜色S和目标颜色D得到输出颜色O必须适用一个等式来计算,这个等式叫做混合等式(Blending equation). 当进行混合时,我们需要使用两个混合等式,一个用于混合RGB通道,一个用于混合A通道. 当设置混合状态时,我们实际上设置的是混合等式中的操作和因子 在默认情况下,混合等式使用的操作都是加操作(我们也可以使用其他操作),我们只需要再设置一下混合因子即可. 由于需要两个等式,每个等式有两个因子(一个用于和源颜色相乘,一个用于和目标颜色相乘),因此一共需要4个因子. 下面是ShaderLab中设置混合因子的命令 命令 描述 Blend SrcFactor DstFactor 开启混合,并设置混合因子.源颜色会乘以SrcFactor,而目标颜色会乘以DstFactor,然后将两者相加后存入颜色缓冲中 Blend SrcFactor DstFactor,SrcFactorA DstFactor A 和上面几乎一样,只是使用不同因子来混合透明通道. 第一个命令只提供了两个因子,这意味着使用同样混合因子来混合RGB通道和A通道,即此时SrcFactorA等于SrcFactor, DstFactorA等于DstFactor. 这些混合因子的值可以取以下: 参数 描述 One 因子为1 Zero 因子为0 SrcColor 因子为源颜色值.当用于RGB通道的混合等式时,使用SrcColor的RGB分量作为混合因子;当用于A通道混合等式时,使用SrcColor的A分量作为混合因子. SrcAlpha 因子源颜色的透明度值(A通道) DstColor 因子为目标颜色值.当用于RGB通道的混合等式时,使用DstColor的RGB分量作为混合因子;当用于A通道混合等式时,使用DstColor的A分量作为混合因子. DstAlpha 尹子维目标颜色值的透明度值(A通道) OneMinusSrcColor 1 - SrcColor OneMinusSrcAlpha 1 - SrcAlpha OneMinusDstColor 1 - DstColor OneMinusDstAlpha 1 - DstAlpha 混合操作 可以使用ShaderLab的BlendOp BlendOption命令,来选择不同的混合操作 操作 描述 Add 将混合后的源颜色和目的颜色相加.是默认的混合操作.使用的混合等式是:O(rgb) = SrcFactor * S(rgb) + DstFactor * D(rgb)O(a) = SrcFactor * S(a) + DstFactor * D(a) Sub 用混合后的源颜色减去混合后的目标颜色.使用的混合等式是:O(rgb) = SrcFactor * S(rgb) - DstFactor * D(rgb)O(a) = SrcFactor * S(a) - DstFactor * D(a) RevSub 用混合后的目标颜色减去混合后的源颜色.使用的混合等式是:O(rgb) = DstFactor * D(rgb) - SrcFactor * S(rgb)O(a) = DstFactor * D(a) - SrcFactor * S(a) Min 使用源颜色和目标颜色中的较小值,是逐分量比较的.使用的混合等式是O(rgba) = (min(S®, D®, min(S(g), D(g), min(S(b), D(b), min(S(a), D(a))) Max 使用源颜色和目标颜色中的较大值,是逐分量比较的.使用的混合等式是O(rgba) = (max(S®, D®, max(S(g), D(g), max(S(b), D(b), max(S(a), D(a))) 混合因子命令通常是与混合因子命令一起工作的.但使用Min或Max混合操作时,混合因子实际上是不起任何作用的 常见的混合类型 通过混合操作和混合因子命令的组合,可以得到一些类似PhotoShop混合模式中的混合效果. 操作 效果 Blend SrcAlpha OneMinusSrcAlpha 正常(Normal), 即透明度混合 Blend OneMinusDstColor One 柔和相加(Soft Additive) Blend DstColor Zero 正片叠底(Multiply),即相乘 Blend DstColor SrcColor 两倍相乘(2x Multiply) BlendOp MinBlend One One 变暗(Darking) BlendOp MaxBlend One One 变亮(Lighting) Blend OneMinusDstColor One 滤色(Screen) Blend One OneMinusSrcColor 滤色,等同于上面的 Blend One One 线性减淡(Linear Dodge) 双面渲染的透明效果 现实生活中,如果一个物体是透明的,意味着我们不仅可以透过它看到其它物体的样子,也可以看到它的内部结构. 但在前面实现的透明效果中,我们无法观察到正方体的内部及其背面的形状. 这是因为,默认情况下,渲染引擎剔除了物体背面的渲染图元,而只渲染了物体的正面. 可以使用Cull指令来控制需要剔除哪个面的图元 在Unity中,Cull指令的语法如下: Cull Back | Front | Off 如果设置为Back,则背对摄像机的渲染图元不会被渲染,也就是默认情况下的剔除状态; 如果设为Front,则朝向摄像机的渲染图元不会被渲染; 如果设置为Off,就会关闭剔除功能,所有图元都会被渲染,但由于这时需要渲染的图元数目会成倍增加,因此除非是用于特殊效果(例如这里的透明效果),通常情况下是不会关闭剔除功能的. 实践: 透明度混合的双面渲染 我们想要得到正确的透明效果,渲染顺序是十分重要的,我们要保证图元要从前往后渲染. 对于透明度测试来说,由于我们没有关闭深度写入,所以可以利用深度缓冲按逐像素的细粒度进行深度排序,从而保证渲染的正确性. 然而透明度混合要关闭深度写入…我们就需要小心控制渲染顺序来得到正确的深度关系. 如果我们直接关闭剔除功能,我们就无法保证同一个物体的正面和背面渲染图元的渲染顺序,就有可能得到错误的半透明效果. 为此,我们选择把双面渲染的工作分为两个Pass: 第一个Pass只渲染背面,第二个Pass只渲染正面,由于Unity会顺序执行SubShader中的各个Pass,因此我们可以保证背面总是在正面之前被渲染. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125Shader "Custom/8.4"&#123; Properties &#123; _Color ("Color", Color) = (1,1,1,1) _MainTex ("Albedo (RGB)", 2D) = "white" &#123;&#125; _AlphaScale("Alpha Scale",Range(0,1)) = 1 &#125; SubShader &#123; Tags &#123; "Queue"="TransParent" "IgnoreProject"="True" "RenderType"="Transparent" &#125; Pass&#123; Tags &#123;"LightMode"="ForwardBase"&#125; // 剔除前面 Cull Front // 全是原Pass ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float uv : TEXCOORD2; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); return fixed4(ambient + diffuse,texColor.a * _AlphaScale); &#125; ENDCG &#125; Pass&#123; Tags &#123;"LightMode"="ForwardBase"&#125; // 剔除后面 Cull Back // 原Pass ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float uv : TEXCOORD2; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); return fixed4(ambient + diffuse,texColor.a * _AlphaScale); &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125;]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第7章-基础纹理]]></title>
    <url>%2Fshader-r-standard-texture%2F</url>
    <content type="text"><![CDATA[纹理的最初目的是使用一张图片来控制模型的外观.使用纹理映射(texture mapping)技术,我们可以把一张图片&quot;黏&quot;在模型表面,逐纹素(texel)地控制模型的颜色 在美工人员建模的时候,通常会在建模软件中利用纹理展开技术把纹理映射坐标(texture-mapping coordinates)存储在每个顶点上. 单张纹理 实践 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788Shader "Custom/7.1"&#123; Properties &#123; _Color ("Color Tint", Color) = (1, 1, 1, 1) // 声明一个2D纹理 _MainTex ("Main Tex", 2D) = "white" &#123;&#125; _Specular ("Specular", Color) = (1, 1, 1, 1) _Gloss ("Gloss", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; "LightMode"="ForwardBase" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; // _MainTex的名字不是随意起的,在Unity中我们使用纹理名_ST来声明某个纹理的属性. // 其中ST是缩放(scale)和平移(translation)的缩写. // 可以在材质面板的纹理属性调整这些值控制材质的平移和缩放. float4 _MainTex_ST; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; // 会把第一组纹理存储到该变量中 float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; // 使用纹理缩放和偏移属性对顶点纹理坐标进行变换 o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; // 或使用unity的内置函数 // o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); // 用tex2D对纹理进行采样 // 第一个参数是需要被采样的纹理,第二个参数是float2类型的纹理坐标 // 返回计算得到的纹素值 fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack "Specular"&#125; 纹理的属性 Texture Type 书上讲的TextureType好像过时了,现在是这样的: 这里使用最普通的texture,在后面的法线纹理一节,我们会使用Normal map类型,在后面的章节中,我们还会看到Cubemap等高级纹理类型. 我们之所以要为纹理选择合适的类型,是因为只有这样才会让Unity知道我们的意图,为Unity Shader传递正确的纹理,并在一些情况下让Unity对该纹理进行优化 Alpha Source 如果选择了From Gray Scale,那么透明通道的值将会由每个像素的灰度值生成. 关于透明效果会在第8章讲到 Wrap Mode 当纹理坐标超过[0, 1]返回后将会如何被平铺. Repeat下,纹理将会重复. Clamp下将会对纹理进行截取. Filter Mode 决定了当纹理由于变换而产生拉伸时将会采用哪种滤波模式. Filter Mode支持三种模式: Point, Bilinear, Trilinear.它们得到的图片滤波效果会依次提升,但需要消耗的性能也依次增大 纹理滤波会影响放大或缩小纹理时得到的图片的质量. 纹理的缩小过程比放大更复杂一些.缩小时,原纹理中的多个像素将会对应一个目标像素.纹理缩小更加复杂的原因在于我们往往需要处理抗锯齿问题,一个最常使用的方法就是使用多级渐远纹理(mipmapping)技术. 多级渐远纹理技术将原纹理提前用滤波处理来得到很多更小的图像,形成一个图像金字塔,每一层都是对上一层图像降采样的结果.这样在实时运行时,就可以快速得到结果像素. 例如当摄像机较远的时候,可以直接使用较小的纹理. 缺点是需要使用一定空间用于存储这些多级渐远纹理,通常会多占33%的内存空间. 在Unity中,我们可以在纹理导入面板中,首先将texture type选择成advanced,再勾选Generate Mip Maps即可开启多级渐远纹理技术. 这张图是,从一个倾斜角度观察一个网格结构的地板时,使用不同的Filter Mode(同时也使用了多级渐远纹理技术)得到的效果. 在内部实现上,Point模式使用了最邻近(nearest neighbor)滤波.在放大或缩小时,它的采样像素数目通常只有一个,因此图像看起来可能会有像素风格的效果. 而Bilinear滤波则使用了线性滤波,对于每个像素,它会找到四个临近像素,然后对它们进行线性插值混合后得到最终像素,因此图像看起来模糊了. 而Trilinear滤波几乎是和Bilinear一样的,只是Trilinear还会在多级渐远纹理之间进行了混合.如果一张纹理没有使用多级渐远纹理技术,那么Trilinear得到的结果就和Bilinear的完全一样了. 通常,我们选择Bilinear滤波格式.需要注意的是,有时我们不希望纹理看起来是模糊的,例如一些类似棋盘的纹理,我们希望它是像素风的,这时我们可能会选用Point模式. 纹理的最大尺寸和纹理模式 当我们在不同平台发布游戏时,需要考虑目标平台的纹理尺寸和质量问题.Unity允许我们为不同目标平台选择不同的分辨率. 如果导入的纹理大小超过了Max Texture Size的设置值,那么Unity将会把该纹理缩放为这个最大分辨率. 理想情况下,导入的纹理可以是非正方形的,单长宽应该是2的幂.如果使用了非2的幂的大小的纹理,那么这些纹理往往会占用更多的内存空间,而且CPU读取该纹理的速度也会下降.有一些平台甚至不支持这种NPOT纹理,这时Unity在内部会把它缩放成最近的2的幂大小. 而Format则决定了Unity内部使用哪种格式来存储该纹理.如果我们将Texture Type设置为Advanced,那么会有更多的Format供我们选择. 凹凸映射 凹凸映射的目的是使用一张纹理来修改模型表面的法线,以便模型提供更多的细节. 这种方法不会真的改变顶点位置,只是是模型看起来凹凸不平 高度纹理 使用一张高度图来实现凹凸映射 高度图中存储的是强度值(intensity),它用于表示模型表面局部的海拔高度. 颜色越浅表明该位置的表面越向外凸起,越深表明该位置的表面越向里凹. 这种方法的优点是比较直观.我们可以从高度图明确的知道一个模型表面的凹凸情况. 缺点是计算更加复杂,在实时计算中不能直接得到表面法线,而是由像素的灰度值计算而得.因此需要消耗更多的性能. 法线纹理 法线纹理中存储的是表面的法线方向.由于法线方向的分量范围在[-1, 1],而像素的分量在[0, 1],因此我们需要做一个映射,通常使用的映射是: pixel = (normal + 1)/2 这要求我们在Shader中对法线纹理进行纹理采样后,还需要对结果进行一次反映射的过程,以得到原先的法线方向.反映射的过程实际就是使用上面映射函数的逆函数: normal = pixwl * 2 - 1 由于方向是相对于坐标空间来说的,那么法线纹理存在哪个坐标空间中呢? 模型空间的法线纹理和切线空间的法线纹理 模型空间的法线纹理 object-space normal map 将修改后的模型空间的表面法线存储在一张纹理中. 切线空间的法线纹理 tangent-space normal space 对于模型的每个顶点,他都有一个属于自己的切线空间. 这个切线空间的原点就是顶点本身,而z轴就是顶点的法线方向,x轴是顶点的切线方向,而y轴可由法线和切线的叉积而得,也被称为副切线(bitangent). 映射到纹理上的区别 从图可以看出,模型空间下的法线纹理看起来是五颜六色的,而是因为所有法线所在的坐标空间是同一个坐标空间,即模型空间,而每个点存储的法线方向是各异的. 有的是(0, 1, 0),映射后存储到纹理中就对应了RGB(0.5, 1, 0.5),浅绿色;有的是(0, -1, 0),映射后存储到纹理中对应了RGB(0.5,0,0.5)的紫色. 而切线空间下的法线纹理几乎全部都是浅蓝色.这是因为,每个发现方向所在的坐标空间是不一样的,即表面每点各自的切线空间. 这种法线纹理其实是存储了每个点在各自的切线空间中的法线扰动方向. 也就是说,如果一个点的法线方向不变,那么它在它的切线空间中,新法线方向就是z轴方向,即(0,0,1),经过映射后存储在纹理中就对应了RGB(0.5, 0.5, 1)的浅蓝色. 如何选择 实际上,法线本身存储在哪个空间都是可以的,但问题是,我们的目的是计算光照而非单纯的计算法线. 而选择哪个空间,意味着我们需要把不同的信息转换到相应的坐标系中. 例如,如果选择了切线空间,我们需要把从法线纹理中得到的法线方向从切线空间转换到世界空间或其他空间中. 总体来说,用模型空间来存储法线的优点如下: 实现简单,更佳直观 我们甚至不需要模型原始的法线和切线等信息,也就是说,计算更少.生成它也很简单.而如果要生成切线空间下的法线纹理,由于模型的切线一般是和UV方向相同,因此想要得到效果比较好的法线映射就要求纹理映射也是连续的 边界平滑 在纹理坐标的缝合处和尖锐的边角部分,可见的突变(缝隙)较少.这是因为模型空间下的法线纹理存储的是统一坐标系下的法线信息.因此在边界上通过插值得到的法线可以平滑变换.而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的,可能会在边缘处或尖锐部分造成更多的可见缝合现象 但使用切线空间有更多优点: 自由度很高. 模型空间下的法线纹理记录的是绝对的法线信息,仅可用于创建它时的那个模型,而应用到其他模型上效果就完全错误了.而切线空间下的法线纹理记录的是相对法线信息,即便把该纹理应用到一个完全不同的网格上,也可以得到一个合理的效果. 可进行UV动画. 比如我们可以移动一个纹理的UV坐标来实现一个凹凸移动的效果,但使用模型空间下的法线纹理会得到完全错误的结果.这种UV动画经常在水或者火山熔岩这种类型的物体上会经常用到. 可压缩 由于切线空间下的法线纹理中法线z方向总是正方向,因此我们可以仅存储XY方向,而推导出Z方向.而模型空间下的法线纹理由于每个方向都是可能的,因此必须存储3个方向的值不可压缩. 实践 实践 : 在切线空间下计算光照模型 在片元着色器中通过纹理采样得到切线空间下的法线,然后再与切线空间下的视角,光照方向进行计算,得到最终的光照效果. 为此,我们需要在顶点着色器中把视角方向和光照方向从模型空间变换到切线空间中.即我们需要知道模型空间到切线空间的变换矩阵.这个矩阵的逆矩阵,即从切线空间变换到模型空间的变换矩阵,是很容易求得的: 我们在顶点着色器中按切线(x轴),副切线(y轴),法线(z轴)的顺序按列排列即可得到(数学原理见4.6.2节).在4.6.2节我们已经知道,如果一个变换仅存在旋转和平移变换,那么这个矩阵的转置矩阵就等于它的逆矩阵,而从切线空间到模型空间的变换正是符合这样的要求的变换.因此,我们把切线(x轴),副切线(y轴),法线(z轴)的顺序按行排列(因为转置了),即可得到模型空间到切线空间的变换矩阵. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Shader "Custom/7.1"&#123; Properties &#123; _Color ("Color Tint", Color) = (1, 1, 1, 1) _MainTex ("Main Tex", 2D) = "white" &#123;&#125; // 法线纹理的属性 // "bump"是Unity内置的法线纹理. // Bump Scale用于控制凹凸程度,当它为0时,意味着法线纹理不对光照产生任何影响 _BumpMap ("Normal Map", 2D) = "bump"&#123;&#125; _BumpScale ("Bump Scale", Float) = 1.0 _Specular ("Specular", Color) = (1, 1, 1, 1) _Gloss ("Gloss", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; // 切线方向赋给tangent float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); // uv的xy分量存储_MainTex的纹理坐标 // zw分量存储_BumpMap的纹理坐标 // 在回忆一下,_Name_ST的xy代表的是缩放值,zw代表偏移值 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; // 实际上,_MainTex和_BumpMap使用同一组纹理坐标就行了,可以减少差值寄存器的使用数目. // o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.xy = o.uv.zw; // 计算副切线.后面乘以v.tangent.w是决定副切线的方向 float3 binormal = cross(normalize(v.normal),normalize(v.tangent.xyz)) * v.tangent.w; // 把切线(x轴),副切线(y轴),法线(z轴)的顺序按行排列来得到模型空间到切线空间的变换矩阵rotation float3x3 rotation = float3x3(v.tangent.xyz,binormal,v.normal); // 把光照和视角方向变换到切线空间中 o.lightDir = mul(rotation,ObjSpaceLightDir(v.vertex)).xyz; o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex)).xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target&#123; fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); // 利用tex2D对_BumpMap进行采样 // 法线纹理中存储的是法线经过映射后得到的像素值,因此我们要把它们反映射回来 fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw); fixed3 tangentNormal; tangentNormal = UnpackNormal(packedNormal); // 乘以凹凸度来得到xy分量. tangentNormal.xy *= _BumpScale; // 由xy向量计算z向量 tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy,tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack "Specular"&#125; 实践 : 在世界空间下计算光照模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596Shader "Unity Shaders Book/Chapter 7/Normal Map In World Space" &#123; Properties &#123; _Color ("Color Tint", Color) = (1, 1, 1, 1) _MainTex ("Main Tex", 2D) = "white" &#123;&#125; _BumpMap ("Normal Map", 2D) = "bump" &#123;&#125; _BumpScale ("Bump Scale", Float) = 1.0 _Specular ("Specular", Color) = (1, 1, 1, 1) _Gloss ("Gloss", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; "LightMode"="ForwardBase" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float4 TtoW0 : TEXCOORD1; float4 TtoW1 : TEXCOORD2; float4 TtoW2 : TEXCOORD3; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; fixed3 worldNormal = UnityObjectToWorldNormal(v.normal); fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; // Compute the matrix that transform directions from tangent space to world space // Put the world position in w component for optimization o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; // Get the position in world space float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); // Compute the light and view dir in world space fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos)); fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos)); // Get the normal in tangent space fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); bump.xy *= _BumpScale; bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy))); // Transform the narmal from tangent space to world space bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir)); fixed3 halfDir = normalize(lightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(bump, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack "Specular"&#125; :TODO 好焦躁啊,这些先留着不看… 渐变纹理]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第6章-Unity中的基础光照]]></title>
    <url>%2Fshader-r-standard-lighting%2F</url>
    <content type="text"><![CDATA[光照基础 我们要模拟真实的光照环境来生成一张图像,需要考虑三种物理现象: 首先,光线从光源中被发射出来 然后,光线和场景中的一些物体相交: 一些光线被物体吸收了,而另一些光线被散射到其他方向 最后,摄像机吸收了一些光,产生了一张图像 光源 在光学里,我们用辐照度(irradiance)来量化光. 对于平行光来说,它的辐照度可通过计算在垂直于l的单位面积上单位时间内穿过的量来得到. 吸收和散射 光线由光源发射出来后,就会与一些物体相交,通常,相交的结果有两个:散射(scattering)和吸收(absorption) 散射只改变光线的方向,但不改变光的密度和颜色.而吸收只改变光线的密度和颜色,而不改变光线的方向. 光线在物体表面经过散射后,有两种方向: 一种将会散射到物体内部,这种现象被称为折射(refraction)或透射(transmission); 另一种将会散射到外部,这种现象被称为反射(reflection). 对于不透明物体,折射进入物体内部的光线还会继续与内部颗粒进行相交,其中一部分光线最后会重新发射出物体表面.而另一些则会被物体吸收.那些从物体表面重新发射出的光线将具有和入射光线不同的分布和颜色. 为了区分这两种不同的散射方向,我们在光照模型中使用了不同的部分来计算它们: 高光反射(specular)部分表示物体表面是如何反射光线的 漫反射(diffuse)部分则表示有多少光线会被折射,吸收和散射出表面. 根据入射光线的数量和方向,我们可以计算出射光线的数量和方向,我们常用出射度(exitance)来描述它. 辐照度和出射度之间只满足先行关系的,而他们之间的比值就是材质的漫反射和高光反射属性 着色 着色(shading)是指,根据材质属性(如漫反射属性等),光源信息(如光源方向,辐照度等),使用一个等式去计算沿某个观察方向的出射度的过程.我们也把这个等式称为光照模型(Lighting Model). 不同光照模型有不同的目的.例如一些用于描述粗糙的物体表面,一些用于描述金属表面等. BRDF光照模型 我们已经了解了光线在和物体表面相交时会发生那些现象. 当已知光源位置和方向,视角方向时,我们就需要知道一个表面是如何和光照进行交互的. 而BRDF(Bidirectional Reflection Distribution Function)就是用来回答这些问题的. 当给定模型的一个点时,BRDF包含了对该点外观的完整的描述.在图形学中,BRDF大多使用同一个数学公式来表示,并且提供了一些参数来调整材质属性. 通俗来讲,当给定入射光线和辐照度后,BRDF可以给出在某个方向上的光照能量分布. 本章设计BRDF都是对真实场景进行理想化和简化后的模型.它们并不能真实地反映物体和光照之间的交互,这些光照模型被称为是经验模型. 标准光照模型 标准光照模型只关心直接光照(direct light),也就是那些从光源发射出来照射到物体表面后,经过物体表面的一次反射直接进入摄像机光线. 它的基本方法是,把进入摄像机内的光线分为4部分,每个部分使用一种方法来计算它的贡献度. 自发光(emissive) 这个部分用于描述当给定一个方向时,一个表面本身会向该方向发射多少辐射量.如果没有全局光照(global illuminiation)技术,这些自发光的表面并不会真的照亮物体,只是它本身看起来更亮了而已. 高光反射(specular) 这个部分用于描述当光线从光源照射到模型表面时,该表面会在完全镜面反射方向散射出多少辐射量. 漫反射(diffuse) 这个部分用于描述,当光线从光源照射到物体表面时,该表面会向每个方向散射多少辐射量. 环境光(ambient) 用于描述其他所有间接光照 环境光 虽然标准光照模型的重点在于直接光照,但在真实世界中,物体也可以被间接光照(indirect light)所照亮. 间接光照是指,光线通常会在多个物体之间反射,最后进入摄像机. 在标准光照模型中,我们使用环境光来近似模拟间接光照. 环境光的计算非常简单,它通常是一个全局变量,场景中的所有物体都使用这个环境光 自发光 光线可以直接由光源发射进入摄像机,而不需要经过其他物体的反射.标准光照模型使用自发光来计算这个部分的贡献度. 它的计算也很简单,就是直接使用了材质的自发光颜色. 通常在实时渲染中,自发光的表面往往并不会照亮周围的表面,也就是说,这个物体并不会被当做是一个光源. Unity 5引入的全局光照则可以模拟这类自发光物体对周围物体的影响(详见18章) 漫反射 漫反射光照是用于对那些被物体表面完全随机散射到各个方向的辐射度进行建模的. 在漫反射中,视角的位置是不重要的,因为反射是完全随机的,因此可以认为在任何反射方向上的分布都是一样的. 但是入射光线的角度很重要. 漫反射光照符合兰伯特定律(Lambert’s law): 反射光线的强度与表面法线和光源方向之间的夹角的余弦值成正比 高光反射 这里的高光反射是一种经验模型,也就是说,它并不完全符合真实世界中的高光反射现象.他可以用于计算那些沿着完全镜面反射方向被反射的光线,这可以让物体看上去是有光泽的,例如金属材质 计算高光反射需要知道的信息比较多,如表面法线,视角方向,光源方向,反射方向等. 高光反射的数学表达式太多了,还是看书吧,书上p124 逐像素还是逐顶点 在片元着色器中计算光照模型,被称作逐像素光照(per-pixel lighting) 在顶点着色器中计算光照模型,被称作逐顶点光照(per-vertex lighting) 逐像素光照 在逐像素光照中,我们会以每个像素为基础,得到它的法线(可以通过对顶点法线的插值得到,也可以从法线纹理中采样得到),然后进行光照模拟的计算. 这种在面片之间对顶点法线进行插值的技术被称为Phone 着色(Phone Shader),也被称为Phone插值或法线插值着色技术,这不同于之前的Phone模型. 逐顶点光照 也被称为高洛德着色(Gouraud Shading). 在逐顶点光照中,我们在每个顶点上计算光照,然后在渲染图元内部进行线性插值,最后输出成颜色. 因为顶点数目往往远小于像素数目,因此逐顶点光照的计算量往往要小于逐像素光照. 但是,由于逐顶点光照依赖于线性插值来得到像素光照,因此,当光照模型中有非线性计算(入计算高光反射)时,逐顶点光照就会出问题. 而且,由于逐顶点光照会在渲染图元内部对顶点颜色进行插值,这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值.这在某些情况下会产生明显的棱角, 总结 标准光照模型并不完全符合真实世界中的光照现象,但由于它的易用性,计算速度和得到的效果都比较好,因此仍在被广泛使用. 标准光照模型也被称为Phone光照模型或Blinn-Phong光照模型. 但这种模型也有很多局限性. 首先,很多重要的物理现象无法用该光照模型表现出来,例如菲涅尔反射(Fresenel reflection). 其次,该模型是各项同性(isotropic)的,也就是说,当我们固定视角和光源方向,旋转这个表面时,反射不会发生任何改变.但有些表面是各向异性(anisotropic)的,如拉丝金属,毛发等. Unity中的环境光和自发光 在Shader中,我们只需通过UNITY_LIGHTMODEL_AMBIENT就可以得到环境光的颜色和强度信息. 计算自发光只需要在片元着色器输出最后的颜色之前,把材质的自发光颜色添加到输出颜色上即可. 漫反射光照模型 实践: 逐顶点漫反射光照 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse",Color) = (1, 1, 1, 1) &#125; Subshader&#123; Pass&#123; // 使用Tags指明该Pass的光照模式 // 只有定义了正确的LightMode,我们才能得到一些Unity的内置光照变量,如后面的_LightColor0 Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag // 需要使用UNity中的内置光照变量,如后面的_lightColor0,还需包含Unity的内置文件Lighting.cginc #include "Lighting.cginc" fixed4 _Diffuse; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : POSITION; float3 color : COLOR; &#125;; v2f vert(a2v v)&#123; v2f o; // 将顶点坐标从模型空间变换到剪裁空间中 o.pos = UnityObjectToClipPos(v.vertex); // 通过UNITY_LIGHTMODEL_AMBIENT获得环境光部分 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; // 将法线变换至世界坐标空间下,并进行归一化 fixed3 worldNormal = normalize(mul(v.normal,(float3x3)unity_WorldToObject)); // 光源方向由_WorldSpaceLightPos0得到,并进行归一化 float3 worldLight = normalize(_WorldSpaceLightPos0.xyz); // 通过_LightColor0访问光源的颜色和强度信息 // saturate是Cg提供的一种函数,它的作用是把参数截取到[0, 1]的范围内. // 将 法线 与 光源方向 的 点积 与 光源的颜色 和 强度 以及 材质的漫反射颜色 相乘 得到 最终的漫反射光照部分 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight)); // 将环境光与漫反射光部分相加,得到最终的光照结果 o.color = ambient + diffuse; return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125; 顶点着色器部分解释: 在第一行,我们首先定义了返回值o.我们已经重复过很多次,顶点着色器最基本的任务就是把顶点位置从模型空间转换到剪裁空间中. 书上比较过时的方法是 使用Unity内置的 模型世界投影矩阵 UNITY_MATRIX_MVP 来完成这样的坐标变换.实际打代码的时候,编辑器顶部出现了一行 1// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' ,然后对应部分的代码也被改了. 接下来是真正计算漫反射光照的部分.回忆一下,为了计算漫反射我们需要知道4个参数. 在前面的步骤中,我们已经知道了材质的漫反射颜色_Diffuse以及顶点法线v.normal.还需要知道光源的颜色和强度信息以及光源方向. 通过Unity提供的内置变量 _LightColor0 来访问该Pass处理光源的颜色和强度信息 通过Unity提供的内置变量 _WorldSpaceLightPos0 得到光源方向 需要注意的是,这里对光源方向的计算不具有通用性.当前场景下,我们假设只有一个光源且其类型是平行光. 如果场景下有多个光源并且类型是点光源等其他类型,直接使用_WorldSpaceLightPos0就不能得到正确的结果. 计算光源方向与法线的点积时,只有两者处于统一坐标空间下,他们的点积才有意义. 于是在这里我们选用世界空间. 在得到世界空间下的法线和光源方向后,我们需要对它们进行归一化操作; 在得到它们的点积的结果后,我们需要防止这个结果为负值.为此,我们选用saturate函数. saturate函数是Cg提供的一种函数,它的作用是可以把参数截取到[0, 1]范围内. 再将 法线 与 光源方向 的 点积 与 光源的颜色 和 强度 以及 材质的漫反射颜色 相乘 得到 最终的漫反射光照部分 最后,将环境光与漫反射光部分相加,得到最终的光照结果 思考:法线 与 光源方向 的 点积 与 光源的颜色 和 强度 以及 材质的漫反射颜色 相乘 的意义 我的理解: 法线 与 光源方向 的 点积 的结果,应该就是光源方向在法线方向上的投影值. 这个投影值的意义是漫反射的强度.顶点法线正对入射光线,漫反射效果最强.顶点法线与入射光线的夹角大于90度,则完全没有漫反射效果.之后再以强度与光源颜色和材质颜色相乘,得到漫反射颜色. 对于细分度较高的模型,逐顶点光照已经可以得到比较好的光照效果了.但对于一些细分程度较低的模型,逐顶点光照就会出现一些视觉问题. 例如这里就有点锯齿 实践: 逐像素漫反射光照 相较于上个人逐顶点光照,把对光照的计算从vert函数转到了frag函数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse",Color) = (1, 1, 1, 1) &#125; Subshader&#123; Pass&#123; Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Diffuse; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; &#125;; v2f vert(a2v v)&#123; // vert函数中仅传递光照方向及法线方向 v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = mul(v.normal,(float3x3)unity_WorldToObject); return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; // 计算在frag函数中进行 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); fixed3 color = ambient + diffuse; return fixed4(color, 1); &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125; 逐像素光照更佳平滑 但是,即使用了逐像素漫反射光照,有一个问题仍然存在:在光照无法到达的区域,模型外观通常是黑的,没有任何明暗变化,这会使模型的背光区域看起来就像一个平面一样,失去模型细节表现. 实际上我们可以通过添加环境光来得到非全黑的效果,但即便这样也无法解决背光面明暗一样的缺点.为此,有一种改善技术被提出来,这就是半兰伯特(Half Lambert)光照模型 半兰伯特光照模型 在上面的光照实例中使用的光照模型也被称为兰伯特光照模型,因为它符合兰伯特定于----在平面某点漫反射光强与该反射点的法向量和入射角的余弦值成正比. 半兰伯特光照模型是在原兰伯特光照模型上修改的. 与原兰伯特模型相比,版兰伯特光照模型没有使用saturate函数截取法向量和光照方向的点积,而是使点积结果乘以一个值再加上一个值.通常情况下.这两个值都为0.5,通过这种方式就能把法向量和光照方向的点积的结果范围从[-1, 1]映射到[0, 1]范围内. 对于模型的背光面,原兰伯特模型中点积结果将映射到同一个值,即0处;而半兰伯特模型中,背光面也会有明暗变化. 需要注意的是,半兰伯特光照模型是没有任何物理依据的,仅仅是一个视觉加强. 球的背光面在两种光照模型下的表现: 原兰伯特光照模型 半兰伯特光照模型 高光反射光照模型 基本光照模型中高光反射部分的计算公式: 计算高光反射需要四个参数:入射光线的颜色和强度,材质的高光反射系数,视角方向以及反射方向.其中,反射方向可以由表面法线和光源方向计算而得. 上述计算很简单,更幸运的是,Cg提供了计算反射方向的函数:reflect. 函数: reflect(i,n) 参数: i: 入射方向;n:法线.可以是float,float2,float3等. 实践: 逐顶点高光反射光照 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse", Color) = (1, 1, 1, 1) // 材质的高光反射颜色 _Specular("Specular", Color) = (1, 1, 1, 1) // 高光区域的大小 _Gloss("Gloss",range(8.0,256)) = 20 &#125; Subshader&#123; Pass&#123; Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; fixed3 color : COLOR; &#125;; v2f vert(a2v v)&#123; v2f o; // 漫反射部分 o.pos = UnityObjectToClipPos(v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject)); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); // 入射光线关于法线的反射方向. // 由于Cg的reflect函数的入射方向要求是由光源指向交点处的,因此我们要把worldLightDir取反后再传给reflect函数 fixed3 reflectDir = normalize(reflect(-worldLightDir,worldNormal)); // 世界空间下的 摄像机坐标与顶点坐标相减,得到视角方向 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld,v.vertex).xyz); // 根据公式和所有的四个参数,带入公式得到高光反射的光照部分. fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir,viewDir)),_Gloss); o.color = ambient + diffuse + specular; return o; &#125;; fixed4 frag(v2f i) : SV_TARGET&#123; return fixed4(i.color,1.0); &#125;; ENDCG &#125; &#125; // fallback调成Specular FallBack "Specular"&#125; 使用逐顶点的方法得到的高光效果,高光部分及其不平滑:因为高光部分的计算是非线性的,而在顶点着色器中在进行插值的过程是线性的,破坏了原计算的非线性关系. 实践: 逐片元高光反射光照 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse", Color) = (1, 1, 1, 1) // 材质的高光反射颜色 _Specular("Specular", Color) = (1, 1, 1, 1) // 高光区域的大小 _Gloss("Gloss",range(8.0,256)) = 20 &#125; Subshader&#123; Pass&#123; Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz; return o; &#125;; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir,worldNormal)); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir,viewDir)),_Gloss); return fixed4((ambient + diffuse + specular),1.0); &#125;; ENDCG &#125; &#125; // fallback调成Specular FallBack "Specular"&#125; 将计算转移到了frag函数中. Blinn-Phong光照模型 上面是Phong光照模型的实现. 而Blinn模型没有使用反射方向,而是引入了一个新的矢量 而Blinn模型计算高光反射的公式是 理解:理解个尖儿,貌似也是个没有物理根据的经验模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse", Color) = (1, 1, 1, 1) _Specular("Specular", Color) = (1, 1, 1, 1) _Gloss("Gloss",range(8.0,256)) = 20 &#125; Subshader&#123; Pass&#123; Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz; return o; &#125;; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); // 新增 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); // 新增 fixed3 halfDir = normalize(worldLightDir + viewDir); // 公式 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal,halfDir)),_Gloss); return fixed4((ambient + diffuse + specular),1.0); &#125;; ENDCG &#125; &#125; FallBack "Specular"&#125; 效果: 谔谔,总感觉区别不大…高光范围比上面大了点…]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第5章-开始Unity Shader学习之旅]]></title>
    <url>%2Fshader-r-start%2F</url>
    <content type="text"><![CDATA[最简单的顶点/片元着色器 顶点/片元着色器的基本结构 12345678910111213141516171819202122232425262728293031323334Shader "MyShaderName"&#123; Properties&#123; // 属性 &#125; SubShader&#123; // 针对显卡A的SubShader Pass&#123; // 设置渲染状态和标签 // 开始Cg代码片段 CGPROGRAM // 该代码片段的编译指令 #pragma vertex vert #pragma fragment frag // Cg代码写在这里 // 结束Cg代码段 ENDCG // 其他设置 &#125; // 其他需要的Pass &#125; SubShader&#123; // 针对显卡B的SubShader &#125; // 上面的SubShader都失败后用于回调的Unity Shader Fallback "VertexLit"&#125; 其中最重要的是Pass语义块.我们绝大多数的代码都是写在Pass语义块中的. 下面是一个实际的最简单的顶点/片段着色器 12345678910111213141516171819202122Shader "Custom/myShader"&#123; SubShader&#123; Pass&#123; CGPROGRAM // 告诉unity,vert函数包含了顶点着色器代码,frag函数包含了片段着色器代码. #pragma vertex vert #pragma fragment frag float4 vert(float4 v : POSITION) : SV_POSITION &#123; return mul(UNITY_MATRIX_MVP, v); // MVP矩阵是: 当前的模型矩阵·观察矩阵·投影矩阵,用于将顶点/方向矢量从模型空间变换到剪裁空间 &#125; fixed4 frag() : SV_Target&#123; return fixed4(1.0, 1.0, 1.0, 1.0); &#125; ENDCG &#125; &#125;&#125; vert函数里的POSITION和SV_POSITION都是Cg/HLSL中的语义(semantics),是不可省略的,它们告诉系统用户需要哪些输入值,以及用户的输出是什么.例如这里: POSITION告诉Unity,把模型顶点坐标填充到参数v SV_POSITION告诉Unity,顶点着色器的输出是剪裁空间中的顶点坐标 如果没有这些语义来限定输入和输出参数的话,渲染器就完全不知道用户的输入和输出是什么,因此会得到错误的结果. 本例中的frag函数没有任何输入,它的输出是一个fixed4类型的变量,并且使用了SV_Target语音进行限定. SV_Targrt也是HLSL中的一个系统语义,它等同于告诉渲染器,把用户的输出颜色存储到一个渲染目标(render target)中,这里将输出到默认的帧缓存中. 模型数据从哪来 如想要得到更多的模型数据(如顶点的纹理坐标和法线方向),我们需要为顶点着色器定义一个结构体作为输入参数. 1234567891011121314151617181920212223242526272829303132333435Shader "Custom/MyShader"&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag // 使用一个结构体来定义顶点着色器的输入 struct a2v&#123; // POSITION语义告诉Unity, 用模型空间的顶点坐标填充vertex变量 float4 vertex : POSITION; // NORMAL语义告诉Unity, 用模型空间的法线方向填充normal变量 float3 normal : NORMAL; // TEXCOORD0语义告诉Unity, 用模型的第一套纹理坐标填充texcoord变量 float4 texcoord : TEXCOORD0; &#125;; float4 vert(a2v v) : SV_POSITION&#123; // 使用v.vertex来访问模型空间的顶点坐标 return mul(UNITY_MATRIX_MVP, v.vertex); &#125; fixed4 frag() : SV_Target&#123; return fixed4(1.0, 1.0, 1.0, 1.0); &#125; ENDCG &#125; &#125;&#125; 在上面的代码中,我们声明了一个新的结构体a2v,它包含了顶点着色器需要的模型数据. 对于顶点着色器的输入,Unity支持的语义有: POSITION, TANGENT, NORMAL, TEXCOORD0, TEXCOORD1, TEXCOORD2, TEXCOORD3, COLOR 等. 为了新建一个结构体, 我们必须使用如下格式来定义它: 12345struct StructName&#123; Type Name : Semantic; Type Name : Semantic; ......&#125; 然后,我们又修改了vert函数的输入类型为a2v. a表示应用(application),v表示顶点着色器(vertex shader),a2v的意思就是把数据从应用阶段传递到顶点着色器中. 顶点着色器和片元着色器的通信 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Shader "Custom/Myshader"&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; // 使用一个结构体来定义顶点着色器的输出 struct v2f &#123; // SV_POSITION语义告诉Unity, pos里包含了顶点在剪裁空间中的位置信息 float4 pos : SV_POSITION; // COLOR0语义可以用于存储颜色信息 fixed3 color : COLOR0; &#125; v2f vert(a2v v)&#123; // 声明输出的结构 v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); // v.normal包含了顶点的法线方向, 其分量在[-1.0, 1.0] // 下面的代码将分量范围映射到了[0.0, 1.0] // 存储到o.color中传递给片元着色器 o.color = v.normal * 0.5 + float3(0.5, 0.5, 0.5); return o; &#125; fixed4 frag(v2f i) : SV_Target&#123; // 将插值后的i.color显示到屏幕上 return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125;&#125; 在上面代码中,我们定义了一个v2f结构体在顶点着色器和片元着色器之间传递信息. 顶点着色器的输出结构中,必须包含一个语义为SV_POSITION的变量,否则渲染器会无法得到剪裁空间中的顶点坐标,也就无法将颜色渲染到屏幕上. 至此,我们完成了顶点着色器和片元着色器之间的通信. 需要注意的是,顶点着色器是逐顶点调用的,而片元着色器是逐片元调用的,所以片元着色器的输入实际上是把顶点着色器的输出进行插值得到的结果. 如何使用属性 通过材质,我们可以方便地调节Unity Shader中的参数,从而随时调整材质的效果. 这些参数需要卸载Properties语义块中. 123456789101112131415161718192021222324252627282930313233343536373839404142Shader "Custom/Myshader"&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag // 在Cg代码中,我们需要定义一个与属性的名称和类型都匹配的变量 fixed4 _Color; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; fixed3 color : COLOR0; &#125; v2f vert(a2v v)&#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.color = v.normal * 0.5 + float3(0.5, 0.5, 0.5); return o; &#125; fixed4 frag(v2f i) : SV_Target&#123; float3 c = i.color; // 使用-Color属性控制输出颜色 c *= _Color.rgb; return fixed4(c, 1.0); &#125; ENDCG &#125; &#125;&#125; 在上面的代码中,我们首先添加了Properties语义块,并在其中声明了一个属性_Color,它的类型是Color,初始值是(1.0, 1.0, 1.0, 1.0). 为了在Cg代码中使用,我们还需要在Cg代码片段中提前定义一个新的变量,这个变量的名称和类型必须与Properties中的属性定义相匹配 ShaderLab属性类型 Cg变量类型 Color, Vector float4, half4, fixed4 Range, Float float, half, fixed 2D sampler2D Cube samplerCube 3D sampler3D 有时会遇到uniform 1uniform fixed4 _Color; uniform关键词是Cg中修饰变量和参数的一种修饰词,它仅仅用于提供一些关于该变量的初始值是如何指定和存储的相关信息. 在Unity Shader中,uniform关键词是可以省略的 (所以uniform到底是个啥啊草) Unity内置文件和变量 为了方便开发者的编码过程,Unity提供了很多内置文件,这些文件包含了很多提前定义的变量,函数和宏等. 内置的包含文件 包含文件(include file),是类似于C++头文件的一种文件.在Unity中,它们的文件后缀是.cginc. 在编写shader时,我们可以用#include把这些文件包含进来,这样我们就可以使用Unity为我们提供的一些非常有用的变量和帮助函数.例如: 1234CDPROGRAM// ...#include "UnityCG.cginc"// ... unity\Editor\Data\CGIncludes文件夹包含了一些内置组件或功能需要的UnityShader. CDIncludes中主要的包含文件及它们的用处: 文件名 描述 UnityCG.cginc 包含了最常使用的帮助函数,宏和结构体等 UnityShaderVriables.cginc 在编译Unity Shader时,会被自动包含进来.包含了许多内置的全局变量,如UNITY_MATRIX_MVP等 Lighting.cginc 包含了各种内置的关照模型,如果包含的是表面着色器的话会自动包含进来 HLSLSupport.cginc 在编译Unity Shader时,会被自动包含进来.声明了许多跨平台编译的宏和定义 除这些之外,Unity5引入了许多新的重要的包含文件,如UnityShaderVariables.cginc, UnityStandardCore.cginc等,这些包含文件用于实现基于物理的渲染,我们会在18章再次遇到它们 UnityCG.cginc是我们最常接触的一个包含文件.它提供了很多结构体和函数方便我们编写Shader.例如,我们可以直接使用UnityCG.cginc中预定义的结构体作为顶点着色器的输入和输出. 名称 描述 包含的变量 appdata_base 可用于顶点着色器的输入 顶点位置,顶点法线,第一组纹理坐标 appdata_tan 可用于顶点着色器的输入 顶点位置,顶点切线,顶点法线,第一组纹理坐标 appdata_full 可用于顶点着色器的输入 顶点位置,顶点切线,顶点法线,四组(或更多)纹理坐标 appdata_img 可用于顶点着色器的输入 顶点位置,第一组纹理坐标 v2f_img 可用于顶点着色器的输出 裁剪空间中的位置 除了结构体外,UnityCG.cginc也提供了一些常用的帮助函数 函数名 描述 float3 WorldSpaceViewDir(float4 v) 输入一个模型空间中的顶点位置,返回世界空间中从该点到摄像机的观察方向 float3 ObjSpaceViewDir(float4 v) 输入一个模型空间中的顶点位置,返回模型空间中该点到摄像机的观察方向 float3 WorldSpaceLightDir(float4 v) 仅可用于前向渲染中.输入一个模型空间中的顶点位置,返回世界空间中从该点到光源的光照方向.没有被归一化 float3 ObjSpaceLightDir(float4 v) 仅可用于前向渲染中.输入一个模型空间中的顶点位置,返回模型空间中从该点到光源的光照方向.没有被归一化 float3 UnityObjectToWorldNormal(float3 norm) 把法线方向从模型空间变换到世界空间中 float3 UnityObjectToWorldDir(float3 dir) 把方向矢量从模型空间变换到世界空间中 float3 UnityWordToObjectDir(float3 dir) 把方向矢量从世界空间变换到模型空间中 内置的变量 Unity还提供了用于访问时间,光照,雾效和环境光等目的的变量. 这些内置变量大多位于UnityShaderVariables.cginc中,与光照有关的内置变量还会位于Lighting.cginc, AutoLighting.cginc等文件中. 后面遇到再详细讲解 Unity提供的Cg/HLSL语义 语义 语义就是一个赋给Shader的输入和输出的字符串,这个字符串表达了这个参数的含义.通俗地讲,这些语义可以让Shader知道从哪里读取数据,并把数据输出到哪里. 语义在Cg/HLSL的Shader流水线中是不可或缺的.需要注意的是,Unity并没有支持所有语义. 通常情况下,这些输入输出变量并不需要有特别的意义.也就是说,我们可以自行决定这些变量的用途. 在DX 10之后,有一种新的语义类型,就是系统数值语义(system-value semantics).这类语义是以SV开头的,SV代表的含义就是系统数值(system-value).这些语义在渲染流水线中有特殊的含义.例如我们用SV_POSITION语义去修饰顶点着色器的输出变量pos,那么就表示pos包含了可用于光栅化的变换后的顶点坐标. 这些语义修饰的变量时不可以随意赋值的,因为流水线需要使用它们来完成特定的目的.例如渲染引擎会把用SV_POSITION修饰的变量经过光栅化后显示在屏幕上. 有时会看到同一个变量在不同的Shader里面使用了不同的语义修饰.例如,一些Shader会使用POSITION而非SV_POSITION来修饰顶点着色器的输出.SV_POSITION是DirectX 10中新引入的系统数值语义,在绝大多数平台上,它和POSITION是等价的,但在某些平台(例如索尼PS4)上必须使用SV_POSITION来修饰顶点着色器的输出.否则无法让Shader正常工作. 因此,对于这些有特殊含义的变量我们最好使用SV开头的语义进行修饰. Unity支持的语义 从应用阶段传递模型数据给顶点着色器时Unity支持的常用语义 语义 描述 POSITION 模型空间中的顶点位置,通常是float4类型 NORMAL 顶点法线,通常是float3类型 TANGENT 顶点切线,通常是float4类型 TEXCOORDn 该顶点的纹理坐标.通常是float2或float4类型 COLOR 顶点颜色,通常是fixed4或者float4类型 其中TEXCOORDn是指TEXCOORD0,TEXCOORD1…其中n的数目是和Shader Model有关的,例如一般在Shader Model2(即Unity默认编译到的Shader Model版本)和Shader Model3中,n等于8,而在Shader Model5中,n等于16. 通常情况下,一个模型的纹理坐标数一般不超过2,我们往往只使用TEXCOORD0和TEXCOORD1. 在Unity中内置的数据结构体appdata_full中,它最多使用了6个纹理坐标 从顶点着色器传递数据给片元着色器时Unity使用的常用语义 语义 描述 SV_POSITION 裁剪空间中的顶点坐标,结构体中必须包含一个用该语义修饰的变量. COLOR0 通常用于输出第一组颜色信息,但不是必须的 COLOR1 通常用于输出第二组颜色信息,但不是必须的 TEXCOORD0~TEXCOORD7 通常用于输出纹理坐标,但不是必须的 上面的语义中,除了SV_POSITION是有特殊的含义外,其他语义对变量的含义没有明确的要求.也就是说,我们可以存储任意值到这些语义描述变量中. 通常,如果我们需要把一些自定义的数据从顶点着色器传递给片元着色器,一般选用TEXTURE0等 片元着色器输出时Unity支持的常用语义 语义 描述 SV_Target 输出值将会存储到渲染目标(render target)中 如何定义复杂的变量类型 上面提到的语义绝大部分用于描述标量或矢量类型的变量 下面的代码给出了一个使用语义来修饰不同类型的变量的例子: 1234567struct v2f&#123; float4 pos : SV_POSITION; fixed3 color0 : COLOR0; fixed4 color1 : COLOR1; half value0 : TEXCOORD0; float2 value1 : TEXCOORD1;&#125;; 关于何时使用哪些变量类型,我们会在5.7.1节给出一些建议.但需要注意的是,一个语义可以使用的寄存器只能处理4个浮点值. 因此,如果我们想要定义矩阵类型,如float3X4等变量就需要使用更多的空间.一种方法是,将这些变量拆分成多个变量,例如对于float4X4的矩阵类型,我们可以拆分成4个float类型的变量,每个变量存储了矩阵中的一行数据. Debug 书上P111 渲染平台的差异 书上p115 Shader整洁 float, half还是fixed 类型 精度 float 最高精度浮点值,通常使用32位来存储 half 中等精度浮点值,通常使用16位来存储,精度是-60,000 ~ 60,000 fixed 最低精度浮点值,通常使用11位来存储,精度是-2.0~2.0 上面的精度范围并不是绝对正确的,尤其是在不同平台和GPU上,他们的实际精度可能和上面给出的范围不一致.通常来讲. 大多数现代的桌面GPU会把所有计算都按最高的浮点精度进行计算.也就是说,float,half,fixed在这些平台上实际是等价的.这意味着我们在PC上很难看出因为half和fixed精度不同而带来的不同. 但在移动平台的GPU上,它们的确会有不同的精度范围.而且不用精度的浮点值的运算速度也会有差异.因此,我们应该确保在真正的移动平台上试验我们的Shader fixed精度实际上只在一些较旧的移动平台上有用,大多数现代GPU上,它们内部把fixed和half当成同样精度来对待. 尽管有上面的不同,单一个基本建议是,尽可能使用精度较低的类型,因为这可以优化Shader的性能,这一点在移动平台上尤其重要.从它们的大体的值域范围来看,我们可以使用 fixed类型来存储颜色和单位矢量 half存储更大的数据 最差的情况再使用float 如果我们的目标是移动平台,一定要确保在真实的手机上测试我们的Shader. 关于移动平台的优化技术,更多内容见16章 规范语法 在5.6.2节,我们提到了DirectX平台对Shader的语义有更加严格的要求.这意味着,如果我们要发布到DirectX平台上就需要使用更严格的语法. 例如,使用和变量类型相匹配的参数数目来对变量进行初始化. 避免不必要的计算 如果我们毫无节制地在Shader(尤其是片元着色器)中进行了大量计算,那么我们可能很快就会收到Unity的错误提示: temporary register limit of 8 exceeded 或 Arithmetic instruction limit of 64 exceeded; 65 arithmetic instructions needed to compileprogram 这样的错误太多是因为我们在Shader中进行了大量的运算,使得需要的临时寄存器数目或指令数目超过了当前可支持的数目. 不同的Shader Target,不同的着色器阶段,我们可使用的临时寄存器和指令数目都是不同的. 通常,我们可以通过指定更高级的Shader Target来消除这些错误. 指令 描述 #pragma target2.0 默认的Shader Target等级,相当于Direct3D上的Shader Model2.0,不支持对顶点纹理的采样,不支持显式的LOD纹理采样等 #pragma target3.0 相当于Direct3D 9 上的Shader Model 3.0, 支持对顶点纹理的采样等 #pragma target4.0 相当于Direct3D 10 上的Shader Model 4.0,支持几何着色器等 #pragma target5.0 相当于Direct3D11上的Shader Model 5.0 Shader Model是由微软提出的一套规范,通俗地理解就是它们决定了Shader中各个特性和能力.这些特性和能力体现在Shader能使用的运算指令数目,寄存器个数等各个方面.Shader等级越高,Shader的能力就越大. 虽然更高级的Shader Target可以让我们使用更多的临时寄存器和运算指令,但一个更好的方法是尽可能减少Shader中的运算,或者通过预计算的方式来提供更多的数据. 慎用分支和循环语句 if-else,for,while这些流程控制指令在GPU上的实现和在CPU上大不相同.在最坏的情况下,我们花在一个分支语句的时间相当于运行所有分支语句的时间.因此不提倡在Shader中使用流程控制语句. 如果我们的Shader中使用了大量的流程控制语句,那么这个Shader的性能可能会成倍下降. 一个解决方法是,我们应尽量把计算向流水线上端移动.例如把片段着色器中的计算放到顶点着色器中,或者直接在CPU中进行预计算,再把结果传递给Shader. 实在要用到分支语句时: 分支判断语句中使用的条件变量最好是常数,即在Shader运行过程中不会发生变化. 每个分支中包含的操作指令尽可能少 分支嵌套层数尽可能少 不要除以0 Shader中,除以0不会报错.注意.]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第3章-Unity Shader 基础]]></title>
    <url>%2Fshader-r-unity-shader%2F</url>
    <content type="text"><![CDATA[UnityShader概述 unity中的shader Standard Surface Shader 会产生一个包含了标准光照模型(使用了Unity5中新添加的基于物理的渲染方法,详见第18章)的表面着色器模板 Unlit Shader 会产生一个不含光照(单包含雾化效果)的基本顶点/片段着色器 ImageEffect Shader 为我们实现各种屏幕文件.这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算,而不在这本书的讨论范围内(草) UnityShader的结构 SubShader Subshader中定义了一系列的Pass一级可选的状态和标签的设置. 每个Pass定义了一次完整的渲染流程,但如果pass的数目过多,往往会造成渲染性能的下降.因此,我们应尽量使用小数目的Pass. 状态和标签同样可以在Pass声明.不同的是,SubShader中的一些标签设定是特定的.也就是说,这些标签设置和Pass中使用的标签是不一样的.而对于状态设置来说,其使用的语法是相同的.但是,如果我们在SubShader中进行了这些设置,那么将会用于所有Pass 状态设置 ShaderLab提供了一系列渲染状态的设置指令,这些指令可以设置显卡的各种状态.例如是否开启混合/深度测试等. 状态名称 设置指令 解释 Cull Cull Back/Front/Off 设置剔除模式.剔除背面/正面/关闭剔除 ZTest ZTest Less Greater/LEqual/GEqual/NotEqual/Always 设置深度测试时使用的函数 Zwrite ZWrite On/Off 开启/关闭深度测试 Blend Blend SrcFactor DstFactor 开启并设置混合模式 当在SubShader块中设置了这些渲染状态时,将会应用到所有Pass,如果我们不想这样,可以在Pass语义块中单独进行上面的设置. SubShader标签 SubShader的标签是一个键值对,他的键和值都是字符串类型. 标签结构如下: 1Tags &#123; &quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; &#125; 标签类型 说明 例子 Queue 控制渲染顺序,指定该物体属于哪一个渲染队列,通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染(详见第8章).我们也可以自定义使用的渲染队列来控制物体的渲染顺序 Tags { “Queue” = “Transparent” } RenderType 对着色器进行分类,例如这是一个不透明的着色器,或是一个透明的着色器.这可以用于着色器替换功能(啥玩意) Tags { “RenderType” = “Opaque” } DisableBatching 一些SubShader在使用Unity批处理功能时会出现问题,例如使用了模型空间下的坐标进行顶点动画(详见第11.3节).这时可以通过该标签来指明是否对该SubShader使用批处理. Tags { “DisableBatching” = “True” } ForceNoShadowCasting 控制使用该SubShader的物体是否会投射阴影(详见8.4)节 Tags { “ForceNoShadowCasting” = “True” } IgnoreProjector 如果该标签设置为True,那么使用该SubShader的物体不会受到projector的影响.通常用于半透明物体. Tags { “IgnoreProjector” = “True” } CanUseSpriteAtlas 当该SubShader是用于精灵时,将该标签设为False Tags { “CanUseSpriteAtlas” = “False” } PreviewType 指名材质面板将如何预览该材质.默认情况下,材质将显示为一个球形.我们可以通过将该标签的值设为&quot;Plane&quot; &quot;SkyBox&quot;来改变预览类型. Tags { “PreviewType” = “Plane” } Pass语义块 Pass语义块包含的语义如下 12345Pass &#123; [Name] [Tags] // Other Code&#125; 首先,我们可以在Pass中定义该Pass的名称,例如 1Name &quot;MyPassName&quot; 通过这个名称,我们可以使用Shader的UsePass命令来直接使用其他UnityShader中的Pass.例如: 1UsePass &quot;MyShader/MYPASSNAME&quot; 这样可以提高代码的复用性.需要注意的是,由于Unity内部会把所有Pass的名字转换成大写字母的表示,因此在使用UsePass命令时必须使用大写的名字. Pass同样可以设置标签,但它的标签不同于SubShader标签.这些标签也是告诉渲染引擎我们希望怎么来渲染该物体. 标签类型 说明 例子 LightMode 定义该Pass在Unity的渲染管线中的角色 Tags { “LightMode” = “ForwardBase” } RequiresOptions 用于指定当满足某些条件时才渲染该Pass,它的值是一个由空格分隔的字符串.目前,Unity支持的选项有: SoftVegetation. 在后面的版本中,可能会增加更多的选项. Tags{ “RequireOption” = “SoftVegetation” } 除了上面的普通Pass定义外,Unity Shader还支持一些特殊的Pass, 以便进行代码复用或实现更复杂的效果. UsePass 如之前所说,可以引入其他Unity Shader中的Pass. GrabPass 负责抓取屏幕并将结果存储在一张纹理中,以用于后续的Pass处理(详见10.2.2节) FallBack 1234FallBack &quot;name&quot;FallBack OffFallBack &quot;VertexLit&quot; 事实上,FallBack还会影响阴影的投射.在渲染阴影纹理时,Unity会在每个UnityShader中寻找一个阴影投射的Pass.通常情况下,我们不用自己专门实现一个阴影投射的Pass,这是因为FallBack使用内置Shader中包含了这样一个通用Pass. 因此,为每个UnityShader设置正确的FallBack是非常重要的. UnityShader的形式 尽管UnityShader可以做的事情非常多(如设置渲染状态等),但其最重要的任务还是指定各种着色器所需的代码.这些着色器代码可以写在Shader语义块中(表面着色器的做法),也可以写在Pass语义块中(顶点/片元着色器和固定函数着色器的做法). 表面着色器 Surface Shader 是Unity自己创造的一种着色器代码类型.它需要的代码量很少,Unity在背后做了很多工作,单渲染代价比较大.当给Unity提供一个表面着色器的时候,它在背后仍旧会将它转换成对应飞顶点/片元着色器. 它存在的价值在于,Unity为我们处理了很多光照细节,使得我们不需要再操心这些烦人的事情. 一个非常简单的表面着色器示例代码: 12345678910111213141516Shader &quot;Custom/sur&quot;&#123; SubShader&#123; Tags &#123;&quot;RenderType&quot; = &quot;Opaque&quot;&#125; CGPROGRAM #pragma surface surf Lambert struct Input &#123; float4 color:COLOR; &#125;; void surf(Input In, inout SurfaceOutput o) &#123; o.Albedo = 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 上述程序可以看出,表面着色器被定义在SubShader语义块(而非Pass语义块)中的CGPROGRAM和ENDCG之间.原因是,表面着色器不需要关心开发者使用多少个Pass,每个Pass如何渲染等问题,Unity会在背后去帮我们做好这些事情.我们要做的只是告诉它,“用这些纹理去填充颜色,用这个法线纹理去填充法线,使用Lambert光照模型” CGPROGRAM和ENDCG之间的代码是使用Cg/HLSL编写的,也就是说,我们需要把Cg/HLSL语言嵌套在ShaderLab中.值得注意的是,这里的Cg/HLSL是Unity经过封装后提供的,它的标准语法和标准的Cg/HLSL几乎一样,但还是有细微不同.例如有些原生的函数和用法Unity并没有提供支持. 顶点/片元着色器 Vertex/Fragment Shader 更加复杂,但灵活性更高. 123456789101112131415161718192021Shader &quot;Custom/vertexfragment&quot;&#123; SubShader&#123; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v : position) : SV_POSITION&#123; return mul(UNITY_MATRIX_MVP, v); &#125; float4 frag() : SV_Target&#123; return fixed4(1.0,0.0,0.0,1.0); &#125; ENDCG &#125; &#125;&#125; 和表面着色器类似,顶点/片元着色器的代码也需要定义在CGPROGRAM和ENDCG中间.但不同的是,顶点/片元着色器是写在Pass语义块中的,而非SubShader语义块内.原因是我们需要自己定义每个Pass需要使用的Shader代码.虽然我们可能需要编写更多的代码,但带来的好处是灵活性很高.更重要的是,我们可以控制渲染的实现细节. 固定函数着色器 Fixed Function Shader 弃子,现在不怎么用的着色器 上面两种着色器都是用了可编程管线.而对于一些较旧的设备,它们不支持可编程管线着色器,因此,我们就需要使用固定函数着色器. 这些着色器往往只能完成一些非常简单的效果]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第2章-渲染流水线]]></title>
    <url>%2Fshader-r-lsx%2F</url>
    <content type="text"><![CDATA[看完数学部分后再来写的 CPU流水线 将数据加载到显存中 把渲染所需所有数据从硬盘加载到系统内存中 网格和纹理等数据又被加载到显存中 设置渲染状态 这些状态定义了场景中的网格是怎么被渲染的 例如,使用哪个顶点着色器/片元着色器,光源属性,材质等. 如果我们没有设置渲染状态,那么所有网格都将使用同一种渲染状态 调用DrawCall Draw Call是一个命令,发起方是CPU,接收方是GPU. 这个命令仅仅会指向一个需要被渲染的图元的列表,而不再包含任何材质信息–因为已经在上个阶段完成了. 当给定一个Draw Call时,GPU会根据渲染状态(材质,纹理,着色器等)和所有输入的顶点数据来进行计算,最终输出到屏幕 GPU流水线 顶点数据 -&gt; 顶点着色器 -&gt; 曲面细分着色器 -&gt; 几何着色器 -&gt; 裁剪 -&gt; 屏幕映射 -&gt; 三角形设置 -&gt; 三角形遍历 -&gt; 片元着色器 -&gt; 逐片元操作 -&gt; 屏幕图像 顶点着色器 顶点无法销毁或创建顶点,也不可以获得顶点之间的联系.例如,我们无法判断两个顶点是否处于同一个网格.正是因为这样的相互独立性,GPU可以利用本身的特性并行化处理每一个顶点,这意味着这一阶段的处理速度会更快. 顶点着色器需要完成的主要工作有:坐标变换和逐顶点光照 当然除了这两个主要任务外,顶点着色器还可以输出后续阶段所需的数据. 坐标变换 把顶点坐标从模型空间变换到齐次剪裁空间 剪裁 摄像机的视野范围内很有可能不会覆盖场景中的所有物体.不在摄像机视野范围内的物体不需要处理.剪裁就是为了完成这个目标而被提出来的. 我们无法通过编程来控制剪裁的过程,而是硬件上的固定操作,但我们可以自定义一个剪裁操作来对这一步进行配置. 屏幕映射 屏幕映射的任务是把每个图元的x,y坐标转换到屏幕坐标系. 三角形设置 从这一步开始进入光栅化阶段. 从上一个阶段输出的信息是屏幕坐标系下的顶点位置以及它们的额外信息,如深度值(z坐标),法线方向,视角方向等. 光栅化阶段有两个最重要的目标:计算每个图元覆盖了哪些像素,以及为这些像素计算它们的颜色. 三角形设置阶段会计算光栅化一个三角网格所需的信息.具体来说,上个阶段输出的都是三角网格顶点.但如果要得到整个三角网格对像素覆盖的情况,我们就必须计算每条边上的像素坐标. 为了能够计算边界像素的坐标信息,我们就需要得到三角形边界的表达方式.这样一个计算三角形网格表示数据的过程就叫做三角形设置.它的输出是为了给下一步做准备. 三角形遍历 三角形遍历阶段会检查每个像素是否被一个三角网格所覆盖. 如果被覆盖的话,就生成一个片元 而这个找到哪些像素被三角网格覆盖的过程就是三角形遍历,这个阶段也被称为扫描变换. 三角形遍历会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素,并使用三角网格三个顶点的顶点信息对整个覆盖区域的像素进行插值. 这一步的输出就是得到一个片元序列. 需要注意的是,一个片元并不是真正意义上的像素,而是包含了很多状态的集合,这些状态用于计算每个像素的最终颜色 这些状态包括了(但不限于)它的屏幕坐标,深度信息,以及其他从几何阶段输出的顶点信息,如法线,纹理坐标等. 片元着色器 前面的光栅化操作并不会影响屏幕上每个像素的颜色值,而是会产生一系列的数据信息,来描述一个三角网格是怎样覆盖每个像素的.而片元就是负责存储这样一系列数据. 真正会对像素产生影响的是下一个阶段–逐片元操作 片元着色器的输入是上一个阶段对顶点信息插值得到的结果. 更具体来说,是根据那些从顶点着色器中输出的数据差值得到的. 它的输出是一个或多个颜色值. 这一阶段可以完成很多重要的渲染技术,其中最重要的技术之一是纹理采样. 为了在片元着色器中进行纹理采样,我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标 然后经过光栅化阶段对三角形网格的三个顶点对应的纹理坐标进行插值后,就可以得到其覆盖片元的纹理坐标了. 片元着色器的局限在于,它仅可影响单个片元. 也就是说,在执行片元着色器时,它不可以将自己的任何结果发送给它的邻居们. 有一个情况例外,就是片元着色器可以访问到导数信息(扩展阅读)(smjb) 逐片元操作 也被称为输出合并阶段 这一阶段的几个重要任务: 决定每个片元的可见性. 这涉及很多测试工作,如深度测试,模板测试等 合并 如果一个片元通过了所以测试,就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行混合 逐片元操作是高度可配置的.即我们可以设置每一步的操作细节.]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bili-api]]></title>
    <url>%2Fbili-api%2F</url>
    <content type="text"><![CDATA[url 描述 https://api.bilibili.com/x/relation/stat?vmid={uid} up粉丝数 https://api.bilibili.com/x/space/upstat?mid={uid} 观看量 https://api.bilibili.com/x/space/navnum?mid={uid} 投稿数量 https://api.bilibili.com/x/space/acc/info?mid={uid} 基本信息 https://api.bilibili.com/x/space/masterpiece?vmid={uid} 代表作]]></content>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第4章-数学基础]]></title>
    <url>%2Fshader-r-math%2F</url>
    <content type="text"><![CDATA[《shader入门精要》免费的第四章pdf 点和矢量 点积(内积)和叉积(外积) 内积 Shader代码中使用dot(a,b)来进行矢量的点积运算. 1a·b = (a x , a y , a z ) ·(b x , b y , b z ) = a x b x + a y b y + a z b z 满足交换律和结合律. 使用: 投影 单位矢量a,和一个长度不限制的矢量b,dot(a,b)得到b在a方向上带有符号的投影 外积 外积的结果时矢量,并非标量. 1a X b = (a x , a y , a z ) X (b x , b y , b z ) = (a y b z - a z b y , a z b x - a x b z , a x b y - a y b x ) 例如: (1, 2, 3) X (−2, −1, 4) = ((2)(4) − (3)(−1), (3)(−2) − (1)(4), (1)(−1) − (2)(−2)) = (8 − (−3), (−6) − 4, (−1) − (−4)) = (11, −10, 3) 外积不满足交换律,即a X b不等于b X a. 然而外积满足反交换律,即a X b = -(b X a) 外积不满足结合律. 矩阵(matrix) 矩阵运算 矩阵乘法 矩阵乘法不满足交换律 AB不等于BA 矩阵乘法满足结合律 (AB)C = A(BC) shader中主要使用4x4矩阵来运算. 特殊矩阵 方块矩阵(方阵) 行和列数目相等的矩阵. 三维渲染里,用的最多的是3x3和4x4的方阵 单位矩阵 用In来表示.比如I3是3x3的单位矩阵. 转置矩阵 transposed matrix 转置矩阵实际是对原矩阵的一种运算,即转置运算.给定一个rXc的矩阵M,他的转置可以表示为MT(T为上标)(辣鸡MD).数学公式是: 例如: 转置矩阵性质: 转置矩阵的转置等于原矩阵(废话) 矩阵的串接转置等于反向串接各个矩阵的转置 即: 逆矩阵 给定一个矩阵M,用M-1(-1为上标)表示M的逆矩阵. MM-1为单位矩阵 矩阵可逆的条件: 矩阵为方块矩阵 矩阵的行列式不为零 虽说在学数学…但是也是shader开发里的数学…还是不去回忆具体怎么求逆矩阵了,交给程序去做=v= 逆矩阵的性质 逆矩阵的逆矩阵等于原矩阵 单位矩阵的逆矩阵是其本身 转置矩阵的逆矩阵等于逆矩阵的转置 即: 矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵 即: 正交矩阵 蒸饺正交是矩阵的一种属性.如果一个方阵M和它的转置矩阵的乘积是单位矩阵的话,我们说这个矩阵是正交的 即: 行矩阵or列矩阵? 书上p64 这里不说过程了. 结论是,unity中习惯把矢量转换成列矩阵,并放在矩阵的右侧进行计算. 矩阵的几何意义: 变换 变换的类型 线性变换 可以保留矢量加和标量乘的变换.用数学公式表达即是: 上面的式子很抽象. 缩放就是一种线性变换.如f(x) = 2x,可以表示一个大小为2的统一缩放. 旋转也是一种线性变换 对于线性变换来说,仅仅使用3X3矩阵可以表示三维坐标下的所有线性变换. 线性变换除了包括旋转和缩放外,还包括错切,镜像,正交投影等. 仿射变换 仅有线性变换是不够的,要考虑平移交换.如,f(x) = x + (1,0,0)这个变换就不是一个线性变换. 三维坐标下,我们不能用一个3x3的矩阵来表示一个平移变换. 这样,就有了仿射变换. 仿射变换是合并了线性变换和平移变换的变换类型.三维空间下的仿射变换可以用一个4x4的矩阵来表示.为此,我们需要把矢量扩展到四维空间下,这就是齐 次 坐 标 空 间(homogeneous space). 不知道是什么鸡儿玩意单好像以后有用的表 齐次坐标 因为3X3矩阵不能表示平移,所以我们用4x4矩阵.为此,我们还需要把原来的三维矢量转换成四维矢量,也就是齐次坐标(homogeneous coordinate). 对于一个点,从三维坐标转换为齐次坐标是将其w分量设为1,而对于方向矢量而言,需要把其w分量设为0. 这样的设置会导致,用一个4x4矩阵对一个点进行变换的时候,平移,缩放,旋转都会被施加于该点.但是如果用于变换一个方向矢量,平移的效果就会被忽略. 分解基础变换矩阵 我们可以把一个基础变换矩阵分解成4个组成部分. 其中,左上角的M是一个用于旋转和缩放的三维矩阵. t表示平移. 最后一行是固定的[0 0 0 1] 平移矩阵 M为单位矩阵时,整个4x4矩阵只代表平移. 平移矩阵的逆矩阵就是反向平移的矩阵. 缩放矩阵 如果缩放系数kx = ky = kz,我们把这样的缩放称为统一缩放否则称为非统一缩放. 直观上看,统一缩放就是等比缩放模型,而非统一缩放会拉伸或挤压模型. 统一缩放不会改变角度和比例信息,非统一缩放会改变模型相关的角度和比例. 在进行法线变换时,如果存在非统一缩放,直接用于变换顶点的变换矩阵的话,就会得到错误的结果.(正确的方法见4.7节(还没发货哦草)) 旋转矩阵 按x轴旋转: 按y轴旋转 按z轴旋转 复合变换 我们可以把平移,旋转,缩放结合起来,组成一个复杂的变换过程. 例如,可以对一个模型先进行大小为(2, 2, 2)的缩放,再绕y轴旋转30度,最后向z轴平移4个单位. 复合矩阵可以通过矩阵的串联来实现. 如: 需要注意的是,因为矩阵的乘法不满足交换律,变换的结果是依赖于变换顺序的. 绝大多数情况下,我们约定变换的顺序是,先缩放,再旋转,最后平移. 坐标空间 模型空间 也称对象空间或局部空间. 世界空间 最外层的坐标空间 观察空间 也称为摄像机空间 Unity中观察空间的+x轴指右方,+y轴指向上方,+z轴指向摄像机的后方----Unity在模型空间和世界空间选用的是左手坐标系,而观察者空间选用右手坐标系. 观察空间和屏幕空间是不同的.观察空间是一个三维空间,而屏幕空间是一个二维空间.从观察空间到屏幕空间需要一个投影(projection)转换. 顶点变换的第二步,就是将顶点坐标从世界空间变换到观察空间.这个变换通常叫做观察变换. 剪裁空间 顶点接下来要从观察者空间转换到剪裁空间(clip space,也被称为齐次裁剪空间)中,这个用于变换的举证叫做裁剪矩阵(clip matrix),也被称为投影矩阵(projection matrix). 剪裁空间的目标是能够方便地对渲染图元进行裁剪.完全位于这块空间内部的图元将会被保留,完全处于这块空间外部的图元将会被剔除,而与这块空间边界相交的图元就会被裁剪.这块空间是由视锥体(view frustum)决定的. 视锥体指的是空间中的一块区域,这块区域决定了摄像机可以看到的空间.视锥体由留个平面包围而成,这些平面被称为裁剪平面(clip planes). 视锥体有两种类型,这涉及两种投影类型----一种是正交投影(orthographic projection),一种是透视投影(perspective projection) 透视投影会有远小近大. 在视锥体的6块裁剪平面中,有两块裁剪平面比较特殊,分别是近剪裁平面(near clip plane)和远剪裁平面(far clip plane).它们决定了摄像机可以看到的深度范围. 我们通过一种通用,简洁的方式进行剪裁工作,这种方式是通过一个投影矩阵把顶点转换到一个剪裁空间中. 投影矩阵有两个目的: 首先是为投影做准备.这是个迷惑点,虽然投影矩阵包含了投影二字,但是它并没有进行真正的投影工作,而是在为投影做准备.真正的投影发生在后面的齐次排除法(homogeneous division)过程中.而经过投影矩阵变换后,顶点的w分量将会具有特殊意义. 其次是对x,y,z分量进行缩放.经过投影矩阵的缩放以后,我们可以直接使用w分量作为一个范围值,如x,y,z都在这个范围内,就说明该顶点位于剪裁空间内. 1.透视投影 视锥体的六个剪裁平面是由Camera组件中的参数和Game视图的横纵比共同决定的. 如图所示,我们可以通过Camera组件的Field of View(简称FOV)属性来改变视锥体竖直张开的角度,而Cliping Planes中的Near和Far属性可以控制视锥体的近剪裁平面和远剪裁平面距离摄像机的远近.这样,我们可以求出视锥体近剪裁平面和远剪裁平面的高度. 一个摄像机的横纵比由Game视图的横纵比和Viewport Rect中的W和H属性共同决定.假设,当前摄像机的横纵比是Aspect: 现在,我们可以根据已知的Near,Far,FOV和Aspect的值来确定透视投影的投影矩阵. 推导见本章的扩展阅读部分 一个顶点和上面的投影矩阵相乘后,可以由观察者空间变换到剪裁空间. 从结果可以看出来,投影矩阵的本质是对x,y,z分量做了不同的缩放(z分量还做了一个平移).缩放的目的是为了方便裁剪. 可以注意到,此时顶点的w分量不再是1,而是原先z分量的取反.现在,我们就可以按如下不等式判断一个变换后的顶点是否位于视锥体内.如果一个顶点在视锥体内,那么它变换后的坐标必须满足: -w &lt;= x &lt;= w -w &lt;= y &lt;= w -w &lt;= z &lt;= w 任何不满足上述条件的图元都需要被剔除或者裁剪. 通过此图还可以注意到,剪裁矩阵会改变空间的旋向性:空间从右手坐标系变换到了左手坐标系. 2. 正交投影 和透视投影类似,在unity中,正交投影的六个人裁剪平面是由Camera组件中的参数和Game视图的横纵比共同决定的. 由图看出,我们可以通过Camera组件的Size属性来改变视锥体竖直方向上的高度的一半,而Clipping Planes中的Near和Far参数可以控制视锥体的近剪裁平面和远剪裁平面距离摄像机的远近.这样,我们可以求出视锥体近剪裁平面和远剪裁平面的高度.即: 同样,我们可以通过摄像机的横纵比得到横向信息.假设当前摄像机的横纵比为Aspect: 现在我们根据已知的Near,Far,Size和Aspect的值来确定正交投影的裁剪矩阵.如下: 推导见本章的扩展阅读 一个顶点和上述投影矩阵相乘后的结果如下: 注意到,和透视投影不同,使用正交投影的投影矩阵对顶点变换后,其分量w依然为1.本质是因为投影矩阵最后一行的不同,透视投影的投影矩阵的最后一行是[0 0 -1 0],而正交投影的投影矩阵最后一行是[0 0 0 1].这样选择是为了为齐次除法做准备(具体在下面讲到) 判断一个变换后的顶点是否位于视锥体内使用的不等式和透视投影的一样. 同样,裁剪矩阵改变了空间的旋向性.可以注意到,经过正交投影变换后的顶点实际已经位于一个立方体内了. 屏幕空间 经过了投影矩阵的变换后,我们可以进行剪裁工作.当完成了所有的剪裁工作后,就需要进行真正的投影了.也就是说,我们需要把视锥体投影到屏幕空间(screen space)中.经过这一步变换,我们会得到真正的像素位置,二非虚拟的三维坐标. 屏幕空间是一个二维空间,因此我们需要把顶点从剪裁空间投影到屏幕空间,来生成对应的2D坐标.这个过程分为两个步骤 首先,我们要进行标准齐次除法(homogeneous division),也被称为透视除法(perspective division).虽然这个步骤听起来陌生,但它实际上非常简单,就是用齐次坐标系的w分量去除以x,y,z分量.在OpenGL中,我们把这一步得到的坐标叫做归一化的设备坐标(Normalized Device Coordinate, NDC).经过这一步,我们可以把坐标从齐次剪裁坐标空间转换到NDC中.经过透视投影变换后的剪裁空间,经过齐次除法后会变换到一个立方体内. 对于透视投影 对于正交投影 经过齐次除法后,透视投影的剪裁空间会变换到一个立方体 对于正交投影来说,它的剪裁空间实际已经是一个立方体了,而且由于经过正交投影矩阵变换后的顶点的w分量是1,因此齐次除法并不会对顶点的x,y,z坐标产生影响 经过齐次除法后,透视投影和正交投影的视锥体都变换到一个相同的立方体内.现在,我们可以根据变换后的x,y坐标来映射输出窗口的对应像素坐标. 这个映射的过程是一个缩放的过程. 齐次除法和屏幕映射的过程可以用下面的公式总结: 上面式子对x和y分量进行了处理,而z分量会被用于深度缓冲.一个传统的方式是把clip z / clip w的值直接存进深度缓冲中,但这不是必须的.通常驱动的生产商会根据硬件来选择最好的存储格式. 此时clip w也并未抛弃,虽然它已经完成了它的主要工作–在齐次除法中作为分母来得到NDC,但它仍然会在后续的一些工作中起到重要作用.例如进行透视矫正差值(草,这又是什么玩意) 在Unity中,从剪裁空间到屏幕空间的转换是底层帮我们完成的.我们的顶点着色器只需要把顶点转换到剪裁空间即可. 总结 以上就是一个顶点如何从模型空间最终转换到屏幕空间的全过程. 顶点着色器的最基本的任务是把顶点坐标从模型空间转换到剪裁空间中.这对应了上图中的前三个顶点变换过程.而在片元着色器中,我们通常也可以得到该片元在屏幕空间的像素信息.我们会在4.9.3节中看到如何得到这些像素位置. 在Unity中,坐标系的旋向性也随着发生了改变. 只有在观察空间使用了右手坐标系. 需要注意的是,这里仅仅给出的是一些最重要的坐标空间.还有一些空间在实际开发中也会遇到,如切线空间(tangent space).切线空间通常用于法线映射. 法线变换 法线(normal),也被称为法矢量(normal vector). 在游戏中,模型的一个顶点往往会携带额外的信息,而顶点法线就是其中的一种信息. 当我们变换一个模型的时候,不仅要变换它的顶点,还需要变换它的法线,以便在后续的处理(如片元着色器)中计算光照等. 玛德这块数学公式太多了md不要表达,反正本来的这块内容就没多少去书上看吧. Unity Shader的内置变量(数学篇) 变换矩阵 这里是Unity5.2版本提供的所有内置变换矩阵.所有矩阵都是float4x4的. 变量名 描述 _Object2World 当前的模型矩阵,用于将顶点/方向矢量从模型空间变换到世界空间 _World2Object _Object2World的逆矩阵.用于将顶点/方向矢量从世界空间变换到模型空间 UNITY_MATRIX_V 当前的观察矩阵,用于将顶点/方向矢量从世界空间变换到观察空间 UNITY_MATRIX_P 当前的投影矩阵,用于将顶点/方向矢量从观察空间变换到剪裁空间 UNITY_MATRIX_MV 当前的模型矩阵·观察矩阵,用于将顶点/方向矢量从模型空间变换到观察空间 UNITY_MATRIX_VP 当前的观察矩阵·投影矩阵,用于将顶点/方向矢量从世界空间转换到剪裁空间 UNITY_MATRIX_MVP 当前的模型矩阵·观察矩阵·投影矩阵,用于将顶点/方向矢量从模型空间变换到剪裁空间 UNITY_MATRIX_T_MV UNITY_MATRIX_MV的转置矩阵 UNITY_MATRIX_IT_MV UNITY_MATRIX_MV的逆转置矩阵,用于将法线从模型空间变换到世界观察空间,也可用于得到UNITY_MATRIX_MV的逆矩阵 UNITY_MATRIX_T_MV这个矩阵比较特殊. 对于正交矩阵来说,它的逆矩阵就是转置矩阵.因此,如果UNITY_MATRIX_MV是一个正交矩阵的话,那么UNITY_MATRIX_T_MV就是它的逆矩阵,也就是说,我们可以使用UNITY_MATRIX_T_MV将顶点/方向矢量从观察空间变换到模型空间 UNITY_MATRIX_IT_MV这个矩阵也要特殊说明一下. 法线的变换需要使用原变换矩阵的逆转矩阵,因此UNITY_MATRIX_IT_MV可以把发现从模型空间变换到观察者空间.而且,只需要对它进行转置,就可以得到UNITY_MATRIX_MV的逆矩阵因此,为了把顶点或法线矢量从观察者空间变换到模型空间,我们可以使用以下代码: 12345// 方法一: 使用transpose函数对UNITY_MATRIX_IT_MV进行转置,得到UNITY_MATRIX_MV的逆矩阵,然后进行列矩阵乘法,把观察空间中的点或方向矢量变换到模型空间中 float4 modelPos = mul(transpose(UNITY_MATRIX_IT_MV), viewPos);// 方法二: 不直接使用转置函数transpose, 而是交换mul参数的位置,使用行矩阵乘法. 本质是一样的.float4 modelPos = mul(viewPos, UNITY_MATRIX_IT_MV); 摄像机和屏幕参数 Unity提供了一些内置变量来让我们访问当前正在渲染的摄像机的参数信息.这些参数对应了摄像机上的Camera组件中的属性值. 变量名 类型 描述 _WorldSpaceCameraPos float3 该摄像机在世界空间中的位置 _ProjectionParams float4 x = 1.0(或-1.0, 如果正在使用一个翻转的投影矩阵进行渲染), y = Near, z = Far, w = 1.0 + 1.0/Far _ScreenParams float4 x = wodth, y = height, z = 1.0 + 1.0/width, w = 1.0 + 1.0/height _ZBufferParams float4 x = 1 - Far/Near, y = Far/Near, z = x/Far, w = y/Far, 该变量用于线性化Z缓存中的深度值(可参考13.1节) unity_OrthoParams float4 x = width, y = height,z没有定义,w = 1.0(该摄像机是正交摄像机),或w = 0.0(该摄像机是透视摄像机) unity_CameraProjectio float4x4 该摄像机的投影矩阵 unity_CameraInvProjection float4x4 该摄像机的投影矩阵的逆矩阵 unity_CameraWorldClipPlanes[6] float4 该摄像机的6个裁剪平面在世界空间下是等式.按如下顺序:左,右,下,上,近,远裁剪平面]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10-Insider-Preview]]></title>
    <url>%2Fwin10-Insider-Preview%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[博客上放上live2d]]></title>
    <url>%2Fblog-live2d%2F</url>
    <content type="text"><![CDATA[很久前就看到在网站上挂个live2d,也有想法了,然而从昨晚才开始折腾.想在博客上放个舰b的live2d,结果试了好久,版本二到版本三,从民间到官方的web sdk都试了,就没有支持舰b的live2d的T_T 最后妥协了下,选了有前车之鉴的药水制作师的live2d.最喜欢之前拿红宝石买来的樱花校服装了. 阿黑颜pio 参考: 猫与向日葵的博客 Cubism WebGL SDK]]></content>
      <tags>
        <tag>live2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shader学习]]></title>
    <url>%2Fshader-learning%2F</url>
    <content type="text"><![CDATA[资料 Shader编程教程-蛮牛 Unity User Manual 第一课 图形硬件简史与可编程管线 课时总结 2003年开始正式进入可编程GPU阶段 GPU的并行处理能力强于CPU 目前GPU无法代替CPU 第二课 shader和渲染管线 GPU前段模块-&gt;图源装配: 过去只有集成在硬件当中的顶点着色器,现在可编程 光栅化: 把计算机显卡当中运算的数据进行一个细分用于适配屏幕上具体的每一个像素的显示 像素运算: 光栅化不等同于像素运算.像素运算最终反映的是颜色,光栅化过后得到的结果是帧缓存.这个过程中可以加入片段着色器. Vertex Processor 顶点处理程序,运算的结果将会交给像素处理器 Frame Buffer 帧缓冲中容纳了是计算机依次显示所要使用的数据,但不只是屏幕上用语显示的颜色的信息,可能还有其他的附加信息.比如深度值 Transform, TexGen, Lighting Transform 模型的空间变换(针对顶点的空间几何变换) Texture Generator 纹理坐标的生成,主要用于在顶点当中取得纹理坐标,纹理坐标转化为uv取值的范围 Lighting 光照 Vertex Shader 改变上个模块的光照,变换,纹理生成等 Culling Depth Test Culling 裁剪.物体在镜头面前展示,背对摄像头的面看不到,可能就会被裁剪,不处理看不到的面的顶点数据. Depth Test 深度测试.范围超过摄像头最近或最远的渲染范围之后,也会被剔除 Texturing Fog 纹理采样.进入光栅化阶段.从纹理当中找到纹理中对应的一个点 Fragmen Shader 远处的物体可能需要雾化处理.处于片段shader的可编程范围 Alpha Test 绘制半透明或全透明物体 Blending 混合最终的图像 可编程能力是两个部分,一部分是变换和光照,使用顶点shader编写顶点着色器 如何采样,计算颜色以及雾化处理等等,这部分放到片段着色器 unity当中,优化主要部分是减少游戏调用gpu渲染的调度次数.CPU搜集数据,产生GPU调度数据.这个过程是昂贵的. shader和材质,贴图的关系 shader实际上是一小段程序.负责将输入的顶点数据以指定的方式和输入的贴图或者颜色组合起来然后输出. 绘图单元可以依据这个输出将图像绘制到屏幕上. 输入的贴图或者颜色等,加上对应的shader,以及对shader]d特定的参数设置,将这些内容(shader及输入参数)打包存储在一起.得到的就是一个Material(材质).之后我们便可以将材质赋予三维物体来渲染(输出)了. 材质好比引擎最终的商品,shader是生产这种商品的加工方法,而贴图是原材料. 课时总结 Shader是图形可编程方案的程序片段 渲染管线是一种计算机从数据到最终图形成像的形象描述 材质是商品,shader是方法,贴图是材料 第三课 shader的三大主流高级编程语言 HLSL 基于DirectX的High Level Shading Language GLSL 基于OpenGL的OpenGL Shading Language CG NVIDIA公司的C for Graphic 第四课 Unity Shader的组织形式 surface shader unity推荐和鼓励的shader.图形管线能够用于识别的,就是vertex and fragment shader.surface shader是对vertex and fragment shader的一种包装.unity最终会把surface shader编译成能被硬件识别和调用的vertex and fragment shader vertex and fragment shader fixed function shaders 固定管线的shader. Shaderlab 语法基本结构 12345678910111213141516Shader &quot;MyShader&quot; &#123; Properties &#123; _MyTexture (&quot;My Texture&quot;, 2D) = &quot;white&quot; &#123; &#125; // place other properties here, such as colors or vectors. &#125; SubShader &#123; // place the shader code here for your: // - surface shader, // - vertex and program shader, or // - fixed function shader &#125; SubShader &#123; // a simpler version of the subshader above goes here. // this version is for supporting older graphics cards. &#125;&#125; unity自带shader Unlit 不发光 VertexLit 顶点光照 Diffuse 漫反射.不仅仅在顶点上进行光照计算,在片段上进行光照计算 Normal Mapped 法线贴图.用的比较多.通过一张贴图进行采样.贴图是关于法向量存储的贴图.把这张图采样出的数据作为法向量再进行光照计算.主要目的是当几何模型面片数量,顶点数量不太多,为表达丰富的细节. Specular 高光.玻璃等 Normal Mapped Specular 高光法线贴图.较昂贵 Parallax Normal mapped 视差法线贴图 Parallax Normal mapped Specular 高光视差法线贴图 Fixed function shader 固定功能的shader.功能有限但是性能很好 Surface Shader Surface Shader无需编写pass通道]]></content>
      <categories>
        <category>作废归档</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[夏目友人帐观影]]></title>
    <url>%2Fnazume-film%2F</url>
    <content type="text"><![CDATA[听说到容莉枝不管好事还是坏事都要去那个祠堂参拜的时候,就心想着那是个树洞,结果还真是个真实树洞233 前半那个笹田演讲的时候放的BGM就是那首熟悉的ふるさとの匂い,直接掉泪 容莉枝阿姨在儿子死后的八年间没有很痛苦是很好的,穗之影做得好.真正可怜的是穗之影啊草. 看之前的剧情以为名取对夏目图谋不轨来着,这次看名取的心理活动,还是个好人.]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习unity]]></title>
    <url>%2Funity-learning%2F</url>
    <content type="text"><![CDATA[unity官方教程https://unity3d.com/cn/learn/tutorials 现在在看一个beagining教程roll a ball material初探 新建material,选择颜色后,将material拖到gameObject上,gameObject就会变成对应的颜色 Update方法 Update方法 Update方法在渲染每帧前被调用 FixedUpdate FixedUpdate方法只有在执行有关物理计算之前才被调用 LateUpdate LateUpdate方法在所有Update方法执行完执行完之后执行 静态和动态GameObject 静态碰撞体 unity会计算场景内所有静态碰撞体的体积,并将信息保存在缓存内.因为静态碰撞体不需要移动,可以避免每帧重新计算这些信息,所以这是对的 每当静态碰撞体移动 旋转或缩放时,unity会重新计算这些静态碰撞体,然后更新静态碰撞体的缓存数据 动态碰撞体 重新计算缓存会耗费系统资源,但我们可以随意移动移动,旋转或缩放动态碰撞体,而且unity不会缓存他们的数据.unity会预测动态碰撞体的移动,所以在移动碰撞体之前,需要告诉unity它们是动态的.可以使用刚体组件来实现这种效果. 任何带有碰撞体和刚体组件的GameObject都会被认为是动态的.任何带有碰撞体却没有刚体组件的GameObject则被视为是静态的. 刚体选中&quot;Is Kinematic&quot;可以将刚体变成仅受脚本控制的刚体.kinematic刚体不受无力作用力的影响,但可以播放动画或通过Transform组件移动 几何图元绘制顺序 Sorting Layer Sorting Layer序号越大的层越后绘制,因而会覆盖掉前面序号小的层上的几何图元 表示指定层在Tags and Layers视图Sorting Layers中的顺序 各层的绘制顺序是Default -&gt; Background -&gt; Character -&gt; Foreground -&gt; UI Order in layer 在同一层调整几何图元的绘制深度.同样是序号大的覆盖序号小的 spirit Render组件中SortingLayer属性控制的是不同层之间的绘制顺序,而Order in Layer控制的是同层中物体的绘制顺序 spine 可算知道瓜游的小人都是什么了 一开始下的spine3.7,然后 于是又下了3.6. 卸载旧版本插件好像是直接在project里把对应的删掉 目力俾斯麦 蛮好玩的 U!P!D!A!T!E! 写unity程序跟平常写其他程序一个很不一样的思想就是unity的每帧都会执行的update. 平时写程序如果遇到时间相关的,就要考虑sleep,然后就要考虑阻塞,考虑协程或多线程. 而unity不一样.利用unity的update机制可以很轻易的管理时间.]]></content>
      <categories>
        <category>作废归档</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加了几个音乐收藏夹]]></title>
    <url>%2FmusicFavorites%2F</url>
    <content type="text"><![CDATA[想着给把最喜欢,最常听的几首歌按风格分类,造了这么几个歌单 治愈 爱 静谧 朝气蓬勃 优美忧伤 对这些歌写点东西 治愈 urar 很美好. 蝴蝶泉边 同样很美好很温馨,更加了点回忆的感觉 Growing! 就是让人撒娇的歌 爱 Letter 动画HandShaker的BGM中听到的. 前面一段代表书信的常规内容,后面深深的感情喷涌而出. 不像小情侣之间的爱,像是老夫老妻或者亲情的爱 这封Letter不像情书而是像家书 LuvLetter 情书. 写情书和纠结要不要将情书送出去的过程,理解的是纠结着很痛苦然后没能送出去. 中间有纠结的痛苦,也有想象的美好结局. 恋 日推给我的,高潮部分很好听 愛唄 当初看一个高木同学的AMV注意到的,很真情实感 小小恋歌 同样是高木同学ed收录的 当初觉得高桥李依版本的好听,比较甜美来着,后来还是觉得新垣结衣唱的好听,捎带沙哑点的声音很温柔很知性 さよならの夏 啊 静谧 Mountain stream 高中时候学校就经常放的 陽だまり道とれんちょん 悠哉日常大王的BGM ふるさとの匂い 夏目友人帐的BGM 朝气蓬勃 RYDEEN 朝气蓬勃 优美忧伤 おうちに帰りたい ちいさな冒険者 素晴的ed. Arrietty’s Song 借东西的小人阿莉埃蒂的主题曲 春よ、来い 看了一个潮学视频知道的…着实很好听 この感情は使命 island的曲子 さよならの夏 啊]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python多重继承init的问题]]></title>
    <url>%2Fpython-mult-inherit-init%2F</url>
    <content type="text"><![CDATA[继承的时候,init父类时,平时用ide写代码习惯了这样写,因为敲一个super再回车就有了这么一行 1super(C, self).__init__() 12345678910111213141516class A: def __init__(self): self.a = "a" class B: def __init__(self): self.b = "b"class C(A,B): def __init__(self): super(C, self).__init__()if __name__ == '__main__': c = C() print(c.__dict__) # &gt;&gt;&gt; &#123;'a': 'a'&#125; 可以看出问题了,C类只init了A类,并没有init B类 下面是我瞎摸出来的解决方法 1234567891011121314151617181920class A: def __init__(self): self.a = "a"class B: def __init__(self): self.b = "b"class C(A, B): def __init__(self): A.__init__(self) B.__init__(self)if __name__ == '__main__': c = C() print(c.__dict__) # &gt;&gt;&gt; &#123;'a': 'a', 'b': 'b'&#125;]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动玩瓜游连连看的脚本]]></title>
    <url>%2Fazurlane-llk%2F</url>
    <content type="text"><![CDATA[做了个自动玩连连看的脚本. github : https://github.com/HHHHhgqcdxhg/azurlane-linkup 图片整理 将原图整理成以下格式 原图: 整理出: 1234567[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 16. 2. 4. 1. 3. 1. 2. 17. 3. 0.] [ 0. 8. 7. 14. 4. 10. 12. 18. 5. 5. 0.] [ 0. 6. 6. 9. 15. 7. 11. 8. 9. 10. 0.] [ 0. 11. 12. 13. 13. 14. 15. 16. 17. 18. 0.] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] #这个二维数组是抽象的连连看"地图",将原连连看相同的图片换成同样的数字,在在周围填充0表示通路 和 12[[1, 6], [1, 4], [1, 7], [1, 2], [1, 9], [1, 5], [2, 4], [1, 3], [2, 9], [2, 8], [3, 2], [3, 1], [3, 5], [2, 2], [3, 7], [2, 1], [3, 8], [3, 3], [3, 9], [2, 5], [4, 1], [3, 6], [4, 2], [2, 6], [4, 4], [4, 3], [4, 5], [2, 3], [4, 6], [3, 4], [4, 7], [1, 1], [4, 8], [1, 8], [4, 9], [2, 7]]# 这个数组每一项表示一组坐标,并且第 2 * i 个元素代表的图片和第 2 * i + 1 个元素代表的图片相同 求解 算法 广度优先暴搜,搜索所有可以到达的图片块,判断目标是否在其中. 代码在源码中的findLineFetch方法和pointSearch方法,注释还写的蛮详细的,这里不再解释. 实行点击: 跟上次的翻牌游戏脚本差不多 结果 7.80s视频: av45062991 7.80s留了视频,有一个7.27s的没录好… 追求极致的话应该能跑进7秒内,说不定能跑进6秒内,我做不到一定是因为我太菜了 时间浪费 截图耗时 因为开局前截图会有数字遮挡,所以等数字消完,再进行截图.因为有一些IO操作,所以就很慢… 算法耗时 嘛,我这个算法是广度优先暴搜,应该比较慢. 点击间隔不统一 ↑这个形容不是很准确.好像,当两个有效的点被点击时,如果距离比较近,下次可以点击的时间间隔就比较短,反之亦然.只是推测,不太确定.因为试的时候,经常前面好多都没事,最后两三组点的时候出错,怀疑是排到最后的组一般距离比较远导致的结果.]]></content>
      <tags>
        <tag>碧蓝航线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plus Ultra!]]></title>
    <url>%2Fbokuhiro-movie%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>动漫</tag>
        <tag>我的英雄学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线翻牌小游戏复现]]></title>
    <url>%2Fblhx-fanpai%2F</url>
    <content type="text"><![CDATA[git repo:https://github.com/HHHHhgqcdxhg/azurlane-fanpai 已部署在:https://blog.ggemo.com/azurlane-fanpai/dist/index.html 一下午撸出来的web复现的碧蓝航线翻牌小游戏. 一路写下来没遇到坑,但也没考虑性能.]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩游戏 还愿]]></title>
    <url>%2Fdevotion%2F</url>
    <content type="text"><![CDATA[真的吓人…变写博客边玩吧. 游戏过程 小女孩透过墙洞看爸爸撕写的字…想了想,以后写代码错到恼羞成怒了也只注释不删 弹珠迷宫真是绝了 被老婆追杀那里吓坏了.用手挡住屏幕看不到主要画面,然后一直都不知道要转头跑…回头翻了别人的视频才知道要跑… 拔舌头那里真心不敢看…依旧拿手遮屏幕 评价 第一次玩恐怖游戏来着,因为跟风就去玩了,吓得不轻. 还是不喜欢这种,为恐怖而恐怖的游戏.里面的一些价值观也不认同. 凉凉 2019年2月23日更新 自断财路的傻逼玩意]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win32按键码]]></title>
    <url>%2Fvkcode%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147VK_CODE = &#123; 'backspace': 0x08, 'tab': 0x09, 'clear': 0x0C, 'enter': 0x0D, 'shift': 0x10, 'ctrl': 0x11, 'alt': 0x12, 'pause': 0x13, 'caps_lock': 0x14, 'esc': 0x1B, 'spacebar': 0x20, 'page_up': 0x21, 'page_down': 0x22, 'end': 0x23, 'home': 0x24, 'left_arrow': 0x25, 'up_arrow': 0x26, 'right_arrow': 0x27, 'down_arrow': 0x28, 'select': 0x29, 'print': 0x2A, 'execute': 0x2B, 'print_screen': 0x2C, 'ins': 0x2D, 'del': 0x2E, 'help': 0x2F, '0': 0x30, '1': 0x31, '2': 0x32, '3': 0x33, '4': 0x34, '5': 0x35, '6': 0x36, '7': 0x37, '8': 0x38, '9': 0x39, 'a': 0x41, 'b': 0x42, 'c': 0x43, 'd': 0x44, 'e': 0x45, 'f': 0x46, 'g': 0x47, 'h': 0x48, 'i': 0x49, 'j': 0x4A, 'k': 0x4B, 'l': 0x4C, 'm': 0x4D, 'n': 0x4E, 'o': 0x4F, 'p': 0x50, 'q': 0x51, 'r': 0x52, 's': 0x53, 't': 0x54, 'u': 0x55, 'v': 0x56, 'w': 0x57, 'x': 0x58, 'y': 0x59, 'z': 0x5A, 'numpad_0': 0x60, 'numpad_1': 0x61, 'numpad_2': 0x62, 'numpad_3': 0x63, 'numpad_4': 0x64, 'numpad_5': 0x65, 'numpad_6': 0x66, 'numpad_7': 0x67, 'numpad_8': 0x68, 'numpad_9': 0x69, 'multiply_key': 0x6A, 'add_key': 0x6B, 'separator_key': 0x6C, 'subtract_key': 0x6D, 'decimal_key': 0x6E, 'divide_key': 0x6F, 'F1': 0x70, 'F2': 0x71, 'F3': 0x72, 'F4': 0x73, 'F5': 0x74, 'F6': 0x75, 'F7': 0x76, 'F8': 0x77, 'F9': 0x78, 'F10': 0x79, 'F11': 0x7A, 'F12': 0x7B, 'F13': 0x7C, 'F14': 0x7D, 'F15': 0x7E, 'F16': 0x7F, 'F17': 0x80, 'F18': 0x81, 'F19': 0x82, 'F20': 0x83, 'F21': 0x84, 'F22': 0x85, 'F23': 0x86, 'F24': 0x87, 'num_lock': 0x90, 'scroll_lock': 0x91, 'left_shift': 0xA0, 'right_shift ': 0xA1, 'left_control': 0xA2, 'right_control': 0xA3, 'left_menu': 0xA4, 'right_menu': 0xA5, 'browser_back': 0xA6, 'browser_forward': 0xA7, 'browser_refresh': 0xA8, 'browser_stop': 0xA9, 'browser_search': 0xAA, 'browser_favorites': 0xAB, 'browser_start_and_home': 0xAC, 'volume_mute': 0xAD, 'volume_Down': 0xAE, 'volume_up': 0xAF, 'next_track': 0xB0, 'previous_track': 0xB1, 'stop_media': 0xB2, 'play/pause_media': 0xB3, 'start_mail': 0xB4, 'select_media': 0xB5, 'start_application_1': 0xB6, 'start_application_2': 0xB7, 'attn_key': 0xF6, 'crsel_key': 0xF7, 'exsel_key': 0xF8, 'play_key': 0xFA, 'zoom_key': 0xFB, 'clear_key': 0xFE, '+': 0xBB, ',': 0xBC, '-': 0xBD, '.': 0xBE, '/': 0xBF, ';': 0xBA, '[': 0xDB, '\\': 0xDC, ']': 0xDD, "'": 0xDE, "`": 0xC0&#125; win32按键码.留着一份省着每次再找了]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线翻牌游戏脚本]]></title>
    <url>%2Fblhx-fanpai4-45%2F</url>
    <content type="text"><![CDATA[匹配相同的牌时是裁下每张牌后,直接对比每张图片的数组是否相同 翻牌的时候想要同时点两张牌,但是查了下adb好像没有支持mult touch,然后想到在模拟器上给每个牌的位置设置快捷键,翻牌的时候调用win32api点击对应的快捷键来翻牌. 最终成绩4.45秒.b站视频:https://www.bilibili.com/video/av44287472/ 下面是完整代码.其中vkcode.VK_CODE是win32按键码映射表,在这篇博客有 82~89行那些几个sleep的参数是试出来的,再小就容易出错了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#! /usr/bin/env python# -*- coding: utf-8 -*-import timeimport osimport cv2import numpy as npimport win32apiimport win32confrom vkcode import VK_CODEclass Blhx: def __init__(self, adbPATH, sharedPATH): self.adb = adbPATH self.sharedPATH = sharedPATH def getScreen(self, filePath="/sdcard/Pictures/tmp.png"): os.system(f"&#123;self.adb&#125; -e shell screencap -p &#123;filePath&#125;") time.sleep(0.5) return cv2.imread(f"&#123;self.sharedPATH&#125;\\tmp.png") def tap(self, X, Y): os.system(f"&#123;self.adb&#125; -e shell input tap &#123;X&#125; &#123;Y&#125;") def cutEvery(self, img): ims = [] matched = [] for y in range(3): for x in range(6): startX = 148 * x + 238 startY = 162 * y + 179 endX = startX + 90 endY = startY + 129 im = img[startY:endY, startX:endX, :] thisImInfo = (y, x, im) hasmatch = False for i, imgInfo in enumerate(ims): difference = cv2.subtract(im, imgInfo[2]) result = not np.any(difference) if result: hasmatch = True matched.append(imgInfo[:2]) matched.append(thisImInfo[:2]) del ims[i] continue if not hasmatch: ims.append(thisImInfo) return matchedkeyboardsMap = [ "QWERTY".lower(), "ASDFGH".lower(), "ZXCVBN".lower()]def mian(): blhx = Blhx(r"E:\programfiles\adb\adb.exe", "J:\ldmnqshare") blhx.tap(800, 485) time.sleep(1.1) print("jietu") im = blhx.getScreen() pos = blhx.cutEvery(im) ks = [] for i, p in enumerate(pos): k = keyboardsMap[p[0]][p[1]] ks.append(k) kl = ks.__len__() if not kl == 18: print("没匹配好") return time.sleep(1) for x in range(9): k0 = 2 * x k1 = k0 + 1 kNode0 = ks[k0] kNode1 = ks[k1] win32api.keybd_event(VK_CODE[kNode0], 0, 0, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode1], 0, 0, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode0], 0, win32con.KEYEVENTF_KEYUP, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode1], 0, win32con.KEYEVENTF_KEYUP, 0) print("tap") time.sleep(0.375)if __name__ == '__main__': mian()]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>碧蓝航线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cuclasses]]></title>
    <url>%2FCuclasses%2F</url>
    <content type="text"><![CDATA[介绍 Cuclasses是我正在写的python库,内容是集合了一些常用的类和方法 项目地址 pypi(少有更新):https://pypi.org/project/cuclasses/ github:https://github.com/HHHHhgqcdxhg/cuclasses 模块 cuclasses.DottableDict 顾名思义,能用 “.” 访问的dict.因为喜欢js访问对象属性的方式,可以用下标,也可以用点. cuclasses.singleton 装饰器. 被装饰的类为单例模式 cuclasses.CallableDict 可以调用的dict,调用时返回自身. cuclasses.StrKeyDict 在查询时把非字符串键转换为字符串的dict cuclasses.headerCopy2Dict 因为在复制chrome开发者工具network里请求的header时很不方便,就弄了这个…把chrome里的headers复制进去,会转换成字典 123456789101112headerStr = """Accept: application/json, text/plain, */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-aliveCookie: l=v; buvid3=08DBF55E-086D-4BE2-9FCB-4B60BFA5F05A140254infocHost: message.bilibili.comOrigin: https://www.bilibili.comReferer: https://www.bilibili.com/video/av9912938/?p=11User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"""a = headerCopy2Dict(headerStr)print(a)#&gt;&gt;&gt; &#123;'Accept': 'application/json, text/plain, */*', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Host': 'message.bilibili.com', 'Origin': 'https://www.bilibili.com', 'Referer': 'https://www.bilibili.com/video/av9912938/?p=11', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125; cuclasses.timePrint 上下文管理器. 带时间戳的print.随时可指定时间格式 12345678910111213141516with timePrint() as print: print(0) # &gt;&gt;&gt; [2019-02-10 16:23:35] 0 print(1, strf="[%Y-%m-%d %H:%M:%S]1") # &gt;&gt;&gt; [2019-02-10 16:23:35]1 1with timePrint("[%Y-%m-%d %H:%M:%S]2") as print: print(2) # &gt;&gt;&gt; [2019-02-10 16:23:35]2 2 print(3, strf="[%Y-%m-%d %H:%M:%S]3") # &gt;&gt;&gt; [2019-02-10 16:23:35]3 3print(4)# &gt;&gt;&gt; 4 cuclasses.timeCount 装饰器.接受两个参数. 被装饰的函数将在执行后打印执行时间 12:param enable: 设为False则不计时,直接执行函数:param method: 可选择的计时所用的获取时间的函数.默认time.perf_counter,或者也可以选填time.time,python3.7可以按需选用time.perf_counter_ns 1234567@timeCount()def bar(): print(&#123;"a": "c"&#125;)bar()#&gt;&gt;&gt; &#123;'a': 'c'&#125;#&gt;&gt;&gt; func bar excuted in : 6.044444444444444e-05 cuclasses.Downloader 下载器. 1234:param directory:下载到的目录:param urls:需要下载的资源目录:param threads:并行下载的线程数:param headers:请求头,默认为&#123;&quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;&#125; with open("xx.json","r") as f: data = json.load(f) d = Downloader(directory=r"E:\ACG\comic\general\どうして私が美術科に",urls=data) d.downloadAll()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站的搭建]]></title>
    <url>%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[依赖 本博客基于Hexo生成,选用Next.Mixins作为主题 正文 主题 不是很喜欢黑黑的颜色,就把css里颜色改了改,改成了蓝色的主题 写作工具 VSC + MPE写md不要太爽(atom,sublime应该一样) 图床 图床用的是七牛云 上传图片至图床的工具是PicGo,同样不要太爽 现在是vs-picgo了,爽上加爽 deploy 不是很清楚hexo clean和hexo generate的关系,索性每次deploy的时候都先hexo clean再hexo g再hexo d.因为很麻烦,就写了段C++做成个exe int main() { system("hexo clean"); system("hexo g"); system("hexo d"); return 0; } 之后就把编译出来的exe命名为d.exe放到项目根目录,之后每次deploy就./d就完事了 评论 之前选用的livere,现在换成了Valine]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[azurlane-painting开发笔记]]></title>
    <url>%2Fazurlane-painting%2F</url>
    <content type="text"><![CDATA[dalao的开发过程 我的开发过程 repo : https://github.com/HHHHhgqcdxhg/azurlane-painting 图片处理过程: 将图片缩小 -&gt; 将图片色彩聚类到16色 -&gt; 将聚类后的16色归到舰b指定的8色 -&gt; 合成画板图片]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bilibili机器人更新日志]]></title>
    <url>%2Fbili-bot-release-log%2F</url>
    <content type="text"><![CDATA[19/06/20 自动搬运youtube视频部署上线 19/05/13 开启广告位招租 19/03/03 重构项目的转推部分 19/02/18 取消对以关键字&quot;【お知らせ&quot;开头的推特的图片打水印(那个图太小了) 19/02/07 取消对以关键字&quot;【接続障害&quot;开头的推特的转推(即日服服务器故障和故障修复的推文) 19/01/27 增加图片水印 18/12/24 修复IOS端点开大图一直正在加载的问题 18/12/21 自动在回复中发送机翻 18/12/20 取消对以关键字&quot;【メンテナンス&quot;开头的推特的转推(即日服维护说明) 18/12/19 䒕黃苽机器人开始运行]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>bot</tag>
        <tag>bilibot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B站碧蓝航线转推姬介绍]]></title>
    <url>%2Fbili-bot%2F</url>
    <content type="text"><![CDATA[简介 这里是䒕黃苽B站机器人的介绍 非碧蓝航线官方.是个机器人.会实时转发碧蓝航线新推特和Youtube上的新视频到B站.qq裙: 881800897 主要活动 转发碧蓝航线日服官推 由自动程序控制 会实时转发碧蓝航线官方推特@azurlane_staff的推文到bilibili动态,并在评论区附上百度翻译得来的译文 转载Youtube碧蓝航线频道的投稿 由自动程序控制 会实时转发碧蓝航线官方Youtube频道@アズールレーン的新视频到bilibili 碧蓝航线直播转播 墙外的直播会进行转播 转播是直接将直播源的媒体流转发,保证与直播源完全一致无任何私货. 直播间: https://live.bilibili.com/21334927 碧蓝航线直播录播 无论墙内还是墙外的直播都会进行录播. 录播同样是对直播源媒体流直接抓流,保证与直播源完全一致无任何私货. 机器人特性 因为是机器人,所以很多方面不可能比得上万物之灵长的人类啦 䒕黃苽机器人会无差别地搬运推特,做不到对优质内容的筛选 有时候主人会调试机器人功能,可能会发一些迷之动态,这时如果看到了无视就好 当然这种一般会在半夜进行,并且尽快删掉 虽说是机器人,主人也会上这个账号,偶尔注入灵魂不要吃惊哦 合作 片源合作 䒕黃苽有着一手瓜游相关的视频和直播的抓流资源,如果烤肉组需要片源可以联系我 想要其他的机器人? 如果你想像本转推姬一样,实时搬运其他的推主的推特或Youtuber的新视频到B站,都可以联系䒕黃苽 需要自备一个拿来转推的B站账号 注意B站限制绑定了手机号的账号才能发动态 联系主人 主人是@蔳莼菂小黃苽. 主人QQ:2894700792 加好友的认证信息请认真填写 也可以通过关于我中的社交平台账号进行联系 其他 更新日志 䒕黃苽B站碧蓝航线转推姬更新日志 䒕黃苽QQ机器人 䒕黃苽除了B站的这个机器人以外,还有QQ机器人,会实时转发碧蓝航线日服官推到QQ群 881800897 具体请见䒕黃苽QQ机器人使用指南 投喂 运行机器人还是有成本在的哦,希望有钱人dalao能帮䒕黃苽分担一下 打赏¥3.00 打赏¥10.00 打赏¥23.33 打赏¥66.66 打赏¥100.00 或前往https://blog.ggemo.com/feed/查看更多打赏渠道]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>bot</tag>
        <tag>bilibot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小黄瓜机器人使用指南]]></title>
    <url>%2Fbot-help%2F</url>
    <content type="text"><![CDATA[介绍 小黄瓜机器人QQ:2482513293 小黄瓜详细功能列表见下文 想要自己的群拥有小黄瓜的话请前往加群准则 所有可能烦人的功能都是可以群管理发送指令开启/关闭的 想要做一个跟小黄瓜类似的机器人,可以跳转至技术相关 加群准则 因为加群太多会使服务器负担太大,所以会控制加群数量. 想要自己的群拥有小黄瓜的话需要以下步骤: 通读本文.找到文中藏着的6位暗号,即可证明通读了本文. 确保要拉的裙满足条件(条件并不严格哦) 并加䒕黃苽机器人为好友 加好友后 私聊䒕黃苽机器人告知一声(不用等回复即可进行下一步) 拉䒕黃苽进群 6位暗号的第1, 2, 3位: 啊哈哇 下一处暗号位置: 联系主人功能 功能列表 无指令功能 点击功能跳转到对应位置 功能 机器人需要管理权限 控制开关 转发推特功能 否 !tweetConfig指令 复读机随机禁言功能 是 !fuduBanConfig指令 新人入群提醒功能 否 !welcomeConfig指令 指令功能 指令功能是通过发送以感叹号开始的指令触发的功能,中文或英文感叹号均可,无视大小写. 点击功能跳转到对应位置 指令 功能 机器人需要管理权限 限管理可用 控制开关 !help 帮助功能 否 否 无 !fuck 众裁功能 是 否 指令 !sleep 金质睡眠功能 是 否 指令 !del 定时撤回消息功能 是 否 指令 !recipe 获取一份假的食谱功能 否 否 指令 !build 碧蓝航线建造模拟器 否 否 指令 !tweetConfig 设置转发推特的功能 否 是 无 !enable 开启功能的功能 否 是 无 !disable 关闭功能的功能 否 是 无 !report 联系主人功能 否 是 无 功能详情 新人入群提醒功能 !welcomeConfig指令限管理可用 有新人入群时,小黄瓜机器人将@新人,发送入群提醒 管理可通过发送 !welcomeConfig + 内容 来指定入群提醒内容 如: 12!welcomeConfig欢迎加入善良可爱小海豹保护者协会群!请先阅读群置顶公告哦! 注: 设置的入群提醒不宜太长,避免刷屏.建议提醒阅读群公告,内容写在群公告即可 设置的入群提醒中的图片将被忽略 !welcomeConfig后不跟内容,将取消入群提醒 复读功能 通过指令开/关功能 小黄瓜检测到有人在复读,就会跟着复读 因不堪网络暴力机器人发消息太多会被腾讯制裁,本功能停止使用 复读机随机禁言功能 !fuduBanConfig指令限管理可用 | 机器人需要管理权限 管理可通过发送类似下面的消息,更改禁言复读机配置 1234567!fuduBanConfig&#123; &quot;banLen&quot;: 2, &quot;banMult&quot;: 10, &quot;banRebel&quot;: false, &quot;randMemberMode&quot;: 2, &quot;randTimeMode&quot;: 3&#125; 对配置的解释如下: 字段名描述可选值对应效果banLen触发复读禁言条数>= 2复读条数(算上 被复读的那一条) 大于等于 这个值时,触发复读禁言 banMult禁言力度>= 1控制禁言时长的力度banRebel 是否开启禁言复读机叛徒true此时,如果是参与复读的人打断复读,则不再进行复读机随机抽取,而是直接抽中这名复读机叛徒false正常进行复读机抽取randMemberMode抽取复读机的模式0关闭本功能,不再禁言复读机1随机抽取一名复读机2正态分布随机抽取一名复读机3取倒数第二个复读机randTimeMode抽取禁言时长的模式1经典随机,禁言时间为 (1~本轮复读条数 之间的随机数) * banMult2复读总长相关,禁言时间为 本轮复读条数 * banMult3固定时长,禁言时长为 banMult4按座位,被抽到的复读机在本轮复读中是倒数第n个,时长就为 n * banMult 众裁功能 本功能为指令功能,通过发送 !fuck + @一名群员 触发 通过指令开/关功能 | 机器人需要管理权限 在一人通过该指令开启对一名群员A的众裁之后,将开始三分钟的计时,统计三分钟内通过该指令参与对群员A的众裁的人数,于三分钟后对群员A进行制裁(禁言) 禁言时长: 参与本轮众裁人数 禁言时长(分钟) &lt;= 2 不禁言 3 5 4 10 &gt;= 5 每多一人,时长加2 注: !fuck后面跟上@一名群员,这个@必须是能@到人的,复制粘贴的不管用 不要重复参与众裁,否则会被禁言1分钟 不要再众裁群主管理辣! 不要欺负人哦,拿来制裁海豹正适合 定时撤回消息功能 本功能为指令功能,通过发送 !del + 时长 + 空格 + 消息 触发 通过指令开/关功能 | 机器人需要管理权限 示例: 1!del 10 这条消息将在10秒后被撤回 注: 如 !del 后不加时长,直接跟消息,则默认撤回时长为5秒 如设置时长,记得时长数字和后面消息中间用空格分隔 设置时长最大为600,超过这个值将改为5 本功能为限 非管理群员 使用 金质睡眠功能 本功能为指令功能,通过发送 !sleep 触发 通过指令开/关功能 | 机器人需要管理权限 22:00~次日03:59发送指令,发送者将被禁言6小时 食谱功能 本功能为指令功能,通过发送 !recipe 或 !gbf触发 通过指令开/关功能 | 消耗黄瓜片 : 20 发送一份分享,标题和图片为随机食谱的标题和图片,点开却是granbluefantasy.jp 碧蓝航线建造模拟器 本功能为指令功能,通过发送 !build 触发 通过指令开/关功能 | 消耗黄瓜片 : 40 !build可接受最多两个正整数参数,用逗号分隔(中英文标点均可) 指令 效果 !build 抽取1池10次 !build x 抽取x池10次,x可为1,2,3 !build x,y 抽取x池y次,y为1~10 注: 概率保证按照官方给出的概率 卡池信息来自着迷碧蓝航线wiki建造模拟器 不准备做限时建造的卡池,想玩的请移步着迷碧蓝航线wiki限时建造模拟器 本功能需要生成图片发送图片,对服务器资源消耗过大,不要玩太过分哦 如果!build没有反应,或者只回复文字不显示图片,就代表被腾讯限制了,这时候就要稍后再试 转发推特功能 !tweetConfig指令限管理可用 小黄瓜会实时转发指定推特用户发送的新推特至qq群 新加的群是不会转发推特的,需要经过设置后,可转发指定推特 设置方法:发送类似如下的消息,可添加或修改推特转发: 12345678910111213!tweetConfig&#123; &quot;follow&quot;:&#123; &quot;name&quot;:&quot;@azurlane_staff&quot;, &quot;nickName&quot;:&quot;碧蓝航线日服推特&quot; &#125;, &quot;groupInfo&quot;: &#123; &quot;nickName&quot;: &quot;在这里填写群名&quot;, &quot;trans&quot;: true, &quot;sendRT&quot;: false, &quot;mediaOnly&quot;:false, &quot;follow&quot;: true &#125;&#125; 以下为对上面配置的解释: 12345678910111213!tweetConfig&#123; &quot;follow&quot;:&#123; &quot;name&quot;:&quot;这里填入需要关注的人的推特Id,以@开头&quot;, &quot;nickName&quot;:&quot;这里填入关注的人的称呼&quot; &#125;, &quot;groupInfo&quot;: &#123; &quot;nickName&quot;: &quot;群名&quot;, // 在这里填写群名,理论上随便填,主要目的是让作者辨识出是哪个群 &quot;trans&quot;: true, // 是否需要发送一遍将经过百度翻译的推文,把true改成false将不翻译 &quot;sendRT&quot;: false, // 是否需要发送 转发和回复别人的推特,建议关闭,打开很烦人的,把false改成true打开 &quot;mediaOnly&quot;: false, // 将false改成true,将只发有图片内容的推特,纯文字推特将忽略,适合关注画师 &quot;follow&quot;: true // 将true改为false,将不转发此人的推特 &#125;&#125; 注意: 这条消息除开头的!tweetConfig以外,全部大小写敏感且必须用半角标点符号(即英文标点) 大括号,冒号,逗号,引号都不能漏 不要将true打成ture,false打成flase… 若出现&quot;查找用户信息失败&quot;提示,请确定关注的人的id以@符号开头,确认无误后稍后再试 设置转发后,机器人需要花几秒时间准备,因此这几秒内做不到转推 附录中给出了些常用推特供参考 开启功能的功能 本功能为指令功能,通过发送 !enable + 其他功能指令 触发 限管理可用 指令 功能 !enable !sleep 开启金质睡眠功能 !enable !fuck 开启众裁功能 !enable !recipe 开启食谱功能 !enable !build 开启碧蓝航线建造模拟器 !enable !del 开启定时撤回消息功能 注:无视所有感叹号全/半角,不区分大小写 关闭功能的功能 本功能为指令功能,通过发送 !disable + 其他功能指令 触发 限管理可用 指令 功能 !disable !sleep 关闭金质睡眠功能 !disable !fuck 关闭众裁功能 !disable !recipe 关闭食谱功能 !disable !build 关闭碧蓝航线建造模拟器 !disable !del 关闭定时撤回消息功能 注:无视所有感叹号全/半角,不区分大小写 联系主人功能 本功能为指令功能,通过发送 !report 触发 !report指令限管理可用 机器人接收到以!report开头的消息,会发送给主人看到 注: 乱玩此功能会打扰到主人的,请不要乱玩 机器人功能相关请先仔细阅读本篇文档对应部分以及Q&amp;A部分 在群里直接@小黄瓜机器人,主人一般情况下看不到的 私聊小黄瓜机器人,主人一般情况下看不到 使用!report指令的消息,主人会看到,并尽量及时回应 按照下面联系方式联系主人,是比较有效的联系方式 有事请直接说事,免掉&quot;在吗&quot;之类的打招呼内容 谢绝无事骚扰 主人QQ:2894700792 加好友的认证信息请认真填写 6位暗号的第4位: 噗 下一处暗号位置: 限管理可用功能 黄瓜片系统 出于目的: 防止功能滥用对小黄瓜服务器造成太大负担 防止某些功能造成刷屏 防止被tx限制 现在实装黄瓜片系统,某些功能需要消耗黄瓜片(黄瓜片就是类似体力的东西啦) 获得黄瓜片 小黄瓜机器人会在每天凌晨04:30,中午13:30,晚上19:30将所有群友的黄瓜片置为40点. 即,黄瓜片不可积攒,每个时间段40点 消耗黄瓜片 消耗黄瓜片的功能 功能 消耗黄瓜片数/次 碧蓝航线建造模拟器 40 食谱功能 20 其他 小黄瓜机器人的管理权限 给小黄瓜管理权限后,机器人并不能马上意识到自己是管理,需要重启插件,这时通过联系主人功能告知重启 限管理可用功能 本文中的&quot;管理&quot;,皆指 管理or群主 把部分功能做成仅限管理可用,目的是过滤掉没素质的人,希望身为管理能意识到自己的一份素质,不要闲来无事report玩,或者凭一己之见关注一些奇怪或无聊的推特 6位暗号的第5位: 嘤 下一处暗号位置: QA idea相关 有觉得好玩的机器人的玩法的想法,可以联系主人哦 技术相关 因为小黄瓜机器人项目中有很多小黄瓜的apikey和OAuth认证信息,开源很麻烦,所以闭源 小黄瓜机器人项目代码是使用python编写,通过richardchien/coolq-http-api和richardchien/python-aiocqhttp控制酷Q实现的, 监听新推特是通过tweepy.StreamListener实现 酷Q只能跑在windows或有图形界面的linux服务器上,本人使用的服务器是阿里云服务器的学生机 其他的䒕黃苽 䒕黃苽bilibili机器人:@碧蓝航线转推姬 会将碧蓝航线新日推转发到B站动态,并在评论区附上翻译 䒕黃苽B站机器人介绍 䒕黃苽微博机器人:@碧蓝航线转推姬(和B站的同名哦) 会将碧蓝航线新日推转发到微博 其他相关 希望群友们素质聊天 投喂 运行机器人还是有成本在的哦,希望有钱人dalao能帮䒕黃苽分担一下 更多打赏渠道: https://blog.ggemo.com/feed/ 打赏¥3.00 打赏¥10.00 打赏¥23.33 打赏¥66.66 打赏¥100.00 QA QA1 Q: 建造模拟器怎么没有限定池? A: 䒕黃苽机器人的建造模拟器数据来源为着迷碧蓝航线wiki建造模拟器.而wiki并没有限定池详细信息,在着迷碧蓝航线wiki限时建造模拟器中,未知角色用问号代替,而䒕黃苽建造模拟器比较在意真实和美观,不乐意用问号这种.想玩的话还请前往着迷碧蓝航线wiki限时建造模拟器. QA2 Q: 建造模拟器概率是不是有问题啊? A: 概率纯粹按照官方给出的概率进行随机抽取,然而实际游戏中可能并非如此(详细可以看下这个视频: bilibili - 揭秘游戏氪金抽卡的“黑幕”【游戏侦查冰】 - 芒果冰OL),故可能感官上和真实游戏中有所不同. QA3 Q: !build经常会没有反应或者只回复文字没有图片,是怎么回事? A: 图片发多了会被腾讯限制,一段时间内发不出图片的,这种时候还请稍候再试 QA4 Q: 为什么我拉䒕黃苽机器人进群或者加好友没有反应? A: 加群准则见本页加群准则.加好友没有反应一定是因为加好友理由是乱填. QA5 Q: 䒕黃苽机器人是有收费的吗? A: 䒕黃苽机器人暂时没有任何付费功能,入群无租金,黄瓜片不可充值.不过如果你钱比较多还喜欢䒕黃苽的话还请通过本页面的投喂进行资助. QA6 Q: 可以 拍/切/剁/用 黄瓜吗? A: 是不可以的. QA7 Q: 䒕黃苽主人是个什么人? A: https://blog.ggemo.com/about/ 6位暗号的第6位: 咕 附录-常用推特id 推特id 备注 @korindo 博丽神主推特 @kirarafantasia 芳文社手游きららファンタジア官推 @azurlane_staff 碧蓝航线日服官推]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>qqbot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python程序打包成exe]]></title>
    <url>%2Fpy2exe%2F</url>
    <content type="text"><![CDATA[前言 用python写了个项目(在这)想发布出去给没有python环境的人用.试了pyinstaller,打包出来不能正常跑…于是心生淫技,将python环境跟项目放到一起,然后拿C写几行程序,通过system call的方式调用python运行项目脚本,再将这个C程序编译成exe… python环境的准备 我首先试了拿虚拟环境,然后发现虚拟环境少了一堆dll…拿自己的python环境吧,一堆这个项目用不着的库,打包进去太大,挑出来太麻烦…索性另外装一个python.我本身环境是3.6.7版本的,又去另外装了个3.7.2版本.安装时注意把什么设置环境变量,向所有用户安装都取消了,留着pip就好,之后拿pip把包都装好,然后把整个python目录拷贝到项目根目录就完事了 准备一个exe 这就比较野蛮…程序入口12345678910111213141516171819202122```C++#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;direct.h&gt; using namespace std;int main(int argc, char * argv[])&#123; string cwd = _getcwd(NULL, 0); string cmd = &quot;\\Python37-32\\python.exe __main__.py&quot;; cmd = cwd + cmd; for (int i = 1; i &lt; argc; i++) &#123; cmd += &quot; &quot;; cmd += argv[i]; &#125; const char *cmd_c_str = cmd.c_str(); // cout &lt;&lt; cmd_c_str&lt;&lt;endl; system(cmd_c_str); //system(&quot;pause&quot;); return 0;&#125; 编译好拿出来放到项目根目录就完事了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桌面追番助手]]></title>
    <url>%2FbangumiDesktopAssistant%2F</url>
    <content type="text"><![CDATA[本项目git仓库:https://dev.tencent.com/u/hhhhhg/p/bangumiDesktopAssistant 尝试了打包成exe却做不到,所以应该只有装了python才能用了XD python版本是3.6.4(因为用到了f前缀字符串,所以大概需要至少3.6版本),操作系统只试了windows 使用: 1234git clone https://git.dev.tencent.com/hhhhhg/bangumiDesktopAssistant.gitcd bangumiDesktopAssistantpip install -r requirements.txtpython __main__.py 在任务栏找到图标(和项目头像是同一张图片),右键可进行追番编辑或者退出程序. 追番编辑工具按要求填入信息,可生成一份番剧信息,保存在src/db/bangumisInfo中,如果填入得当,不发生意外,则可正常使用. 遇到特殊情况(比如番剧停更)则需要手动改对应的json文件中的chapters部分… 有番剧更新时,会播放音频,为src/audio/alarm.wav 透明度,配色等配置存在src/db/config.json中,可以轻易更改 配置好环境后,之后可以运行bangumi.bat来运行本工具,也可在注册表中将bangumi.bat设为开机自启 运行截图: 1080p屏幕下unfocused状态表现 1080p屏幕下focused状态(鼠标悬停在之上时)表现 之前用tkinter写了两天了,察觉有点不好用,又换成了PyQt5. 耗资源方面,平常在后台运行就占用十几二十M内存]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>动漫</tag>
        <tag>gui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投喂]]></title>
    <url>%2Ffeed%2F</url>
    <content type="text"><![CDATA[我很努力(ง •̀_•́)ง 请给我钱 (σ $﹃$)σ 做䒕黃苽机器人还是有些成本在的,请帮帮䒕黃苽回回本吧! 爱发电 ￥ 爱发电 支付宝 打赏¥3.00 打赏¥10.00 打赏¥23.33 打赏¥66.66 打赏¥100.00 微信 打赏¥3.00 打赏¥10.00 打赏¥23.33 打赏¥66.66 打赏¥100.00 请给我钱 我什么都不会做的 .hgImgHolder{width:auto;height:200px;float:left}]]></content>
      <tags>
        <tag>投喂</tag>
      </tags>
  </entry>
</search>
