<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dubbo笔记-1-总体大图]]></title>
    <url>%2Fdubbo-1%2F</url>
    <content type="text"><![CDATA[总体分层 总体分为业务层(Biz),RPC层,Remote层 进一步划分可以分成10层,左边的是具体的分层,右边是该层中比较重要的接口 Dubbo核心组件 层次名 作用 Service 业务层 包括业务代码的接口与实现,即开发者实现的业务代码 config 配置层 主要围绕ServiceConfig(暴露服务配置)和ReferenceConfig(引用服务配置)两个实现类展开,初始化配置信息可以理解为该层管理了整个Dubbo配置 proxy 服务代理层 在Dubbo中,无论生产者还是消费者,框架都会生成一个代理类,整个过程对上层是透明的.当调用一个远程交口时,看起来就像是调用了一个本地接口一样,代理层会自动做远程调用并返回结果,即让业务层对远程调用无感 cluster 集群容错层 该层主要负责:远程调用失败时的容错策略(如失败重试,快速失败);选择具体调用节点时的负载均衡策略(如随机,一致性Hash等);特殊调用路径的路由策略(如某个消费者只会调用某个特定的生产者) monitor 监控层 这一层主要负责监控统计调用次数和调用时间等 protocol 远程调用层 封装RPC调用具体过程,Protocol是Invoker暴露和引用的主功能入口,它负责管理Invoker的整个生命周期.Invoker是Dubbo的核心模型,框架中所有其他模型都向它靠拢,或者转换成它.允许它发起invoke调用,它可能是执行一个本地的接口实现,也可能是一个远程的实现,还可能一个集群实现 exchange 信息交换层 建立Request-Response模型,封装请求响应模式,如把同步请求转化为异步请求 transport 网络传输层 把网络传输抽象为统一接口,如Mina和Netty虽然接口不一样,但是Dubbo在它们上面又封装了统一接口.用户也可以根据其扩展接口添加更多的网络传输方式 Serialize 序列化层 负责管理整个框架网络传输时的序列化/反序列化工作 Dubbo总体调用过程 服务提供方 首先服务提供者在框架启动时,会初始化服务实例,通过Proxy组件调用具体协议(Protocol),把服务端要调用的接口封装成Invoker,然后转换成Exporter,这个时候框架会打开服务端口等并记录服务实例到内存中,最后通过Register把服务元数据注册到注册中心 Proxy Dubbo只需要引用一个接口就可以调用远程的服务,并且只需要像调用本地方法一样调用即可.其实Dubbo框架为我们生成了代理类,调用的方法其实是Proxy组件生成的代理方法,会自动发起调用返回结果. Protocol 协议是对数据格式的一种约定.它可以把我们对接口的配置根据不同的协议转换成不同的Invoker对象.如DubboProtocol可以把XML文件中一个远程接口的配置转换成一个DubboInvoker. Exporter 用于暴露到注册中心的对象,它的内部属性持有了Invoker对象,可以认为它是在Invoker上包了一层 Register 把Exporter注册到注册中心 服务调用方 消费放会在启动时会通过Registry在注册中心订阅服务端的元数据(包括IP和端口),这样就可以得到服务提供方暴露的服务了. 首先,调用过程也是从一个Proxy开始的,Proxy持有了一个Invoker对象,然后触发invoker调用.在invoker调用过程中,需要使用Cluster负责集群容错.Cluster在调用之前会通过Director获取所有可以调用的远程服务Invoker列表.由于可以调用的远程服务有很多,此时如果用户配置了路由规则(如制定某些方法调用某个特定节点),那么还会根据路由规则将Invoker列表过滤一遍. 然后,可选择的Invoker可能还会有很多,决定要调用哪一个的话要通过LoadBalance方法做负载均衡,最终选出一个拿来调用的Invoker.这个Invoker在调用之前优惠经过一个过滤器链,这个过滤器链通常是处理上下文,限流,计数等. 接着,会使用Client做数据传输,如我们常见的Netty Client等.传输之前肯定要做一些私有协议的构造,此时就会用到Codec接口.构造完成后,就会对数据包进行序列化,然后传输到服务提供者端.提供者接收到数据包,也会使用Codec处理协议头以及一些半包,粘包等.处理完成后再对完整的数据报文做反序列化处理. 随后,这个Request会被分配到ThreadPool中进行处理,Server会处理这些Request,根据请求查找对应的Expoter(它内部持有Invoker).Invoker是被装饰器模式一层一层套了非常多的Filter的,因此在调用最终的实现类之前,又会经过一个服务提供者的过滤连. 最终,我能得到了具体接口的真是实现并调用,再原路把结果返回.]]></content>
      <categories>
        <category>dubbo笔记</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo笔记-0-概述]]></title>
    <url>%2Fdubbo-0%2F</url>
    <content type="text"><![CDATA[dubbo思想 微内核 + 富插件 dubbo特性 分类 特性 面向接口代理的高性能RPC调用 提供高性能的基于代理的远程调用能力,服务以接口为粒度,为开发者屏蔽远程调用的底层细节 服务与自动发现 支持多种注册中心服务,服务实例上下线实时感知 运行期流量调度 内置条件,脚本等路由策略,通过配置不同的路由规则,轻松实现灰度发布,同机房优先等功能 负载均衡 内置多种负载均衡策略,只能感知下游节点的健康状况,逐渐减少调用延迟,提高系统吞吐量 高度可扩展能力 微内核 + 富插件,所有核心能力(如Protocol,Transport,Serialization被设计为扩展点,平等对待内核实现和第三方实现) 可视化的服务治理与运维 提供丰富服务治理,运维工具,随时查询服务元数据,服务健康状态及调用统计,实时下发路由策略,调整配置参数 dubbo解决什么问题 高性能,透明的RPC调用 Dubbo可以让开发者像调用本地的方法一样调用远程服务,而不需要显式在代码中指定是远程调用,整个过程对上层开发者透明,dubbo会自动完成后续操作,如负载均衡,路由,协议切换,序列化等,开发者只需要接受对应的调用结果即可 服务的自动注册与发现 自动负载均衡与容错 Dubbo提供了完整的集群容错机制,可以实现软件层面的负载均衡,以此降低硬件的压力,Dubbo还提供了调用失败的各种容错机制,如Failover,Failefase,结果集合并等. 动态流量调整 在应用运行时,某些服务节点可能因为硬件原因需要减少负载,或者某些节点需要人工手动下线,又或者需要实现单元化的调用,灰度功能;Dubbo提供了管理控制台,用户可以在界面上动态地调整每个服务的权重,路由规则,禁用/启用,实现运行时的流量调度 依赖分析与调用统计 当应用规模进一步提升,服务间的依赖关系变得错综复杂,甚至分不清那个应用要在哪个应用之前启动,架构师都不能完整地描述应用的架构关系.服务的调用量越来越大,服务的容量问题就暴露出来,这个服务需要多少机器支撑?什么时候该加机器?Dubbo可以接入三方APM做分布式链路追踪与性能分析,或者使用已有的独立监控中心来监控接口的调用次数及好事,用户可以根据这些数据反推出系统容量]]></content>
      <categories>
        <category>dubbo笔记</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方舟编译器]]></title>
    <url>%2FArkCompiler%2F</url>
    <content type="text"><![CDATA[方舟编译器大概是这个意思? 不是很清楚它编译的时机是什么…是app安装的时候? 2019年8月9日20:48:27补充,看了华为开发者大会,编译的时机是发布前]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里一面笔记]]></title>
    <url>%2Finterview-ali-1%2F</url>
    <content type="text"><![CDATA[没答上来的问题 01 Q: dubbo他内部的通信协议是什么? A: 不知道 事后: 太深了,以后慢慢来吧. 02 Q: 万一我们数据库操作成功了,但是返回给客户端的时候网络波动了,应该怎么办 A: 答的乱七八糟… 事后: 白井姐姐: 返回的时候,如果网络波动了,没有合法的关闭连接的话,服务端会察觉到,察觉到的话就回滚… wasup: 用PUT方法 03 Q: 依赖注入详细点是如何做的?bean互相依赖,应该怎么办? A: 不知道… 事后: 好像是什么,三重缓存? 04 Q: 成绩表,找出三门课以上不及格的同学,写出sql A: 子查询中先查出所有同学不及格科目的数量,子查询外面将超过三个的筛选出来. Q: 有没有不用子查询的方法? A: 答的乱七八糟… 事后: 用having字句… 05 Q: 联合查询 A: 懵逼 事后: 再看看联合索引吧… 06 Q: 项目使用的事务隔离级别? A: ReadCommitted Q: ReadCommitted有什么问题? A: 幻读 事后: 落了不可重复读… 07 Q: JDBC属于哪层网络协议? A: 不知道… 08 Q: 根据hash计算在桶中的位置的时候,为什么要前16位与后16做异或运算? A: 不做异或运算啊,他做与运算 事后: 我是傻逼,当时脑子蒙了 09 Q: concurrentHashMap取出来的东西一定是我们想要的吗? A: 不是,但是想不到这个场景了… 事后: 如果一个线程把某个键删了,另一个线程再取会出错. 10 Q: volatile一定是安全的吗? A: 不是,忘记这个场景了… A: 需要保证我们的操作的原子性. Q: 有什么场景? A: 比如有一个数,我们多个线程加它 Q: 如何保证原子性? A: 使用J.U.C.atomic.atomicInteger Q: 他内部是怎么实现原子性的呢? A: 不好意思我没了解到那么深入 事后: 应该大胆一点,答加锁的. 回去又翻了一下深入理解jvm,讲到了我们一个int的加法,虽然代码是看只有一行,即使编译出来只有一条字节码指令,这条指令在解释器里面也可能需要转换成若干条本地机器指令,所以不能保证原子性,要加锁. 11 Q: 有什么问题要问我的? A: 巴拉巴拉… 事后: 应该把上面不会的问题再挨个问一遍? emm 自己还是理论上的知识比较看重…问的项目里的**怎么**的都有点力不从心. emmm 2019年8月10日19:58:52 挂了 很多东西,感觉都是因为是刚学的,还没有完全融入自己的思想,还需要更多的沉淀. 应对面试时,不会的问题一定要好好思考. 比如,这次阿里面的场景题:如果返回数据的时候网络波动了怎么办,和问AtomicInteger内部原理的时候 自以为会的问题也不要张口就来,做好容错. 比如,这次问&quot;bean是不是new出来的&quot;,当时回的&quot;是&quot;,虽然后来又补了句&quot;不他是由processor初始化才&quot;,但没说到点子上(指反射),这种时候应该先答&quot;我想一下&quot;,不能被问题牵着鼻子走 1@RequestHeader(value="token") String token 1234Long operatorId = redisTool.getUserIdByToken(token);if(operatorId.equals(-1L))&#123; return ErrorEnum.VERIFY_FAILED.getResult();&#125;]]></content>
      <tags>
        <tag>面试</tag>
        <tag>阿里巴巴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五种IO模型]]></title>
    <url>%2Fio-model%2F</url>
    <content type="text"><![CDATA[IO分为两步: 等待数据准备好 数据搬迁 五种IO模型包括: 阻塞IO, 非阻塞IO, 信号驱动IO, IO多路转接, 异步IO 阻塞式IO blocking I/O 在内核将数据准备好之前一直阻塞 非阻塞IO noblocking I/O 调用程序发起系统调用之后不断轮询询问内核数据有没有准备好. 没有准备好时不会阻塞程序 信号驱动IO signal blocking I/O 当数据报准备好时,内核会给调用程序发送一个信号 在等待信号期间调用程序不会阻塞 IO多路转接 I/O multiplexing 类似于非阻塞型I/O,只不过轮询不是用户线程去执行,而是内核去轮询.内核监听程序监听到数据准备好后,调用内核函数复制数据到用户态. 异步IO asynchronous I/O 异步IO依赖信号处理程序来进行通知. 不过前面都是数据准备阶段的阻塞和非阻塞,异步IO模型通知的是IO操作已完成,而不是数据准备完成. 异步IO才是真正的非阻塞,主进程只负责做自己的事情,等IO操作完成.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java与线程]]></title>
    <url>%2Fjava-and-thread%2F</url>
    <content type="text"><![CDATA[线程的实现 使用内核线程实现 内核线程(Kernel-Level Thread, KLT) 就是直接由 操作系统内核(Kernel) 支持的线程,这种线程由内核来完成线程切换,内核通过操纵调度器(Scheduler)对线程进行调度,并负责将线程的任务映射到各个处理器上. 每个内核可以视为内核的一个分身,这样操作系统就有能力同时处理多件事情,支持多线程的内核就叫做多线程内核(Multi-Threads Kernel). 程序一般不会直接去使用内核线程,而是去使用内核线程的一种高级接口, 轻量级进程(Light Weight Process, LWP) 轻量级进程就是我们通常意义上所讲的线程. 由于每个轻量级进程都由一个内核线程支持,因此只有先支持内核线程,才能有轻量级进程. 这种轻量级线程与内核线程之间1:1的关系被称为一对一的线程模型. 由于内核线程的支持,每个轻量级进程都成为一个独立的调度单元,即使有一个轻量级进程在系统调用中阻塞了,也不会影响到整个进程的工作. 由于基于内核线程实现,所以各种线程操作,如创建,析构以及同步,都需要进行系统调用,而系统调用的代价是相对较高的,需要在 用户态(User Mode) 和 内核态(Kernel Mode) 中来回切换. 其次,每个轻量级进程都需要有一个内核线程的支持,因此轻量级进程要消耗一定的内核资源,因此一个系统支持轻量级进程的数量是有限的. 使用用户线程 从广义上讲,一个线程只要不是内核线程,就可以认为是 用户线程(User Thread) . 而从狭义上讲,用户线程指的是完全建立在用户空间的线程库上,系统内核不能感知到线程存在. 用户线程的建立,同步,销毁和调度完全在用户态中完成,不需要内核的帮助.如果程序实现得当,这种线程不需要切换到内核态,因此操作可以是非常快速且低消耗的,也可以支持规模更大的线程数量.部分高性能数据库中的多线程就是由用户线程实现的.这种进程与用户线程之间1:N的关系成为一对多的线程模型. 使用用户线程的优势在于不需要系统内核支援,劣势也在于没有系统内核的支援,所有的线程操作都需要用户程序自己去处理.线程的创建,切换和调度都是需要考虑的问题,而且由于操作系统制霸处理器资源分配到进程,那诸如阻塞如何处理,多处理器系统之如何将线程映射到其他处理器上这类问题解决起来异常困难,甚至不可能完成.除了以前在不支持多线程的操作系统中(如DOS)的多线程程序与少数有特殊需求的程序外,现在使用用户线程的程序越来越少了,Java,Ruby等语言都曾经使用过用户线程,最终又都放弃使用它. 使用用户线程加轻量级进程混合实现 在这种混合实现下,既存在用户线程,也存在轻量级进程.用户线程还是完全建立在用户空间中,因此用户线程的创建,切换,析构等操作依然廉价,并且可以支持大规模的用户线程并发.而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁,这样可以使用内核提供的线程调度功能及处理器映射,并且用户线程的系统调用要通过轻量级线程来完成,大大降低了整个进程被完全阻塞的风险. 在这种混合模式下,用户线程与轻量级进程的数量比是不定的,即为N:M的关系 Java线程的实现 对于Sun JDK来说,它的Windows版与Linux版都是使用一对一的线程模型实现的,一条Java线程就映射到一条轻量级进程之中,因为Windows和Linux系统提供的线程模型是一对一的. Java线程调度 线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是 协同式线程调度(Cooperative Threads-Sheduling) 和 抢占式线程调度(Preemptive Threads-Sheduling) 如果使用协同式调度的多线程系统,线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上. 协同式多线程的最大好处是是实现简单,而且由于线程要把自己的事情干完后才会进行线程切换,切换操作对线程自己是可知的,所以没有什么线程同步的问题. 它的最大坏处也很明显:线程执行时间不可控制,甚至如果出现一个线程编写有问题,一直不告知系统进行线程切换,那么程序就会一直阻塞在那里. 如果使用抢占式的多线程系统,那么每个线程将有系统来分配执行时间,线程的切换不由线程本身来决定(在Java中,Thread.yield()可以让出执行时间,但是要获取执行时间的话,线程本身是没什么办法的).在这种实现线程调度的方式下,线程的执行时间是系统可控的,也不会有一个线程导致整个进程阻塞的问题,Java使用的线程调度方式就是抢占式调度. 线程状态 新建(New) 创建后尚未启动的线程处于这种状态 运行(Runable) Runable包括了操作系统线程转台中的Running和Ready,也就是处于此转台的线程有可能正在执行,也有可能正在等着CPU给它分配时间 无限期等待(Waiting) 处于这种转态的线程不会被分配CPU时间,它们要等待被其他线程显式地唤醒.以下方法会让线程进入无限期等待状态: 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待(Timed Waiting) 处于这种转态的线程不会被分配CPU执行时间,不过无须等待被其他线程显式地唤醒,在一定时间之后它们由系统自动唤醒.以下方法会让线程进入限期等待状态: Thread.sleep()方法 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Thread.join()方法 LockSupport.parkNanos()方法 LockSupport.parkUntil()方法 阻塞(Blocked) 线程被阻塞了,&quot;阻塞转态&quot;与&quot;等待状态&quot;的区别是:阻塞状态在等待着获取到一个排他锁,这个时间将在另外一个线程放弃这个锁的时候发生;而等待状态则是在等待与短时间,或者唤醒动作的发生.在线程等待进入同步区域的时候,线程将进入这种状态 结束(Terminated) 已终止线程的线程状态,线程已经结束执行 线程安全 当多个线程访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步,或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果,那么这个对象是线程安全的. 这个定义比较严谨,它要求线程安全的代码都具备一个特征:代码本身封装了所有必要的保障手段(如同步互斥等),令调用者无需关心多线程的问题,更无须自己采取任何措施来保证多线程的正确调用. 在大多数场景中,我们都会将这个定义弱化一些,如果把&quot;调用这个对象的行为&quot;限定为&quot;单次调用&quot;,这个定义的其他描述也能够成立的话,我们就称它是线程安全的了. Java中的线程安全 按照线程安全的&quot;安全程度&quot;由强至弱来排序,我们可以将Java语言中的各种操作共享的数据分为以下五类:不可变,绝对线程安全,相对线程安全,线程兼容和线程对立 不可变 不可变(Immutable) 对象一定是线程安全的,无论是对象的方法实现还是方法的调用者,都不需要再采取任何的线程安全保障措施,只要一个不可变的对象被正确地构建出来(没有发生this引用逃逸的情况),那其外部的可见状态永远也不会改变,永远也不会看到它在多个线程之中处于不一样的状态.&quot;不可变&quot;带来的安全性是最简单最纯粹的. Java语言中,如果共享数据是一个基本数据类型,那么只要在定义时使用final关键字修饰它就可以保证它是不可变的.如果共享数据是一个对象,那就要保证对象的行为不会对其状态产生任何影响才行.如java.lang.String的对象,它是一个典型的不可变对象,我们调用它的substring(),replace和concat()这些方法都不会影响它原来的值,只会返回一个新构造的字符串对象. 保证对象行为不影响自己状态的途径有很多种,其中最简单的就是把对象中带有状态的变量都声明为final,这样在构造函数结束之后,它就是不可变的. 绝对线程安全 绝对的线程安全满足上面严格的线程安全的定义,一个类要达到&quot;不管运行时环境如何,调用者都不需要任何额外的同步措施&quot;通常需要付出很大的,甚至有时候是不切实际的代价.在Java API中标注自己是线程安全的类,大多数都不是绝对的线程安全. 相对线程安全 相对的线程安全就是我们通常所讲的线程安全,它需要保证对这个对象单独操作是线程安全的,我们在调用的时候不需要额外的保障措施,但是对于一些特定顺序的连续调用,就可能需要在调用端使用额外的同步手段来保证调用的正确性. 在Java中,大部分的线程安全类都属于这种类型,如Vector,HashTable,Collection的synchronizeCollection()方法包装的集合等. 线程兼容 线程兼容是指对象本身并不是线程安全的,但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用.我们平常说一个类不是线程安全的,绝大多数时候指的都是这一种情况. Java API中大部分的类都是属于线程兼容的. 线程对立 线程对立是指无论调用端是否采取了同步措施,都无法在多线程环境中并发使用的代码. 线程对立很少出现. 线程安全的实现方法 互斥同步 互斥同步(Mutual Exclusion &amp; Synchronization) 同步是指在多个线程并发访问共享数据时,保证共享数据在同一个时刻只被一个(或者是一些,使用信号量的时候)线程使用. 而互斥是实现同步的一种手段,临界区(Critical Section) , 互斥量(Mutex) 和 信号量(Semaphore) 都是主要的互斥实现方式. 互斥是因,同步是果;互斥是方法,同步是目的. Synchronized 在Java中,最常用的互斥同步手段就是synchronized关键字. synchronized关键字经过变异之后,会在同步块前后分别行程 monitorenter 和 monitorexit这两个字节码指令 这两个字节码指令都需要一个reference类型的参数来指明要锁定的对象. 如果Java程序中的synchronized明确指定了对象,那就是这个对象的reference 如果没有明确指定,那就根据synchronized修饰的是实例方法还是类方法,去取对应的对应的对象实例或Class对象作为锁对象. 在执行monitorenter指令时,首先会尝试获取对象的锁,如果这个对象没被锁定,或者当前进程已经拥有了那个对象的锁,把锁的计数器加1 在执行monitorexit指令时会将锁计数器减1,当计数器为0时,锁就被释放. 如果获取对象锁失败,那当前线程就要阻塞等待,知道对象锁被另外一个线程释放为止. 虚拟机规范在堆monitorenter和monitorexit的行为描述中,有两点是需要注意的: synchronized同步块对同一条线程来说是可重入的,不会出现自己把自己锁死的情况. 同步块在已进入线程执行完之前,会阻塞后面其他线程的进入.因Java的线程是映射到轻量级进程中的,如果需要阻塞或唤醒一个线程,都需要操作系统来帮忙完成,这就需要从用户态转换到核心态,因此状态需要消耗很多的处理器时间.所以synchronized是Java语言中一个重量级(Heavyweight)的操作.而虚拟机本身会进行优化,比如在通知操作系统阻塞进程之前加入一段自旋等待过程,避免频繁在用户态与内核态之间切换. JUC 也可以通过JUC包中的 重入锁(ReentrantLock) 来实现同步.ReentrantLock与synchronized很相似,他们都具备一样的线程重入特性,只是代码写法上有点区别,一个表现为API层面的互斥锁,另一个表现为远胜于法层面的互斥锁. ReentrantLock相比synchronized增加了一些高级功能,主要为以下三种: 等待可中断 当持有锁的线程长期不释放锁的时候,正在等待的线程可以选择放弃等待,改为处理其他事情,可中断特性对处理执行时间非常长的同步块很有帮助. 公平锁 公平锁是指多个线程在等待同一个锁的时候,必须按照申请锁的时间顺序来依次获得锁.而非公平锁在释放时,任何一个等待锁的线程都有机会获得锁. 锁绑定多个条件 一个ReentrantLock可以同时绑定多个Condition对象,而在synchronized中,锁对象的wait(),notify()或notifyAll()方法可以实现一个隐含的条件,如果要和多于一个的条件关联的时候,就不得不额外添加一个锁,而ReentrantLock则无需这样做,只需要多次调用newCondition()方法即可. 互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题.因此这种同步也成为阻塞同步(Blocking Synchronize).从处理问题的方式上说,互斥同步属于一种悲观的并发策略,总是认为只要不去加锁就肯定会出问题,无论共享数据是否真的会出现竞争,它都要进行加锁,用户态与核心态转换,维护锁计数器合集检查是否有阻塞的线程需要唤醒等操作. 非阻塞同步 非阻塞同步(Non-Blocking Synchronize) 是基于冲突检测的乐观并发策略,通俗地讲,就是先进行操作,如果没有其他线程征用共享数据,那操作就成功了,如果共享数据有征用,产生了冲突,那就再采取其他的补偿措施(最常见的补偿措施是不断重试,直至成功).这种乐观的策略不需要将线程挂起. 无同步方案 要保证线程安全,并不是一定就要进行同步.同步只是保证共享数据争用时的正确性手段,如果一个方法本来就不涉及共享数据,那么它自然就无须任何同步措施去保证正确性,因此会有一些代码天生就是线程安全的. 可重入代码 可重入代码(Reentrant Code) 这种代码也叫作纯代码(Pure Code) ,可以在代码执行的任何时刻中断它,转而去执行另外一段代码,而在控制权返回后,原来的程序不会出现任何错误.相对线程安全来说,可重入性是更基本的特性,它可以保证线程安全. 可重入代码有一些共同的特征,例如不依赖存储在堆上的数据和公用的系统资源,用到的状态都由参数传入,不调用非可重入的方法等. 我们可以通过一个简单的原则来判断代码是否具有可重入性:如果一个方法它的返回结果是可以预测的,只要输入了相同的数据,就都能返回相同的结果,那它就满足可重入性. 线程本地存储 线程本地存储(Thread Local Storage) 指的是,如果一段代码中所需要的数据必须与其他代码共享,那就看看这些共享数据的代码是否能保证在同一个线程中执行,如果能保证,我们就可以把共享数据的可见范围限制在同一个线程之内,这样,无须同步也能保证线程之间不出现数据争用的问题. ThreadLocal Java中的java.lang.ThreadLocal类就是来实现线程本地存储的. 锁优化 自旋锁与自适应自旋锁 互斥同步对性能最大的影响就是阻塞的实现,挂起线程和回复线程的操作都需要转入内核态中完成,这些操作给系统的并发性能带来了很大的压力.同时,共享数据的锁定状态只会持续很短的一段时间,为了这段时间去挂起和回复线程并不值得. 如果物理机器上有一个以上的处理器,能让两个或以上的线程同时并行执行,我们就可以让后面请求锁的线程稍等一下但不放弃处理器的执行时间(即以一些CPU资源为代价,换来的是省去了内核态与用户态的切换),看看持有锁的线程是否很快就会释放锁.为了让线程等待,我们只需让线程执行一个忙循环(自旋),这项技术就是自旋锁. 自旋等待本身虽然避免了线程切换的开销,但它是要占用处理器时间的,因此,如果锁被占用的时间很短,自旋等待的效果就会非常好,反之,如果锁被占用的时间很长,那么自旋的线程只会白白消耗处理器资源,而不会做任何有用的工作,反而会带来性能上的浪费. 因此,自旋等待的时间必须要有一定的限度,如果自旋超过了限定的次数仍然没有成功获得锁,就应当使用传统的阻塞式的方式去挂起线程了. 自适应的自旋锁意味着自旋的时间不再固定了,而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定. 如果在同一个锁对象上,自旋等待刚刚成功获得过锁,并且持有锁的线程正在运行中,那么虚拟机就会认为这次自旋也很有可能再次成功,进而它将允许自旋等待持续相对更长的时间. 锁清除 锁清除是指虚拟机即时编译在运行时,对一些代码上要求同步,但是被检测到不可能存在共享数据竞争的锁进行消除.锁清除的主要判断依据来源于逃逸分析的数据支持,如果判断在一段代码中,堆上的所有数据都不会逃逸出去从而被其他线程访问到,那就把他们当做线上数据对待,认为它们是线程私有的,同步加锁自然就无须进行. 锁粗化 如果一系列的连续操作都对同一个对线反复加锁和解锁,那即使没有线程竞争,频繁地进行互斥同步操作也会导致不必要的性能损耗. 例如: 1234567public String concatString(String s1, String s1, String s3)&#123; StringBuilder sb = new StringBuilder(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString():&#125; 如果JVM探测到这样的一连串对同一个对象(sb)加锁的操作,将会把加锁同步的范围扩展(粗化)到整个操作序列的外部. 轻量级锁 操作系统互斥量来实现的传统锁被称为重量级锁,而轻量级锁是相对于重量级锁来讲的. 轻量级锁并不是用来代替重量级锁的,它的本意是在没有多线程竞争的前提下,减少传统的重量级锁使用操作系统互斥量产生的性能消耗. 对象头中有2bit用来存储锁标志位, 偏向锁]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>深入理解JVM</tag>
        <tag>jvm</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2Falgorithm-sort%2F</url>
    <content type="text"><![CDATA[复习一下排序算法 概览 排序算法 时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n2) O(n) O(n2) O(1) in-place 稳定 选择排序 O(n2) O(n2) O(n2) O(1) in-place 不稳定 插入排序 O(n2) O(n) O(n2) O(1) in-place 稳定 希尔排序 O(nlogn) O(nlong2n) O(nlog2n) O(1) in-place 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) out-place 稳定 快速排序 O(nlogn) O(nlogn) O(n2) O(logn) in-place 不稳定 堆排序 O(n logn) O(n logn) O(n logn) O(1) in-place 不稳定 计数排序 O(n + k) O(n + k) O(n + k) O(k) out-place 稳定 桶排序 O(n + k) O(n + k) O(n2) O(n + k) out-place 稳定 基数排序 O(n * k) O(n * k) O(n * k) O(n + k) out-place 稳定 冒泡排序 冒泡排序对数组进行两层遍历,每一步比较相邻的两项,如果这两项排序错了则对其进行交换 代码 1234567891011121314// 冒泡排序public static void bubble(int[] arr) &#123; int temp; int len = arr.length; for (int i = len - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 评价 冒泡排序通常被认为是最低效的排序方法 但是冒泡排序如果在某次遍历中发现没有交换值,就可以提前结束 优化代码 1234567891011121314151617181920// 优化的冒泡排序public static void bubbleEnhance(int[] arr) &#123; int temp; int len = arr.length; boolean changed; for (int i = len - 1; i &gt;= 0; i--) &#123; changed = false; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; changed = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if(!changed)&#123; break; &#125; &#125;&#125; 选择排序 选择排序对数组进行两层遍历,每次遍历找到最小的项,遍历完成后再把最小的项放到正确的位置 代码实现 12345678910111213141516// 选择排序public static void selection(int[] arr)&#123; int temp,currentMinIndex; int len = arr.length; for(int i = 0; i &lt; len - 1; i++)&#123; currentMinIndex = i; for(int j = i + 1; j &lt; len; j++)&#123; if(arr[currentMinIndex] &gt; arr[j])&#123; currentMinIndex = j; &#125; &#125; temp = arr[currentMinIndex]; arr[currentMinIndex] = arr[i]; arr[i] = temp; &#125;&#125; 插入排序 插入排序总是保持一个位置靠前的以排好的子表,然后每一个新数据项被插入到前边的子表里 代码实现 123456789101112131415// 插入排序public static void insertion(int[] arr) &#123; int currentValue, position; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; currentValue = arr[i]; position = i; while (position &gt; 0 &amp;&amp; currentValue &lt; arr[position - 1]) &#123; arr[position] = arr[position - 1]; position -= 1; &#125; arr[position] = currentValue; &#125;&#125; 希尔排序 希尔排序又叫&quot;缩小间隔排序&quot;,它以插入排序为基础,将原来要排序的列表划分为一些字列表,再对每一个子列表执行插入排序 划分子列表的方法是希尔排序的关键.我们并不是将原始列表分成含有连续元素的子列,而是确定一个特别的分量&quot;i&quot;,这个i更准确地说是划分的间隔.然后把每间隔为i的所有元素选出来组成子列表,然后对每个子序列进行插入排序,最后当i=1时,对整体进行一次插入排序 代码实现 12345678910111213141516171819202122# 希尔排序def shellSort(alist): n = len(alist) gap = n // 2 while gap &gt; 0: for i in range(gap): gapInsetionSort(alist, i, gap) gap = gap // 2 return alist# # start子数列开始的起始位置， gap表示间隔def gapInsetionSort(alist,startpos,gap): #希尔排序的辅助函数 for i in range(startpos+gap,len(alist),gap): position=i currentvalue=alist[i] while position&gt;startpos and alist[position-gap]&gt;currentvalue: alist[position]=alist[position-gap] position=position-gap alist[position]=currentvalue 归并排序 归并排序是一种递归算法,它持续地将一个列表分成两半进行排序. 快速排序 通过一趟排序将要排序的数据分成独立的两部分,其中一部分的数据比另外一部分的所有数据都要小,然后按此方法对这两部分数据分别进行快速排序. 12345678910111213141516171819202122232425262728293031323334353637public void quickSort(int[] arr, int start, int end)&#123; if(end &lt;= start)&#123; return; &#125; int p = partition(arr, start, end); quickSort(arr,start,p - 1); quickSort(arr,p + 1,end);&#125;public int partition(int[] arr, int start, int end) &#123; System.out.println("============↓↓↓开始执行↓↓↓============="); System.out.println("本次执行数组: " + Arrays.toString(Arrays.copyOfRange(arr,start,end))); float pos = r.nextFloat(); int posInt = (int) (pos * (end - start) + start); int tmp = arr[posInt]; System.out.println("本次选定基准: arr[" + (posInt - start) + "] = " + tmp); arr[posInt] = arr[start]; arr[start] = tmp; int pivot = arr[start]; int j = start; int i = start + 1; while (i &lt; end) &#123; if (arr[i] &lt;= pivot) &#123; tmp = arr[j + 1]; arr[j + 1] = arr[i]; arr[i] = tmp; j += 1; &#125; i += 1; &#125; tmp = arr[j]; arr[j] = arr[start]; arr[start] = tmp; System.out.println("本次执行完事后数组: " + Arrays.toString(Arrays.copyOfRange(arr,start,end))); return j;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库中的各种锁]]></title>
    <url>%2Fdatabase-lock%2F</url>
    <content type="text"><![CDATA[概述 分类方法 锁 锁模式 乐观锁, 悲观锁 范围锁 行锁, 表锁 算法锁 临间锁, 间隙锁, 记录锁 属性锁 共享锁, 排他锁 状态锁 意向共享锁, 意向排他锁 行锁 一锁锁一行或多条记录,mysql的行锁是基于索引加载的,所以行锁是要加在索引响应的行上,即命中索引 锁冲突概率低,并发性高,但是会有死锁的情况出现 表锁 一锁锁一张表,表锁响应的是非索引字段,即全表扫描 记录锁 记录锁是在行锁上衍生出来的锁 记录锁锁的是表中的某一条记录,记录锁的出现条件是必须是精准命中索引并且索引是唯一索引,如主键id. 间隙锁 间隙锁又称为区间锁,每次锁定都是锁定一个区间,隶属行锁 既然间隙锁隶属行锁,那么间隙锁的触发条件必然是命中索引的 当我们使用范围查询而不是相等条件查询时,查询条件命中索引]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务隔离和Spring事务传播特性]]></title>
    <url>%2Ftransaction-isolation%2F</url>
    <content type="text"><![CDATA[事务隔离 事务的四大特性 原子性 一致性 隔离性 持久性 四种事务隔离级别 Read Uncommitted 读取未提交内容 会出现脏读 Read Committed 读取提交内容 Nonrepeatable Read 不可重复读 Read Committed满足了隔离的定义: 一个事务只能看到其他事务已提交的操作 因为两次读取数据库某条数据时,数据可能会不一致(两次读取之间,该数据被其他事务改动),所以也被称为Nonrepeatable Read (这个是mysql默认的事务隔离级别) Repeatable Read 可重读 确保同一事务获取到的数据是一致的 不过会导致另一个问题: 幻读 Serializable 可串行化 最高级别的事务隔离,通过强制事务排序使之不可能相互冲突,从而解决幻读问题.简而言之,它是在每个读的数据上加上共享锁.在这个级别可能导致大量的超时现象和锁竞争 总结 隔离级别 脏读 不可重复读 幻读 Read Uncommitted √ √ √ Read Committed x √ √ Repeatable Read x x √ Serializable x x x Spring事务传播特性 required Propagation.REQUIRED 方法被调用是自动开启事务,在事务范围内则使用同一事务,否则开启新事务 requires_new Propagation.REQUIRES_NEW 无论如何自身都会开启新事务 supports Propagation.SUPPORTS 自身不会开启事务,在事务范围内则使用相同事务，否则不使用事务. not_supported Propagation.NOT_SUPPORTED 自身不会开启事务,在事务范围内使用挂起事务,运行完毕恢复事务. mandatory Propagation.MANDATORY 自身不开启事务,必须在事务环境中否则报错. never Propagation.NEVER 自身不会开启事务,在事务范围内使用抛出异常. nested Propagation.NESTED 如果一个活动的事务存在,则运行在一个嵌套的事务中.如果没有活动事务,按照required执行. 名词解释 脏读 Dirty Read 读取其他事务未提交的执行结果 幻读 Phantom Read 幻读是指用户在读取某一行数据时,另一个事务又在该范围内插入了新行,当用户再次读取该范围数据行时,会出现新的&quot;幻影行&quot;]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法笔记]]></title>
    <url>%2Fnote-algorithm%2F</url>
    <content type="text"><![CDATA[数据结构 编程能力 算法 排序算法 搜索算法 图论 动态规划 基础技巧 分治 倍增 二分 贪心 t160:相交链表 滑动窗口]]></content>
  </entry>
  <entry>
    <title><![CDATA[一次反射的应用]]></title>
    <url>%2Fonce-reflect%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;public class JdbcGetAll &#123; // 传入表名和类名和Connection对象,会将给定表中的每条数据转换成给定的类的实例. // 要求,表的字段的字段名和数据类型要和类的字段名和类型一一对应 public List getAll(String tableName, String className, Connection conn) &#123; // 从给定的类名获得类传至该变量 Class thisClass; // 类的字段的数组 Field[] thisFields; // 类的字段的Map,方便根据字段名获取到Field对象 HashMap&lt;String, Field&gt; thisFieldsMap = new HashMap&lt;&gt;(); // 类的构造器 Constructor thisConstructor = null; // 表的字段名的集合 var COLUMN_NAMEs = new ArrayList&lt;String&gt;(); // 用于盛放生成的对象的数组,最终返回该对象 var thisInstances = new ArrayList(); try &#123; thisClass = Class.forName(className); thisConstructor = thisClass.getConstructor(); thisFields = thisClass.getFields(); for (var field : thisFields) &#123; thisFieldsMap.put(field.getName(), field); &#125; &#125; catch (ClassNotFoundException e) &#123; System.out.println("No class called '" + className + "'"); return null; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; // 获取到表的字段的sql语句 var sql = "select COLUMN_NAME from information_schema.COLUMNS where table_name = '" + tableName + "'"; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; pstmt = conn.prepareStatement(sql); rs = pstmt.executeQuery(); while (rs.next()) &#123; var COLUMN_NAME = rs.getString("COLUMN_NAME"); COLUMN_NAMEs.add(COLUMN_NAME); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; // 获取表的数据 sql = "select * from " + tableName; try &#123; pstmt = conn.prepareStatement(sql); rs = pstmt.executeQuery(); // 遍历所有记录,为每条记录生成一个类实例 while (rs.next()) &#123; try &#123; // 从类的构造器创建新的实例 var thisInstance = thisConstructor.newInstance(); // 遍历所有表的字段 for (var COLUMN_NAME : COLUMN_NAMEs) &#123; // 获取到表的字段名对应的对象字段 var field = thisFieldsMap.get(COLUMN_NAME); // 获取到该条记录该条字段的值 var o = rs.getObject(COLUMN_NAME); // 为对象的字段设置值 field.set(thisInstance, o); &#125; thisInstances.add(thisInstance); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUitl.close(pstmt, conn); &#125; return thisInstances; &#125; public static void main(String[] args) &#123; Connection conn = JdbcUitl.getConnection("address", 3306, "dbName", "root", "password"); var jdbcGetAll = new JdbcGetAll(); List res = jdbcGetAll.getAll("teacher", "Teacher", conn); System.out.println("结果集中共含有" + res.size() + "个元素: &#123;"); for (var re : res) &#123; System.out.println(" " + re); &#125; System.out.println("&#125;"); &#125;&#125; JdbcUtil类的代码 123456789101112131415161718192021222324252627282930import java.sql.*;public class JdbcUitl &#123; public static Connection getConnection(String address,int port,String dbName,String userName,String passWord)&#123; Connection conn = null; try &#123; conn = DriverManager.getConnection("jdbc:mysql://" + address + ":" + port + "/" + dbName,userName,passWord); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static void close(PreparedStatement pstmt,Connection conn)&#123; if(pstmt!=null)&#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解JVM》笔记-2-垃圾收集器与内存分配策略]]></title>
    <url>%2Fjvm-understanding-gc%2F</url>
    <content type="text"><![CDATA[对象已死吗 引用计数法 引用计数算法(Reference Counting) 给对象添加一个引用计数器,每当有一个地方引用它时,计数器值就加1;当引用失效时,计数器值减1;任何时刻计数器值为0的对象不可能再被使用. 引用计数法实现很简单,判定效率也很高.但是至少主流的Java虚拟机没有选用引用计数法管理内存的. 其主要原因是它很难解决对象之间相互引用的问题. 可达性分析算法 主流商用语言(如Java,C#)的主流实现中,都是通过可达性分析算法(Reachability Analysis) 来判定对象是否存活的. 这个算法的基本思路是通过一系列成为&quot;GC Root&quot;的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain) ,当一个对象到GC Roots没有任何引用链相连时,则证明此对象是不可用的. 如图,对象object5,object6,object7虽然相互有关联,但是它们到GC Roots是不可达的,所以它们将会被判定是可回收对象. 可作为GC Roots的对象 虚拟机栈(帧栈中的本地变量表)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(即一般说的Native方法)引用的对象 再谈引用 无论是引用计数还是可达性分析算法,判断对象是否存活都与&quot;引用&quot;有关. Java的引用分为4种,这四种引用强度依次逐渐减弱: 强引用(Strong Reference) 软引用(Soft Reference) 弱引用(Weak Reference) 虚引用(Phantom Reference) 强引用 强引用就是指在代码中普遍存在的,类似Object obj = new Object();这类的引用. 只要强引用还在,垃圾收集器永远不会回收掉被引用的对象. 软引用 软引用用来描述一些还有用但并非必需的对象. 对于软引用关联着的对象,在系统将要发生内存溢出异常之前,将会把这些对象列进回收范围之中进行二次回收.如果这次回收还没有足够的内存,才会抛出内存溢出异常. 软引用通过SoftReference类实现. 弱引用 弱引用也是用来描述非必需的对象的. 它的强度比软引用还要更弱一些. 只被弱引用关联的对象只能生存到下一次垃圾收集发生之前.当垃圾收集器工作时,无论当前内存是否足够,都会回收掉只被弱引用关联的对象. 弱引用通过WeakReference类实现. 虚引用 虚引用也称为幻影引用或者幽灵引用,它是最弱的一种引用关系. 一个对象是否被虚引用关联完全不会对它的生存构成影响,也无法通过一个虚引用来取得一个对象实例. 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知. 虚引用通过PhantomReference实现. 生存还是死亡 此部分作废,finalize()方法已过时 即使在可达性分析算法中不可达的对象,也并非是&quot;非死不可&quot;的. 要真正宣告一个对象的死亡要经历以下过程: 对上图的解释: 是否有必要执行finalize()方法: 当对象没有覆盖finalize()方法或finalize()方法已经被虚拟机调用过,虚拟机将会视为&quot;没有必要执行finalize()方法&quot;. 执行finalize(): finalize()方法由一个有虚拟机自动建立的,低优先级的Finalizer线程去执行. 这里所谓的&quot;执行&quot;,是指虚拟机会触发这个方法,但不承诺会等待它运行结束.这么做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环,这时如果等待它运行结束,将很可能会导致F-Queue中其他对象处于永久等待,甚至导致整个内存回收系统崩溃. 若在执行对象的finalize()方法中,将对象自身与引用链上任何一个对象建立关联,则可以在第二次标记中判断为可达,从而避开被回收. 执行过一次finalize()方法的对象在面临下一次垃圾回收时,虚拟机将不会再次执行finalize()方法,而是直接将其回收. 回收方法区 很多人认为方法区(或HotSpot中的永久代)没有垃圾收集,Java虚拟机规范中说过可以不要求方法区实现垃圾收集,而且在方法区中进行垃圾收集的性价比一般比较低:在堆中,尤其是在新生代中,常规应用进行一次垃圾收集一般可以回收70%~95%的空间,而永久代的垃圾收集效率远低于此. 永久代的垃圾回收主要回收两部分:废弃常量和无用的类 废弃常量 回收废弃常量与回收堆中的对象非常类似. 以常量池中字面量的回收为例,假如一个字符串&quot;abc&quot;已经进入了常量池了,但是当前系统中没有任何一个String对象叫做&quot;abc&quot;,如果这时进行垃圾回收,这个&quot;abc&quot;常量将会被系统清理出常量池. 常量池中的其他类(接口),方法,字段的符号引用也与此类似. 无用的类 同时满足以下3个条件,才能是无用的类: 该类的所有实例均已被回收,即Java堆中不存在该类的任何实例. 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法. 虚拟机可以对满足上述3个条件的无用类进行回收,但不是像对象一样必须进行回收.HotSpot虚拟机提供了参数进行控制. 垃圾收集算法 标记-清除算法 标记-清除算法(Mark-Sweep) 最基础的收集算法. 算法分为两个阶段.首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象.它的标记过程就是上面的对象标记判定. 之所以说它是最基础的收集算法,是因为后续的收集算法都基于这个思路并对其不足进行改进而得到的.它的不足有两个: 效率问题 标记和清除两个过程效率都不高 空间问题 标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时,无法找到足够的连续内存,而不得不再进行一次垃圾收集动作. 复制算法 复制算法是为了解决效率问题被提出来的. 复制算法将内存按容量划分为大小相等的两块,每次只使用其中的一块,当这一块内存用完了,就将还存活的对象复制到另一块上面,然后再把已使用过的内存空间一次清理掉.这样使得每次都是对整个半区进行内存回收,内存分配的时候也不比考虑内存碎片等复杂情况,只要移动堆顶指针,按顺序分配内存即可,实现简单运行高效. 这种算法的代价是将内存缩小为原来的一半,未免太高了一点. 现代的商用虚拟机都采用这种收集算法来回收新手代,IBM公司的专门研究表明,新生代中的对象98%是&quot;朝生夕死&quot;的,所以并不需要按照1:1的比例来划分内存空间,而是将内存分为一块较大的Eden空间和两块较小的Survior空间,每次使用一块Eden和其中一块Survior. 当回收时,将Eden和Survior中还存活着的对象一次性复制到另外一块Survior空间,最后清理掉Eden和刚刚用过的Survior空间. HotSpot虚拟机默认Eden和Survior的大小比例是8:1,每次新生代中可用的内存空间为整个空间的90%,只有10%的内存会被浪费. 当Survior空间不够用时,需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion) 复制算法在对象存活率较高时就要进行较多的复制操作,效率会变低,而且需要额外的空间进行分配担保,所以在老年代中一般不能直接采用复制算法. 标记-整理算法 标记-整理算法(Marking-Compact) 是根据老年代的特点提出来的. 标记过程仍与标记-清除算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉边界以外的内存. 分代收集算法 当前商业虚拟机的垃圾收集都采用分代收集算法(Generational Collocation) .这种算法并没有什么新的思想,只是根据对象存活周期将不同的内存划为几块. 一般是把Java堆分为新生代和老年代,这样就可以根据各个年代的特点采用最适当的收集算法. 在新生代中,每次垃圾收集都会有大批对象死去,只有少量存活,那就选用复制算法,只需要付出少量存活对象的复制成本就可以完成收集; 而老年代因为对象存活率高,没有额外的空间对它进行分配担保,就必须使用标记-清除或者标记-整理算法来进行回收. HotSpot的算法实现 上面从理论上介绍了对象存活判定算法和垃圾收集算法,而在HotSpot虚拟机上实现这些算法时,必须对算法的执行效率有严格考量,才能保证虚拟机高效运行. 枚举根节点 在可达性分析时,从GC Roots节点找引用链这个操作中,可视为GC Roots的节点主要在全局性引用(例如常量或类静态属性)与执行上下文(如栈帧中的本地变量表)中,现在很多应用仅仅方法区就有数百兆,如果要逐个检查这里么的引用,那必然会消耗很多时间. 另外,可达性分析对执行时间的敏感还体现在GC停顿上,因为这项分析工作必须在一个能确保一致性的快照中进行.这里&quot;一致性&quot;的意思是指在整个分析期间不能出现对象引用关系还在不断变化的情况.这一点不满足的话分析结果准确性就无法得到保证.这点是导致GC进行时必须停顿所有Java执行线程(Sun将这件事情称作&quot;Stop The World&quot;)的其中一个重要原因. 目前主流的Java虚拟机使用的都是准确式GC,所以当执行停下来后,并不需要一个不漏地检查完所有执行上下文和全局的引用位置.虚拟机应当是有方法直接得知哪些地方存放着对象引用. 在HotSpot的实现中,是使用一组称为OopMap的数据结构来达到这个目的的. 在类加载完成的时候,HotSpot就把对象内什么偏移量上是什么类型的数据计算出来,在JIT编译过程中,也会在特定的位置记录下栈和寄存器中哪些位置是引用.这样,GC在扫描时就可以直接得到这些信息了. 安全点 在OopMap的帮助下,HotSpot可以快速且准确地完成GC Roots的枚举,但有一个问题: 可能导致引用关系变化,或者说OopMap内容变化指令非常之多,如果为每一条指令都生成对应的OopMap,那将会需要大量的额外空间,这样GC的空间成本将会变得很高. 实际上,HotSpot着实没有为每条指令都生成OopMap,前面已经提到,只是在特定的位置记录了这些信息,这些位置被称为安全点(Safepoint) ,即程序执行时并非在所有地方都能停下来开始GC,只有在到达安全点时才能暂停. Safepoint的选定既不能太少以致于让GC等待时间太长,也不能过于频繁以致于过分增大运行时负荷. 所以,安全点的选定基本上是以程序&quot;是否具有让程序长时间执行的特征&quot;为标准进行选定的,因为每条指令执行的时间都非常短暂,程序不太可能因为指令流长度太长这个原因而过长时间运行,&quot;长时间执行&quot;的最明显的特征就是指令序列复用,例如方法调用,循环跳转,异常跳转等,所以具有这些功能的指令才会产生Safepoint. 对于Safepoint,另一个需要考虑的问题是如何在GC发生时让所有线程(这里不包括执行JNI调用的线程)都跑到最近的安全点上再停顿下来. 这里有两种方案可供选择:抢先式中断(Preemptive Suspension) 和主动式中断(Voluntary Suspension) 抢先式中断 抢先式中断不需要线程的执行代码主动去配合,在GC发生时,首先把所有线程全部中断,如果发现有线程的地方不在安全点上,就恢复线程,让它跑到安全点上. 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件. 主动式中断 主动式中断的思想是当GC需要中断线程的时候,不直接对线程操作,仅仅简单地设置一个标志,各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己中断挂起. 对标志进行轮询的时机和安全点出现的时机是重合的,在其基础上加上创建对象需要分配内存的时机. 安全区域 使用Safepoint似乎已经完美解决了如何进入GC的问题,但实际情况却并不一定. Safepoint机制保证了程序执行时,在不太长的时间内就会遇到可进入GC的Safepoint. 但是,程序&quot;不执行&quot;的时候呢?所谓的程序不执行就是没有分配CPU的时间,典型的例子就是线程处于Sleep状态或者Blocked状态,这时候线程无法响应JVM的中断请求,走到Safepoint中断挂起,JVM显然不太可能等待线程被分配CPU的时间.对于这种情况,就需要安全区域(Safe Region) 来解决. 安全区域是指在一段代码中,引用关系不会发生变化,在这个区域中的任意地方开始GC都是安全的. 在线程执行到Safe Region中的代码时,首先标识自己已经进入了Safe Region,那样,当在这段时间里JVM要发起GC时,就不用管标识为Safe Region状态的线程了.在线程要离开Safe Region时,它要检查系统是否已经完成了根节点枚举(或者是整个GC过程),如果完成了,那线程继续执行,否则线程就必须等待直到收到可以安全离开Safe Region的信号为止. 垃圾收集器 垃圾收集算法是内存回收的方法论,垃圾收集器是内存回收的具体实现. Java虚拟机规范中对垃圾收集器应该如何实现没有任何规定,因此不同的厂商,不同版本的虚拟机所提供的的垃圾收集器都可能有很大差别,并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器. 这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机(这个版本中正式提供了商用的G1收集器),这个虚拟机包含的所有收集器如下图: 上图展示了7种不同分代的收集器,两个收集器之间的连线代表它们可以搭配使用. 虚拟机所处的区域,则表示它是属于新生代还是老年代收集器. Serial收集器 Serial收集器是最基本,发展历史最悠久的收集器,曾经(JDK 1.3.1之前)是虚拟机新生代收集的唯一选择. 这个收集器是一个单线程收集器,但它的单线程的意义并不仅仅说明他只会使用一个CPU或一条收集线程去完成垃圾收集工作,更重要的是在它进行垃圾收集时,必须暂停其他所有的工作线程,直到它收集结束,这对很多应用来说是无法接受的. 对于&quot;Stop The World&quot;带给用户的不良体验,虚拟机的设计者们表示完全理解,但也表示非常委屈:&quot;你妈妈给你打扫房间的时候,肯定也会让你老老实实地在椅子上或者房间外面待着,如果她一边打扫,你一边丢纸屑,这房间还能打扫完?&quot;这确实是一个合理的矛盾. HOtSpot虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行.从Serial到Parallel再到CMS乃至G1,一个个收集器越来越优秀,用户线程的停顿时间在不断缩短,但是扔没办法完全消除. Serial收集器一直是虚拟机运行在Client模式下的默认新生代收集器,它相对于其他收集器的单线程的优点是:简单而高效. 对于限定单个CPU的环境来说,Serial收集器没有线程交互的开销,专心做垃圾收集自然可以获得更高的单线程收集效率. 在用户的桌面应用场景中,分配给虚拟机管理的内存一般来说不会很大,收集几十兆甚至一两百兆的新生代,停顿时间完全可以控制在几十毫秒最多一百毫秒内,只要不是频繁发生,这点停顿是完全可以接受的. 所以,Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择. ParNew收集器 ParNew收集器其实就是serial收集器的多线程版本,除了使用多条线程进行垃圾收集之外,其余行为包括Serial收集器可用的所有控制参数,收集算法,Stop The World,对象分配规则,回收策略等都与Serial收集器完全一样,在实现上,这两种收集器也共用了相当多的代码. ParNew收集器除了多线程之外,其他与Serial收集器相比并没有太多创新之处,但它却是很多运行在Server模式下的虚拟机中首选的新生代收集器,其中有一个与性能无关但是很重要的原因是,除了Serial收集器外,只有它能与CMS收集器配合工作. ParNew收集器在单CPU情况中绝对不会有比Serial收集器更好的效果.但随着CPU数量的增加,它对于GC是系统资源的有效利用还是很有好处的. Parallel Scavenge收集器 Parallel Scavenge收集器是一个新生代收集器,它也是使用复制算法的收集器,又是并行的多线程收集器. Parallel Scavenge收集器的特点是它的关注点与其他收集器不同,CMS等收集器的关注点是尽可能地缩短垃圾收集时用户停顿的时间,而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput). 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值,即 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) 停顿时间越短就越适合需要与用户交互的程序,良好的响应速度能提升用户体验. 而高吞吐量可以高效地利用CPU时间,尽快完成程序的运算任务,主要适合在后台运算而不需要太多交互的任务. 由于与吞吐量关系密切,Parallel Scavenge收集器也经常被称为&quot;吞吐量优先&quot;收集器 Serial Old收集器 Serial Old是Serial收集器的老年代版本.它同样是一个单线程收集器,使用标记-整理算法. 这个收集器的主要意义也是在于给Client模式下的虚拟机使用. 如果再Server模式下,那么它还有两大用途: 给JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用 作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure时使用 Parallel Old收集器 Parallel Old是Parallel Scavenge收集器的老年代版本,使用多线程和标记-整理算法. 由于老年代的Serial Old收集器在服务端拖累,使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化效果,由于单线程的老年代无法充分利用服务器多CPU的处理能力,在老年代很大而且硬件比较高级的环境中,这种组合还不一定有ParNew加CMS的组合给力. 直到Parallel Old处理器出现后,&quot;吞吐量优先&quot;收集器终于有了比较名副其实的应用组合,在注重吞吐量以及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器. CMS收集器 CMS(Concurrent Mark Sweep)收集器 是一种以获取最短回收停顿时间为目标的收集器. 目前很大一部分Java应用集中在互联网站或者B/S架构的系统服务器上,这类应用尤其重视服务器的响应速度,希望系统停顿时间最短,以给用户带来较好的体验.CMS收集器就非常符合这类应用的需求. 从名字(Mark Sweep)就能看出,CMS是基于标记-清除算法实现的,它的运作过程相对复杂一点,整个过程分为四个步骤: 初始标记(CMS initial mark) 初始标记和重新标记两个步骤仍需要Stop The World. 初始标记仅仅只是标记一下GC Roots能关联到的对象,速度很快 并发标记(CMS concurrent mark) 并发标记阶段就是进行GC Roots Tracing的过程 重新标记(CMS remark) 重新标记为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录.这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记停顿时间短 并发清除(CMS concurrent sweep) 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作,所以,从总体上说,CMS收集器的内存回收过程是与用户线程一起并发执行的. CMS是一款优秀的收集器,它的主要优点在名字上已经体现出来了:并发收集,低停顿,Sun公司的一些官方文档中也称之为并发低停顿收集器(Concurrent Low Pause Collector) 但是CMS还远达不到完美的程度,她又以下3个明显的缺点: 1-CMS收集器对CPU资源十分敏感 在并发阶段,它虽然不会导致用户线程停顿,但是会因为占用了一部分CPU资源而导致应用程序变慢,总吞吐量会降低. 2-CMS收集器无法处理浮动垃圾 CMS收集器无法处理浮动垃圾(Floating Garbage),可能会出现&quot;Concurrent Mode Failure&quot;失败而导致另一次Full GC的产生. 由于CMS并发清理阶段用户线程还在运行着,伴随程序运行自然会还有新的垃圾不断产生,这一部分垃圾出现在标记过程之后,CMS无法在当次收集中处理掉它们,只好留在下一次GC时再清理掉.这一部分垃圾就称为浮动垃圾. 也是由于在垃圾收集阶段用户线程还需要运行,那也就还需要预留有足够的内存空间给用户线程使用,因此CMS收集器不能像其他收集器那样等到老年代几乎被填满了再进行收集,需要预留一部分空间提供并发收集时的程序运作使用. 3-空间碎片过多 CMS是基于标记-清除算法实现的收集器,这意味着手机结束时会有大量空间碎片产生.空间碎片过多时,将会给大对象分配带来很大的麻烦,往往会出现老年代内存还有很大空间剩余,但无法找到足够大的连续空间来分配当前对象,不得不提前触发一次Full GC. G1收集器 内存分配与回收策略 Java体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题: 给对象分配内存和回收分配给对象的内存. 对象的内存分配,往大方向讲,就是在堆上分配,对象主要分配在新生代的Eden区上,如果启动了本地线程分配缓冲,将按线程优先在TLAB上分配.少数情况下也可能会直接分配在老年代中,分配的规则并不是百分之百固定的,其细节取决于当前使用的是哪一种垃圾收集器组合,还有虚拟机中与内存相关的参数配置的设置. 对象优先在Eden分配 大多数情况下,对象在新生代Eden中分配.当Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC. 大对象直接进入老年代 Java大对象需要大量连续的内存空间. 经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来放置它们. 虚拟机提供了一个-XX:PretenureSizeThreshold参数,令大于这个设置值的对象直接在老年代分配,这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制. 长期存活的对象进入老年代 虚拟机采取了分代收集的思想来管理内存,那么内存回收时就必须能识别哪些对象应放在新生代,哪些对象应放在老年代.为此,虚拟机给每个对象定义了一个年龄(Age)计数器. 如果对象在Eden出生并经过一次Minor GC后仍然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1. 对象在Survivor中每熬过一次Minor GC,对象的年龄就增加1. 当它的年龄增加到一定程度(默认15)就会被晋升到老年代中. 动态对象年龄的判定 为了能更好地适应不同程序的内存状况,虚拟机并不是永远地要求对象年龄达到PretenureSizeThreshold才能晋升老年代.如果再Survivor中相同年龄所有对象大小的总和大于Survior空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代. 空间分配担保 在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间,如果这个条件成立,那么Minor GC可以确保是安全的.如果不成立,则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败. 如果允许,那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小. 如果大于,则会尝试进行一个Minor GC,即时可能出现风险. 如果小于,或者HandlePromotionFailure不允许冒险,那这时要给为进行一次Full GC.]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>深入理解JVM</tag>
        <tag>jvm</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解JVM》笔记-1-Java内存区域]]></title>
    <url>%2Fjvm-understanding-memory%2F</url>
    <content type="text"><![CDATA[Java内存区域 程序计数器 程序计数器(Program Counter register) 是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器.字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令.分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器. 为了切换线程后恢复到正确的执行位置,每条线程都需要有一个独立的线程私有的程序计数器. 如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是一个Native方法,这个计数器值则为空. 异常情况 此内存区域是唯一一个没有任何OutOfMemoryError情况的区域 Java虚拟机栈 Java虚拟机栈(Java Virtual Machin Stacks) 也是线程私有的,它的生命周期与线程相同. 虚拟机栈描述的是Java方法执行的内存模型: 每个方法在执行的同时都会创建一个栈帧(Stack Frame). 栈帧用于存储局部变量表,操作数栈,动态链接,方法出口等信息. 局部变量表 局部变量表存放了编译器可知的各种基本数据类型(byte,boolean,short,int,long,double,float,char),对象引用,和returnAdress类型(指向了一条字节码指令的地址). 64位的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型均只占用一个. 局部变量表所需的内存空间在编译期间完成分配,在进入一个方法时,这个方法需要在栈中分配多大的局部空间是完全确定的. 异常情况 Java虚拟机栈有两种异常状况: 如果线程请求的栈深度大于虚拟机允许的深度,将抛出StackOverflowError异常; 如果虚拟机栈无法申请到足够的内存,将抛出OutOfMemoryError异常. 本地方法栈 本地方法栈为虚拟机使用到的Native方法服务,其余与Java虚拟机栈相似. Java堆 对大多数应用来说,Java堆 是占内存最大的一块. java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例 .这一点在java虚拟机规范中的描述是: 所有对象实例以及数组都要在堆上分配. Java堆是垃圾收集器管理的主要区域. 从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer) (简称TLAB ).TLAB如何划分都和存放内容无关,无论哪个区域,存储的都仍然是对象实例,进一步划分是为了更好地回收内存 ,或者更快地分配内存 . 异常情况 Java堆可以出在物理上不连续的空间中,只要逻辑上是连续的即可.在实现时,主流的虚拟机都是按照可扩展来实现的. 如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常. 方法区 方法区(Method Area) 是线程共享的内存区域,它用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据. 这一区域的内存回收目标主要是针对常量池的回收和对类型的卸载. 运行时常量池 运行时常量池(Runtime Constant Pool) 是方法区的一部分. Class文件中有一项信息是常量池(Constant Pool Table) ,用于存放编译器生成的各种字面量 和符号引用 ,这部分内容将在类加载后进入方法区的运行时常量池中存放. 运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性, Java语言并不要求常量一定只有编译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入仿佛运行时常量池,运行期间 也可能进将新的常量放入池中(这种特性被开发人员利用得比较多的是String类的intern()方法). 异常情况 当方法区无法满足内存分配的需求时,将抛出OutOfMemoryError异常. HotSpot虚拟机中的对象 对象的创建 1-类加载检查 当虚拟机遇到一条new指令时,首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已被加载,解析和初始化过.如果没有,那必须先执行响应的类加载过程. 2-分配内存 对象所需的内存的大小在类加载完成后便可以完全确定,为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来. 如果Java堆中内存是绝对规整的,则使用指针碰撞(Bump the Pointer) 如果Java堆中内存并不是规整的,就要使用空闲列表(Free List) 3-空间置零 内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头),如果使用TLAB,这一工作过程也可以提前至TLAB分配时进行. 这一操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用,程序能访问到这些字段的数据类型所对应的的零值. 4-对象头设置 接下来,虚拟机要对对象进行必要的设置,例如这个对象时哪个类的实例,如何才能找到类的元数据信息,对象的哈希码,对象的GC分代年龄等信息. 这些信息存放在对象的对象头(Object Header) 之中. 5-init 在上面的工作都完成之后,从虚拟机的视角来看,一个新的对象已经产生了,但从Java程序的角度来看,对象的创建才刚刚开始: init方法还没有执行,所有的字段都还为零.所以,执行new指令之后会接着执行init方法,把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才算完全产生出来. 对象的内存布局 对象在内存中的存储的分布可用分为3块区域: 对象头(Header),实例数据(Instance Data)和对齐填充(Padding) 对象头 对象头包括两部分信息: 1-Mark Word 存储对象自身的运行时数据,如哈希码,GC分代年龄,锁状态标志,线程持有的锁,偏向进程ID,偏向时间戳等. 2-类型指针 对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例. 另外,如果对象是一个Java数组,那在对象头中还必须有一块用于记录数组长度的数据. 实例数据 实例数据部分是对象真正存储的有效信息,也是在程序代码中所定义的各种类型的字段内容. 无论是从父类继承下来的,还是在子类中定义的字段内容,都需要记录起来. 这部分的存储顺序会收到虚拟机分配策略参数(FieldAllocationStyle)和字段在Java源码中定义顺序的影响. HotSpot虚拟机默认的分配策略为longs/doubles,ints,shorts/chars,bytes/booleans,OOP(Ordinary Object Pointers),从分配策略中可以看出,相同宽度的字段总是被分配到一起. 在满足这个前提条件的情况下,在父类中定义的变量会出现在子类之前. 如果CompactFields参数值为true(默认为true),那么子类中较窄的变量也可能会插入到父类变量的空隙之中. 对齐填充 对齐填充并不是必然存在的,也没有特别的含义,它仅仅起着占位符的作用. 这个占位符的存在是因为,HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍 对象的访问定位 Java程序需要通过栈上的reference数据来获取到堆上的具体对象. 对象访问方式取决于虚拟机实现.目前主流的访问方式有使用句柄和直接指针两种. 通过句柄访问对象 Java堆中将会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自的具体地址信息. 使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行文)时只会改变句柄中的实例数据指针,而reference本身不需要改变. 通过直接指针访问对象 Java堆对象的布局中必须考虑如何放置访问类型数据的相关类型,而reference中存储的直接就是对象地址. 使用直接指针访问方式的最大好处就是速度更快,它节省了一次指针定位的时间开销. HotSpot使用的是直接指针.]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>深入理解JVM</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于养生的思考]]></title>
    <url>%2Fthinking-health%2F</url>
    <content type="text"><![CDATA[一天睡6小时会比一天睡8小时拥有多2小时清醒的时间,可以说前者比后者多1/8的时间,一年下来,前者比后者多“活着”一个月. 熬夜对身体不好,会死得早.不过,看似死得早,实际上,比看上去死的晚的人少活的,可能只是风烛残年的一小段时间,熬夜的人将这部分生命透支了,换取的是年轻的生命. 这里引出了一个思考: 年轻的生命,和老来的生命,哪个更有价值?需要由此来判断透支是否划算. 我现在还很年轻,我觉得老年人的生命没有意思.以我现在对老年人的心境的理解是,做什么都没有激情,体会不到兴奋,现在的我认为这种生命舍弃也罢,换取年轻时能体验刺激,做事有激情的时间. 不过,这个评判来自现在的我.或许老了的我,虽无法体验到激情,不会兴奋,但能从浇花,散步中体会到有价值的东西呢? 对于这个问题,我现在的观点是:不管将来的我怎么想,我现在按我现在的评判行动即可.老了如果后悔的话,就拿&quot;年轻的我做出的方针是为了使年轻的我很开心&quot;来安慰自己.]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nuxt的理解]]></title>
    <url>%2Fnuxt-understanding%2F</url>
    <content type="text"><![CDATA[nuxt nuxt允许将一部分vue的生命周期运行在服务端,在服务端生成部分渲染好的页面之后返回给客户端 nuxt和vue的生命周期 nuxt文档没有说明白服务端渲染中vue生命周期中的哪些部分是运行在服务端,哪些运行在客户端的… 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;section class=&quot;container&quot;&gt; &#123;&#123;p&#125;&#125; &lt;br&gt; &#123;&#123;t&#125;&#125; &lt;/section&gt;&lt;/template&gt;&lt;script&gt; import axios from &apos;axios&apos; export default &#123; data () &#123; return &#123; p: &apos;p&apos;, t: &apos;t&apos; &#125; &#125;, asyncData (&#123; req, params &#125;) &#123; // We can return a Promise instead of calling the callback return axios.get(&apos;https://api.ggemo.com/test&apos;) .then((res) =&gt; &#123; return &#123; posts: res.data &#125; &#125;) &#125;, created () &#123; this.p = this.posts.data.text &#125;, mounted () &#123; console.log(&quot;p before changed: &quot;,this.p) this.p = &apos;p mounted&apos; console.log(&quot;p changed: &quot;,this.p) this.t = &apos;t mounted&apos; &#125; &#125;&lt;/script&gt; 这样渲染出来的html文件的body部分为 1234567891011121314151617181920212223242526&lt;body data-n-head=""&gt;&lt;div data-server-rendered="true" id="__nuxt"&gt;&lt;!----&gt; &lt;div id="__layout"&gt; &lt;div&gt; header &lt;section class="container"&gt; 成功 successed &lt;br&gt; t &lt;/section&gt; footer &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;window.__NUXT__ = &#123; layout: 'default', data: [&#123; posts: &#123; status: 0, data: &#123; text: '成功 successed' &#125; &#125; &#125;], error: null, serverRendered: true&#125;&lt;/script&gt;&lt;script src="/_nuxt/runtime.js" defer&gt;&lt;/script&gt;&lt;script src="/_nuxt/pages_index.js" defer&gt;&lt;/script&gt;&lt;script src="/_nuxt/pages_index.42262e91659a4eb99aae.hot-update.js" defer&gt;&lt;/script&gt;&lt;script src="/_nuxt/vendors.app.js" defer&gt;&lt;/script&gt;&lt;script src="/_nuxt/app.js" defer&gt;&lt;/script&gt;&lt;/body&gt; 在页面上的渲染效果为 其中https://api.ggemo.com/test中的内容为{ posts: { status: 0, data: { text: ‘成功 successed’ } } } created钩子中的 this.p的值,在传给客户端之前就已经被渲染进了html源码 而mounted中的 this.p的值和this.t的值的更改是在客户端被执行的 由此可见,vue的created钩子运行在了服务端,mounted钩子运行在了客户端 nuxt官网的图片: Render应该是执行vue生命周期中beforeMount之前的钩子]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-deploy]]></title>
    <url>%2Fdjango-deploy%2F</url>
    <content type="text"><![CDATA[最终的命令是这样的: 1uwsgi --http :8000 --chdir /root/ggemo_django/ggemo_django --home=/usr/local/python3 --wsgi-file /root/ggemo_djgo/ggemo_django/wsgi.py 期间有不少坑. 要在wsgi.py中将项目地址加入python运行环境 1sys.path.append(os.path.split(os.path.dirname(__file__))[0]) 之后,会提示sqlite版本不够,下载下来新版本后,python的sqlite3库识别不到新的sqlite.之后按照https://superuser.com/questions/1425212/where-does-django-look-for-sqlite-instance-sqlite-3-8-3-or-later-is-required?rq=1说的,将export LD_LIBRARY_PATH=&quot;/usr/local/lib&quot;原封不动写入环境变量,就好了.]]></content>
      <tags>
        <tag>ggemo日志</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务薅羊毛]]></title>
    <url>%2Fhaoyangmao-cloudService%2F</url>
    <content type="text"><![CDATA[免费 腾讯云 https://cloud.tencent.com/act/free 下面的更多产品与服务 重点总结 产品 免费额度 对象存储 企业用户每月1TB标准存储空间，个人用户每月50GB标准存储空间，6个月免费体验时长 CDN 每月10G免费流量，新用户更有连续6个月50GB免费流量 鉴黄 2000张/天 DDoS 防护 抵御2G DDos攻击 七牛云 https://www.qiniu.com/events/free 重点总结 产品 免费额度 对象存储 • 标准存储免费空间 10 GB• 每月免费上传流量 无上限• 10 万次 PUT/月，100 万次 GET/月 CDN 10 GB/月 内容安全 • 免费鉴黄额度 6 万张• 免费鉴暴恐额度 6 万张• 免费政治敏感人物识别额度 6 万张 阿里云 https://free.aliyun.com/ntms/free/personal.html 重点总结 产品 免费额度 短信服务 100条 华为云 https://activity.huaweicloud.com/free_product/index.html 百度智能云]]></content>
  </entry>
  <entry>
    <title><![CDATA[anime-want2watch]]></title>
    <url>%2Fanime-want2watch%2F</url>
    <content type="text"><![CDATA[寒蝉鸣泣之时 无头骑士异闻录 火影忍者 光之美少女]]></content>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第16章-Unity中的渲染优化]]></title>
    <url>%2Fshader-r-optimalize%2F</url>
    <content type="text"><![CDATA[影响性能的因素 CPU负责保证帧率,GPU负责分辨率先关的一些处理 CPU 过多的draw call 复杂的脚本或者物理模拟 GPU 顶点处理 过多的顶点 过多的逐顶点计算 片元处理 过多的片元(既可能是由于分辨率造成的,也可能是由于overdraw造成的) 过多的逐片元计算 宽带 使用了尺寸很大且未压缩的纹理 分辨率过高的帧缓存 对于CPU来说,限制它的主要原因是每一帧中draw call的数目. CPU每次通知GPU渲染之前,都要提前准备好顶点数据(如位置,法线,颜色,纹理坐标等),然后调用一系列API将它们放到GPU的指定位置,最后,调用一个指令,通知GPU开始渲染. 而调用绘制命令时,就会产生一个drawcall.过多的drawcall会造成CPU的性能瓶颈,这是因为每次调用drawcall是,CPU往往都需要 改变很多渲染状态的设置,而这些操作是非常耗时的.如果一帧中需要的drawcall过多的话,就会导致CPU把大部分时间都花费在提交drawcall上面. 当然,其他操作也可能造成CPU瓶颈,例如物理,布料模拟,蒙皮,粒子模拟等,这些都是计算量很大的操作. 而对于GPU来说,它负责整个渲染流水线.他从处理CPU传递过来的模型数据开始,进行顶点着色器,片元着色器等一系列工作,最后输出到屏幕上的每个像素.因此,GPU性能瓶颈和需要处理的定点数,屏幕分辨率,显存等因素有关. 而相关的优化策略可以从减少处理的数据规模(包括顶点数目和片源数目),减少运算复杂度等方面入手. 了解了上面的基本内容后,本章节后续会涉及的优化技术有: GPU优化 使用批处理技术减少drawcall数 GPU优化 减少需要处理的顶点数目 优化几何体 使用模型的LOD(Level of Detail)技术 使用遮挡剔除(Occlusion Culling)技术 减少需要处理的片元数目 控制绘制顺序 警惕透明物体 减少实时光照 减少计算复杂度 使用Shader的LOD技术 代码方面的优化 节省内存带宽 减少纹理大小 利用分辨率缩放 减少drawcall数目 批处理(batching)是经常看到的优化技术.批处理的实现原理就是为了减少每一帧出现的drawcall数目. 为了把一个对象渲染到屏幕上,CPU需要检查哪些光源影响了该物体,绑定shader并设置它的参数,再把渲染命令发送给GPU. 当场景包含大量对象时,这些操作就会非常耗时.一个极端的例子是,如果我们需要渲染1000个三角形,把它们按1000个单独的网格进行渲染所花费的时间要远大于渲染一个包含了1000个三角形的网格.在这两种情况下,GPU性能消耗其实并没有多大的区别,但CPU的drawcall数目会成为性能瓶颈. 因此,批处理的思想很简单,就是在每次调用drawcall时尽可能多的处理多个物体. 使用同一材质的物体可以一起批处理.这是因为,对于使用同一材质的物体,他们之间的不同仅仅在于顶点数据上的差距. 我们可以把这些顶点合并在一起发给GPU,就可以完成一次批处理. Unity中支持两种批处理:一种是动态批处理,一种是静态批处理. 对于动态批处理来说,优点是一切处理都是由Unity自动完成的,不需要我们做任何操作,而且物体是可以移动的,但缺点是,限制很多,可能一不小心就会破坏了这种机制,导致Unity无法动态批处理一些使用了相同材质的物体. 而对于静态批处理来说,它的优点是自由度很高,限制很少;但缺点是可能会占用更多的内存,而且经过静态批处理后的所有物体都不可以再移动了(即便在脚本中尝试改变物体的位置也是无效的). 动态批处理 如果场景中有一些模型共享了同一个材质并满足一些条件,Unity就会自动把它们进行批处理,从而只花费一个drawcall就可以渲染所有模型. 动态批处理的基本原理是,每一帧都可以进行批处理的模型网格进行合并,再把合并后的模型数据传递给GPU,然后使用同一材质对其渲染. 除了实现方便,动态批处理的另一好处是,经过批处理的物体仍然可以移动,这是由于在处理每帧时Unity都会重新合并一次网格. 虽然Unity动态批处理不需要我们进行额外的工作,但只有满足条件的模型和材质才可以被动态批处理.需要注意的是,随着Unity版本的变化,这些条件也有一些改变. 在本节中,我们给出一些主要的条件限制: 能够进行动态批处理的网格的顶点属性规模要小于900. 例如,如果shader中需要使用顶点位置,发信和纹理坐标这三个顶点属性,那么要想让模型能够被动态批处理,它的顶点数目不能超过300.需要注意的是,这个数字在未来有可能会发生变化,因此不需要依赖这个数据. 一般来说,所有对象都需要使用同一个缩放尺度 一个例外情况是,如果所有物体都是用了不同的非统一缩放,那么它们也是可以被动态批处理的.但在Unity5中,这种对模型缩放的限制已经不存在了. 使用光照纹理(lightmap)的物体需要小心处理. 这些物体需要额外的渲染参数,例如,在光照纹理上的索引,偏移量和缩放信息等.因此,为了让这些物体可以被动态批处理,我们需要保证它们指向光照纹理中的同一个位置(?) 多Pass的Shader会中断批处理. 在前向渲染中,我们有时需要使用额外的pass来为模型添加更多的光照效果,但这样一来模型就不会被动态批处理了. 动态批处理的限制比较多,例如很多时候,我们的模型数据往往会超过900的顶点属性限制.这种时候依赖动态批处理来减少drawcall显然已经不能满足我们的需求了. 静态批处理 相对于动态批处理来说,静态批处理适用于任何大小的几何模型. 它的原理是.只在运行开始阶段,把需要进行静态批处理的模型合并到一个新的网格中,这意味着模型不可以在运行时被移动.但由于他只需要进行一次合并操作,比动态批处理更加高效. 静态批处理的一个缺点在于,他往往需要更大的内存来存储合并后的几何结构. 这是因为,如果在静态批处理前一些物体共享了相同的网格,那么在内存中每一个物体都会对应一个该网格的复制品,即一个网格会变成多个网格再发给GPU.如果这类使用同一网格的对象很多,那么这就会成为一个性能瓶颈了. 例如,如果再一个使用了1000个相同树模型的森林中使用了静态批处理,那么就会使用1000倍的内存,这会导致严重的内存影响. 这种时候,解决方法要么忍受这种牺牲内存换取性能的做法,要么不使用静态批处理,而使用动态批处理技术(但要小心控制模型的顶点数和属性数目),或者自己编写批处理方法. 在内部实现上,Unity首先将这些静态物体变换到世界空间下,然后为他们构建一个更大的顶点和索引缓存. 对于使用了同一材质的物体,静态批处理只需要调用一个drawcall就可以绘制全部物体. 而对于使用了不同材质的物体,静态批处理同样可以提升渲染性能,尽管这些物体仍然需要调用多个drawcall,但静态批处理可以减少这些drawcall之间的状态切换,而这些切换往往是费时的操作. 共享材质 从之前的内容可以看出,无论是动态批处理还是静态批处理,都要求模型之间需要共享同一个材质.但不同的模型之间总会需要不同的渲染属性,例如,使用不同的纹理,颜色等.这时,我们需要一些策略 来尽可能地合并材质. 如果两个材质之间只有使用的纹理不用,我们可以把这些纹理合并到一张更大的文立中,这张更大的纹理被称为一个图集(atlas). 一旦使用了同一张纹理,我们就可以使用同一个材质,再使用不同的采样坐标对纹理采样及可. 但有时,除了纹理不同外,不同的物体在材质上还有一些微笑的参数变化,例如,颜色不同,某些浮点属性不同.但是,不管动态批处理还是静态批处理,它们的掐你都是要使用同一个材质. 是同一个,而不是使用了同一种shader的材质,也就是说它们指向的材质必须是同一个实体.这意味着,只要我们调整了参数,就会影响到所有使用这个材质的对象.那么想要微小的调整,一个常用的方法就是使用网格的顶点数据(最常见的就是顶点颜色数据)来存储这些参数. (这里还有一段较详细的,以后再看) 批处理的注意事项 尽可能选择静态批处理,但时刻小心对内存的消耗,并且记住经过静态批处理的物体不可以再被移动 如果无法进行静态批处理,而要使用动态批处理的话,那么请小心上面提到的各种限制. 例如,尽可能让这样的物体少并且尽可能让这些物体包含少量的顶点属性和顶点数目. 对于游戏中的小道具,例如捡拾的金币等,可以使用动态批处理 对于包含动画这类物体,我们无法全部使用静态批处理,但其中如果有不动的部分,可以把这部分标识为&quot;Static&quot; 除了上述的提示外,在使用批处理时还有一些需要注意的地方. 由于批处理需要把多个模型变换到世界空间下再合并它们,因此,如果shader中存在一些基于模型空间下的坐标的运算,那么往往会得到错误的结果.一个解决方法是在shader中使用DisableBatching标签强制使用该Shader的材质不被批处理. 另一个需要注意的是,使用半透明材质的物体 通常需要使用严格的从后往前的绘制顺序来保证透明混合的正确性.对于这些物体,Unity会首先保证它们的绘制顺序,再尝试对它们进行批处理.这意味着,当绘制顺序无法满足时,批处理无法在这些物体上被成功应用. 减少需要的顶点数目 优化几何体 Unity中显示的顶点数目往往要多余建模软件里显示的顶点数.通常Unity中显示的数目要大很多.我们真正应该关心的是Unity中显示的数目. 三维软件更多的是站在我们人类的角度理解顶点的,即组成几何体的每一个点就是一个单独的点. 而Unity是站在GPU的角度上去计算顶点的. 在GPU看来,有时需要把一个顶点拆分成两个或更多的顶点.这种将顶点一分为多的原因主要有两个:一是为了分离纹理坐标(uv splits),另一个是为了**产生平滑的边界88(smoothing splits).它们的本质,其实都是对于GPU来说,顶点的每一个属性和顶点之间必须是一对一的关系.而分类纹理坐标,是因为建模时的一个顶点的纹理坐标有多个. 例如,对于一个正方体,它的六个面之间虽然使用了一些相同的点,但在不同面上,同一个顶点的纹理坐标可能并不相同.对于GPU来说,这是不可理解的.因此,它必须把这个顶点拆分成多个具有不同纹理坐标的顶点. 而平滑边界也是类似,不同的是,此时一个顶点可能会对应多个法线信息和切线信息.和通常是因为我们要决定一个边时一条硬边(hard edge)还是一条平滑边(smooth edge) 对于GPU来说,它本质只关心有多少个顶点.因此,尽可能减少顶点数其实才是我们真正需要关心的事情.因此,最后一条几何体优化建议是:移除不必要的硬边以及纹理衔接,避免边界平滑和纹理分离. 模型的LOD算法 另一个减少顶点数的方法是使用LOD技术.这种技术是,当一个物体离摄像机很远时,模型上的很多细节是无法被察觉到的.因此,LOD允许当对象逐渐远离摄像机时,减少模型上的面片数量,从而提高性能. 在Unity中,我们可以使用LOD Group组件来为一个物体构建一个LOD.我们需要为同一个对象准备多个包含不同细节程度的模型,然后把他们赋给LOD Group组件中的不同等级,Unity就会自动判断当前位置上需要使用哪个等级的模型 遮挡剔除技术 遮挡剔除(Occlusion culling)可以用来消除那些在其他物体后面看不到的物件,这意味着资源不会浪费在那些看不到的顶点上.进而提升性能. 我们需要把遮挡剔除和摄像机的视锥体剔除(Frustum Culling)区分开来. 视锥体剔除只会剔除掉那些不在摄像机的视野范围内的对象,但不会判断视野中是否有物体被其他物体挡住.而遮挡剔除会使用一个虚拟的摄像机来遍历场景,从而构建一个潜在氪金的对象集合层级结构. 在运行时刻,每个摄像机将会使用这个数据来识别哪些物体是可见的,而哪些物体被其他物体挡住不可见.使用遮挡剔除技术,我们需要进行一系列额外的处理工作,具体步骤参见Unity手册相关内容(docs.unity3d/Manual/OcclusionCulling.heml) 模型的LOD技术和遮挡剔除技术可以同时减少CPU和GPU的负荷.CPU可以提交更少的drawcall,而GPU需要处理的顶点和片元数目也减少了. 减少需要处理的片元数目 另一个造成GPU瓶颈的是需要处理过多片元.这部分优化的重点在于减少overdraw.简单来说,overdraw指的就是 同一个像素被绘制多次. Unity中Scene视图左上方的下拉菜单中选中Overdraw即可查看overdraw. 实际上,这里的视图只是提供了查看物体相互遮挡的层数,并不是真正的最终屏幕绘制的overdraw.也就是说,可以理解为它显示的是,如果没有任何深度测试和其他优化策略时的overdraw. 这种视图通过吧所有游戏对象都渲染成一个透明的轮廓,透过查看透明颜色的累积程度来判断物体之间的遮挡. 控制绘制顺序 为了最大限度避免overdraw,一个重要的优化策略就是控制绘制顺序. 由于深度测试的存在,如果我们可以保证物体都是从前往后绘制的,那么就可以很大程度上减少overdraw.这是因为,在后面绘制的物体由于无法通过深度测试,因此就不会再进行后面的渲染处理. 在Unity中,那些渲染队列数目小于2500(如&quot;Background&quot;“Geometry&quot;和&quot;AlphaTest”)的对象都被认为是不透明(opaque)的物体,这些物体总体上是从前往后绘制的,而使用其他的队列(如&quot;ransparent&quot;&quot;Overlay&quot;等)的物体则是从后往前绘制的.这意味着,我们可以尽可能地把物体的队列设置为不透明的渲染队列,而尽量避免使用半透明队列. 好无聊了这块以后再来看 时刻警惕欧明物体 减少实时光照和阴影]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp笔记-装箱与拆箱]]></title>
    <url>%2Fcsnote-2%2F</url>
    <content type="text"><![CDATA[官方指南翻译 官方指南: Boxing and Unboxing (C# Programming Guide) 装箱是把一个值类型转换为object类型或转换为任何实现了该值类型接口的类型的过程.当CLR装箱一个值类型时,它将这个值封装进一个System.Object并且存在堆中.拆箱将这个值从这个object中取出来.装箱是隐式的,拆箱是显式的.装箱和拆箱的概念是C#类型系统统一视图的基础.C#类型系统中,一任何类型的值都可以被当做object. 在下面的例子里,int值i被装箱,并赋值给objecto 123int i = 123;// 下面一行装箱了i.object o = i; 然后objecto可以拆箱并赋值给变量i 12o = 123;i = (int)o; // 拆箱 下面的例子解释了装箱在C#中的应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// String.Concat 例子// 42和true必须被装箱Console.WriteLine(String.Concat("Answer", 42, true));// List 例子// 新建一个objects的list存放各种各样类型的元素List&lt;object&gt; mixedList = new List&lt;object&gt;();// 往这个list中天际一个stringmixedList.Add("First Group:");// 往这个list中添加一些intfor (int j = 1; j &lt; 5; j++)&#123; // 每个添加进这个list的j都会被装箱 mixedList.Add(j);&#125;// 添加另一个string和更多intmixedList.Add("Second Group:");for (int j = 5; j &lt; 10; j++)&#123; mixedList.Add(j);&#125;// 显示这个list中的所有元素. 用var声明循环中的所有变量, 然后编译器会分配它的类型foreach (var item in mixedList)&#123; Console.WriteLine(item);&#125;// 下面的循环将第一批的int的平方加起来// 这些list的元素是objects,在被拆箱之前不能乘和加// 这个拆箱必须是显式的var sum = 0;for (var j = 1; j &lt; 5; j++)&#123; // 下面的语句会引起一个编译错误: // Operator '*' cannot be applied to operands of type 'object' and 'object'. //sum += mixedList[j] * mixedList[j]); // 当列表元素拆箱后,计算不会引起编译错误 sum += (int)mixedList[j] * (int)mixedList[j];&#125;// 显示的结果是 30, 1 + 4 + 9 + 16.Console.WriteLine("Sum: " + sum);// Output:// Answer42True// First Group:// 1// 2// 3// 4// Second Group:// 5// 6// 7// 8// 9// Sum: 30 性能 因为涉及到一个简单的分配, 所以装箱和拆箱在计算上是昂贵的. 当一个值类型被装箱时, 一个新的object就会被指派和创建. 在较小的程度上, 拆箱需要的花费在计算上也是很昂贵. 更多信息请浏览性能 装箱 装箱用来将值类型存到垃圾回收(GC)堆中. 装箱隐式地将值类型转换为object类型或转换为任何实现了该值类型接口的类型. 将一个值类型装箱会在堆中指派一个object实例并将这个值拷贝进这个新的object. 考虑下下面这个值类型变量的声明: 1int i = 123; 下面的语句隐式地对变量i进行了拆箱: 12// 拆箱将i的值拷贝进object oobject o = i; 上面语句的结果是,在栈上创建一个对象o的引用, 引用了在堆上的int类型的值. 这个值是一个分配到变量i上的值类型的拷贝. i和o这两个变量的区别可以用下面这张装箱变换的图来形象的解释: 装箱也可以像下面这样显式的执行, 不过显式的装箱永远不会用到: 12int i = 123;object o = (object)i; // 显式的装箱 描述 这个例子用装箱将一个int变量i转换成一个objecto. 然后,如果存放在变量i中的值从123变为456… 下面的例子表明了,圆本 的值类型和装箱后的object使用不同的内存地址, 所以可以存储不同的值. 例子 123456789101112131415161718192021class TestBoxing&#123; static void Main() &#123; int i = 123; // 装箱将i的值拷贝进object o object o = i; // 改变i的值 i = 456; // i的改变不会影响到o中值的变化 System.Console.WriteLine("The value-type value = &#123;0&#125;", i); System.Console.WriteLine("The object-type value = &#123;0&#125;", o); &#125;&#125;/* 输出: The value-type value = 456 The object-type value = 123*/ 拆箱 拆箱显式地将object类型或任何实现了该值类型接口的类型转换为一个值类型. 一个拆箱操作由下面两部分组成: 确定这个object实例是一个给定值类型的装箱. 将这个实例中的值拷贝给一个值类型变量. 下面的语句展示了装箱和拆箱操作: 123int i = 123; // 一个值类型object o = i; // 装箱int j = (int)o; // 拆箱 下面的图是上面语句的演示: 为了确保拆箱在运行时能成功, 被拆箱的东西必须是一个之前被装箱创建的object的引用. 尝试去拆箱null会引发一个NullReferenceException.尝试拆箱一个不相容的类型会引发一个InvalidCastException 例子 下面的例子示范了一个不正确的引发了InvalidCastException的拆箱的例子: 12345678910111213141516171819class TestUnboxing&#123; static void Main() &#123; int i = 123; object o = i; // 隐式装箱 try &#123; int j = (short)o; // 尝试拆箱 System.Console.WriteLine("Unboxing OK."); &#125; catch (System.InvalidCastException e) &#123; System.Console.WriteLine("&#123;0&#125; Error: Incorrect unboxing.", e.Message); &#125; &#125;&#125; 上面的程序会输出: Specified cast is not valid. Error: Incorrect unboxing. 如果你将int j = (short) o;改为int j = (int) o;, 这个转换就会成功, 会输出Unboxing OK.]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>csharp</tag>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp笔记-值类型与引用类型]]></title>
    <url>%2Fcsnote-1%2F</url>
    <content type="text"><![CDATA[之前玩python的时候就有点在意但是没仔细学…只知道python是简单值传值,复杂值传引用. C#中的值类型和引用类型 C#中的所有Object的派生类都是引用类型 byte，short，int，long，float，double，decimal，char，bool和struct统称为值类型 这里注意,结构体为值类型而类都是引用类型. 值类型和引用类型的区别 以下部分参考了知乎这篇文章并加上自己的理解 值类型的数据存储在内存的栈中,引用类型的数据存储在内存的堆中.而内存单元中只存放堆中对象的地址,因此值类型存取速度快,引用类型存取速度慢 值类型表示实际数据,引用类型表示指向存储在内存堆中的数据的指针或引用 值类型继承自System.ValueType,引用类型继承自System.Object 栈的内存分配是自动释放；而堆在.NET中会有GC来释放 值类型没法继承,没法用接口来引用(虽然泛型+接口解决部分问题) 以下参考知乎:C# 引用类型相比于值类型意义何在? - Nanry的回答 - 知乎 百度百科引用类型的解释: 引用类型 由类型的实际值引用（类似于指针）表示的数据类型。如果为某个变量分配一个引用类型，则该变量将引用（或“指向”）原始值。不创建任何副本。引用类型包括类、接口、委托和装箱值类型。 值类型并不是在程序启动时就全部分配在栈上的,而是一直在入栈出栈操作,所以正常情况下由于入栈出栈的操作,不会超过栈空间的限制,超过了就是引起非常内存访问了(如果是static是不是一开始就全部分配在栈上呢?) C#的值类型就是存在栈中的.值类型是轻量级的类型,因为在大多数情况下,值类型的的实例都分配在线程栈中,因此它不受垃圾回收的控制,缓解了托管堆中的压力,减少了应用程序的垃圾回收的次数,提高性能.(栈中存的数据可以自动清理,堆中的数据要依靠GC) 顺便,有一种编程技巧极其容易因为栈空间不足而导致非常内存访问的情况,那就是递归.如果你在一个递归方法中使用了值类型,并且递归次数过多,经常会发生栈溢出的异常。 下面是两个,上面的那个答主提到的扩展阅读,以后再看 一看就懂：图解C#中的值类型、引用类型、栈、堆、ref、out 栈大小和内存分部问题 顺便引出的以后再看的问题: 栈和堆 尾递归优化]]></content>
      <categories>
        <category>csharp</category>
      </categories>
      <tags>
        <tag>csharp</tag>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMVCC设计模式的理解]]></title>
    <url>%2Fnote-AMVCC%2F</url>
    <content type="text"><![CDATA[对比以前前端MVVM设计模式做出理解 MVVM MVVM在view层负责根据数据展示视图,如v-if,v-for标签的作用. view层会响应事件,调用model层方法,如@click标签等. model层则负责所有数据的操作. MVC Unity中的MVC的view层根据数据展示视图 view层会响应事件,之后通知Controller层,对事件进行响应. MVC像是把MVVM的model拆成model和controller两层. controller层会使用和更改数据,但不会存储数据.存储数据交给model层. 个人理解,这样做的好处是条理更清晰,比如所有取数据,都在APP.Model.someData,并且在Unity中调整变量值的地方更加集中,容易管理.Unity传统的EC模型相对于MVC,在脚本之间互相调用和互相传参十分麻烦. Controller的switch-case 这里的&quot;避免庞大的switch-case&quot;仅为代码书写上,不会显得太多switch-case,实际执行的逻辑上还是该多少还是多少.]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载翻译 Unity with MVC-How to Level Up Your Game Development]]></title>
    <url>%2Funity-with-mvc-how-to-level-up-your-game-development%2F</url>
    <content type="text"><![CDATA[Unity with MVC: How to Level Up Your Game Development的翻译 没有找到好的国内的unity mvc的资料,国外的找到了这个. 自己翻译下,功力尚浅望轻喷.(页面最下面有评论板块) 原文地址: https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development (以括号开头和结尾的代码块为译者的注释和吐槽,比如这行和下面一行) (这个标题说是MVC,实际上讲的是MVC的一个变种: AMVCC模式) 程序猿经常从经典的Hello World着手开始学习.从那开始,项目越做越大.每个新挑战都指向一个重要的课题: 项目越大,就越乱. 不久后,就可以看到大小团队不会随意的不顾一切的做项目.代码应该被维护且能长时间持续使用.你工作过的公司不会只要你联系方式而是每次需要修或改善代码的时候叫你(然而你不希望这样). 这就是软件设计模式存在的理由;他们利用简单的规则来操控一个软件工程的整体架构.他们使一个或多个程序猿把一个大项目的部分分开成一些核心部分来写,并且用一个标准化的方法来组织,使得遇到不熟悉的代码的部分时能消除混乱. 如果所有人都遵守这些规则,就会使传统代码能更好的维护和操纵,并且新的代码可以更灵活地添加进去.规划开发的方法论花费的时间更少.因为问题是多种多样的,所以设计模式不存在最强杀招.必须仔细考虑每个模式的优点和缺点,然后找到最适合拿来解决手头的问题的. 在这份教程中,我会结合我在Unity游戏开发平台和Model-View-Controller(MVC)模式上的经验.在我七年的开发,在与我乱成一锅粥的游戏开发的正面对决中,我利用设计模式得到了很好的代码结构和开发速度. 我一开始会讲一些uninty的基础架构:Entity-Component模式.然后我会解释MVC如何适应它,并且用一些模拟的项目来解释它. 动机 在软件相关的文献中,我们可以找到一大堆关于设计模式的.纵然他们有一系列规则,开发者仍然经常需要做一些小的改动来使设计模式更能适应他们独特的问题. 这种&quot;程序编制的自由性&quot;证明了我们找不到一个单一的,确定的方法来设计软件.所以,这篇文章不应是解决你问题的终极方案,而是展示两种流行的设计模式:Entity-Component和Model-View-Controlle的效益和发展潜力. Entity-Component模式 Entity-Component(EC)是一种设计模式,我们首先定义组成应用的元素们的层级(Entities),然后定义将要被包含的特征和数据(Components).在更多的&quot;程序猿&quot;看来,一个Entity可以是一个包含了有0个或多个Components的对象.让我们这样描述一个Entity: some-entity [component0, component1, …] 这里是一个简单的EC树的例子: 1234567891011- app [Application] - game [Game] - player [KeyboardInput, Renderer] - enemies - spider [SpiderAI, Renderer] - ogre [OgreAI, Renderer] ui [UI] - hud [HUD, MouseInput, Renderer] - pause-menu [PauseMenu, MouseInput, Renderer] - victory-modal [VictoryModal, MouseInput, Renderer] - defeat-modal [DefeatModal, MouseInput, Renderer] EC在缓解多重继承的问题方面是一个好的模式,当一个复杂的类结构引出问题时,例如钻石问题: 一个类D,继承自两个类,B和C,而B和C继承自同一个类A,这时就会引发冲突,因为B和C会不同地修改A的属性. 因为在游戏开发中继承应用很广泛,所以这种问题会很常见. 通过分解小的Component的属性和数据操作器,可以使他们可以附加在不同的Entitiy上并重用,而不用依赖于复杂的继承关系(顺便,这不只是C#或JavaScript,Unity常用的语言的特征). Entity-Component模式的不足 EC在OOP之上的一个层面,EC有利于整理和更好的组织你的代码架构.然而,在大项目中,我们仍然&quot;太过随意&quot;然后我们会发现自己身处一个&quot;属性海洋&quot;,可能会费一段艰苦的时光来找到对的Entity和Component,或搞清楚它们应该如何相互影响.一个给定的任务中会有无穷种Entity和Component的组合方式. 一个摆脱混乱的途径是在Entity-Component之上添加一些的额外的参考.比如,我喜欢的一种考虑软件的方式是将其差分成三种不同的类别: 一些处理原数据,允许创建,读取,更新,删除和查找(也就是CRUD) 另一些实现一些接口来和其他元素相互作用,检测他们范围内相关的事件并且当发生时触发通知 最后,一些元素负责接收这些通知,制定事务逻辑决策,并决定如何操作数据 幸运的是,我们已经有表现得符合这些需求的设计模式了. Model-View-Controller(MVC)模式 Model-View-Controller pattern(MVC)模式将软件分成三个主要模块:Models (数据CRUD), Views (界面/事件检测)和Controllers (决策/处理).MVC实现起来足够灵活,即使是建立在ECS或OOP之上. 游戏和UI的开发有通常的工作流程: 等待用户输入,或其他的触发条件,向合适的地方发送这些通知,决定如何响应,并做出相应的数据操作.这些行为清楚地表现了MVC应用的兼容性. 这种方法论引入了其他的抽象层,会对软件规划有帮助,并且让新来的程序猿能掌控一个就算很大的代码库.通过将思考过程分离成数据,接口和决策,可以减少开发者必须通过查找来添加或修改功能的源文件. Unity和EC 让我们仔细看看unity预先给我们了什么. Unity是一个建立在EC上的开发平台,所有的Entity都是GameObject的实例,它们的属性可以使他们&quot;可见&quot;,“可移动”,“可交互”,等等,都是由继承Component的类提供的. Unity editor的Hierarchy面板和Inspector面板提供了装配你的应用的强大的方法,用比通常情况下更少的代码来附加组件,配置它们的初始化状态和引导你的游戏. 尽管如此,我们讨论过的,我们会遇到&quot;太多属性&quot;的问题并且发现我们身处一个庞大的层级中,属性分散在各个地方,使开发者更加难以存活. 按MVC的方式思考,我们可以按事物的功能将它们分类,使我们的应用的结构像下面这个例子这样: 将MVC打造进游戏开发环境 现在我要介绍两种简单的 一般的MVC模式的变种,可以将其打造进我曾用MVC建立Unity项目时遇到的特殊的情况: MVC的类容易散布在代码里 在Unity中,开发者通常必须拖拽对象来获取它们,或者使用类似GetComponent( … )的笨重的查找语句来获取对象 如果Unity崩溃了或者一些bug使所有的拖拽来的引用丢失了,会使该死的引用丢失接连发生. 必须使用一个独特的根引用对象,通过它来使Application中的所有对象可获取和重新获得. 一些元素封装了一些 一般的,需要高度重用的,不能自然地分类到Model,View或Controller中的功能.我简单地叫它们组件.它们也是Entity-Component中的&quot;Components&quot;的概念.但是在MVC框架中仅仅作为辅助者. 例如,一个Rotator组件,只会按照角速度旋转物体,但不会通知,存储,或决定任何事. 为了帮助缓解两种问题,我提出了一种魔改的设计模式,我叫它AMVCC,或Application-Model-View-Controller-Component. Application 你的应用的单独的入口,是所有决定性的实例和依赖应用的数据的容器 MVC 到目前为止你应该知道的. 😃 Component 可复用的,小的,容易被包含的脚本 例子: 10 Bounces 作为一个简单的例子,让我们来看下一个简单的叫10 Bounces的游戏,在此我会使用AMVCC模式的核心要素 这个游戏的结构很简单: 一个带有一个SphereCollider和一个Rigidbody的Ball(将会在&quot;Play&quot;之后开始下落),一个当做地面的Cube和5个搭建AMVCC的脚本. Hierarchy 在写代码之前,我通常会从hierarchy开始并创建我的类和物件的大纲.通常遵守这个新的AMVCC风格. 我们可以看到,view GameObject包含了所有的可见的元素,和其他的包含了View 脚本的物件(???). model和controller组件在一些小项目中通常只包含他们各自的脚本.在大项目中,他们会包含 包含了各自的脚本的GameObjects. 当其他人拿到你的项目希望看到: 数据: 查看application &gt; model &gt; … 逻辑/工作流程: 查看application &gt; controller &gt; … 渲染/接口/监听器: 查看application &gt; view &gt; … 如果所有的团队都遵从这些简单的规则,传统项目将不再成为问题(我谔谔) 需要注意的是,Component没有固定的容器,它们非常灵活,可以在开发者空闲的时候附加到不同的元素上. 写脚本 注意:下面的脚本都是真实世界的实现的抽象版本.一个详细的实现对渲染不太好.然而,如果你想浏览更多,点击这里查看我的个人的Unity MVC框架,Unity MVC.你可以找到大多数应用需要的实现AMVCC结构框架需要的核心class. 让我们来看一下构成10 Bounces的脚本的结构. 在开始之前,因为和常见的Unity的工作流程不同,让我们先简略地阐明脚本和GameObjects是如何共同工作的.在Unity中,“组件”,在Entity-Component的概念中,由MonoBehaviour类表现.一个组件要在运行时存在,开发者需要将其拖拽入一个GameObject(在Entity-Component模式中的&quot;Entity&quot;)或者用AddComponent()命令.在此之后,脚本就会被实例化并且准备好在执行时使用. 首先,我们定义Application类(AMVCC中的&quot;A&quot;),作为主要的类,包含所有实例化的游戏元素的引用.我们也可以创建一个辅助的基类叫Element,让我们能拿到Application实例和他的子元素的MVC实例.(子元素的MVC实例是什么鬼啊晕了晕了) 考虑到这一点,让我们开始定义Application类(AMVCC中的&quot;A&quot;),将要包含一个独特的实例.在它里面,三个变量model,view,和controller,将在运行时给我么提供所有的MVC实例的接入点.这些变量需要是包含 想要的脚本的public引用的MonoBehaviour. 之后,我们也要创建一个辅助基类叫做Element,来给我们提供Application的实例. 注意这两个类都要继承MonoBehaviour,他们是将要被附加到GameObject “Entities&quot;上的&quot;组件”. 1234567891011121314151617181920// BounceApplication.cs// 所有元素的基础类都在这个应用中public class BounceElement : MonoBehaviour&#123; // 应用和所有实例的入口. public BounceApplication app &#123; get &#123; return GameObject.FindObjectOfType&lt;BounceApplication&gt;(); &#125;&#125;&#125;// 10 Bounces 入口.public class BounceApplication : MonoBehaviour&#123; // MVC根实例的引用. public BounceModel model; public BounceView view; public BounceController controller; // Init things here void Start() &#123; &#125;&#125; 我们可以在BounceElement中创建MVC的核心类,BounceModel,BounceView和BounceController通常会是更多专门的实例的容器,不过我们这个例子比较简单,所以只有View有嵌套结构.Model和Controller可以各自用一个脚本来完成: 123456789// BounceModel.cs// 包含这个应用的所有相关数据.public class BounceModel : BounceElement&#123; // 数据 public int bounces; public int winCondition;&#125; 12345678// BounceView .cs// 包含这个应用的所有相关视图.public class BounceView : BounceElement&#123; // ball的引用 public BallView ball;&#125; 123456789// BallView.cs// 记录Ball的视图和属性.public class BallView : BounceElement&#123; // 只有这个是必须的.物理部分在工作的其他部分实现. // 碰撞体的回调函数. void OnCollisionEnter() &#123; app.controller.OnBallGroundHit(); &#125;&#125; 123456789101112131415161718192021// BounceController.cs// 控制应用工作流程.public class BounceController : BounceElement&#123; // 处理Ball的碰撞事件 public void OnBallGroundHit() &#123; app.model.bounces++; Debug.Log("Bounce "+app.model.bounces); if(app.model.bounces &gt;= app.model.winCondition) &#123; app.view.ball.enabled = false; app.view.ball.GetComponent&lt;Rigidbody&gt;().isKinematic=true; // 使ball停下 OnGameComplete(); &#125; &#125; // 处理胜利的情况 public void OnGameComplete() &#123; Debug.Log("Victory!!"); &#125;&#125; 创建好了所有的脚本之后,我们继续配置和附加它们. 层级布局会类似这样: 1234567- application [BounceApplication] - model [BounceModel] - controller [BounceController] - view [BounceView] - ... - ball [BallView] - ... 拿BounceModel做例子,我们看下它在Unity里是什么样子的: 所有的脚本都设定好并且运行之后,我们会在Console Panel中看到这样的输出: (别忘记给ball添加Rigidbody和给ball和ground添加碰撞体) 通知 就像上面这个例子,一个球碰到地板的时候会执行app.controller.OnBallGroundHit()函数.无论如何,在应用中的所有通知都用这种方法并不是&quot;错误&quot;的,但是,以我的经验,在AMVCC的Application类中用一个简单的通知系统能得到更好的结果. 让我们修改BounceApplication结构来实现: 123456789101112131415161718// BounceApplication.csclass BounceApplication &#123; // 遍历所有Controller并作为通知数据的代表 // 这个方法很容易找到,因为每个类都是"BounceElement",都有一个"app"实例 public void Notify(string p_event_path, Object p_target, params object[] p_data) &#123; BounceController[] controller_list = GetAllControllers(); foreach(BounceController c in controller_list) &#123; c.OnNotification(p_event_path,p_target,p_data); &#125; &#125; // Fetches all scene Controllers. public BounceController[] GetAllControllers() &#123; /* ... */ &#125;&#125; 然后,我们需要一个新的脚本让所有开发者添加通知的事件名,这些事件会在运行时进行调度. 123456789101112// BounceNotifications.cs// 这个类将所有的事件名定义为static.class BounceNotification&#123; public const string BallHitGround = "ball.hit.ground"; public const string GameComplete = "game.complete"; /* ... */ public const string GameStart = "game.start"; public const string SceneLoad = "scene.load"; /* ... */&#125; (上面代码块中的&quot;const&quot;原文中皆为static,按原文写编译出错) 显而易见,通过这种方式,程序的可读性增加了,因为开发者不需要在所有的源码中找controller.OnSomethingComplexName方法来理解运行时会产生什么样的行为.只需查看一个文件,就可以理解这个应用的所有行为. 现在,我们只需要改变BallView和BounceController来适应这种新系统: 123456789// BallView.cs// 记录Ball的视图和属性.public class BallView : BounceElement&#123; // 只有这个是必须的.物理部分在工作的其他部分实现. // 碰撞体的回调函数. void OnCollisionEnter() &#123; app.Notify(BounceNotification.BallHitGround,this); &#125;&#125; 12345678910111213141516171819202122232425262728// BounceController.cs// 控制应用工作流程.public class BounceController : BounceElement&#123; // 处理Ball的碰撞事件 public void OnNotification(string p_event_path,Object p_target,params object[] p_data) &#123; switch(p_event_path) &#123; case BounceNotification.BallHitGround: app.model.bounces++; Debug.Log("Bounce " + app.model.bounces); if(app.model.bounces &gt;= app.model.winCondition) &#123; app.view.ball.enabled = false; app.view.ball.GetComponent&lt;RigidBody&gt;().isKinematic=true; // 使ball停下 // 通知自身,说不定有其他其他controller响应 app.Notify(BounceNotification.GameComplete,this); &#125; break; case BounceNotification.GameComplete: Debug.Log("Victory!!"); break; &#125; &#125;&#125; 大项目将会由很多通知.所以为了避免一个庞大的switch-case结构,可以创建不同的controller来处理不同范围的消息. 实际项目中的AMVCC 上面的例子展示了一个AMVCC模式的应用场合.为了使你的思维方式能符合MVC的三个元素,而且按一个有序的层级展示entity应该明确这种技能. 在大项目中,开发者需要面对更多的复杂的场景,并且不好的决定一些事物是该放到View层还是Controller层,或者遇到一个给定的class需要更加彻底地分散到更小的模块. 翻阅的规则 (by Eduardo) 并不存在什么&quot;普遍的MVC整理规则&quot;.但是有一些简单的规则,我遵守它们来帮我决定一些事物是Model,View,Controller,还是需要分解成更小的模块. Class的分类 Model 包含一个应用的核心数据或状态,比如player的health,或是枪的ammo(弹药) 序列化的,并行的,和/或这两种的变种 加载/保存数据(本地或者网络) 在运行中通知Controller 为游戏的有限状态机保存游戏状态 不会接触到Views View 从Model层中获取数据来为用户展示实时的游戏状态.比如,一个View层的方法player.Run()会在内部调用model.speed显示player的行为 不会改动Model层 严格的实现自身类的功能.比如: 一个PlayerView不应该实现输入检测或更改游戏状态 一个View应该表现得像是有通知重要事件的接口的黑盒子 不存储核心数据(比如速度,血量,…) Controller 不存储核心数据 会过滤掉 不希望有的View 发来的通知 更新和使用Model的数据 管理Unity的场景的工作流 Class的层级 既然这样,我不需要遵守太多的步骤.通常,当我需要给变量名加太多的&quot;前缀&quot;时,我就会意识到需要把类分解,或同个元素有太多的变种(如MMO游戏中的Player类或FPS游戏中的Gun类). 比如,一个单个的包含了Player数据的Model会有很多playerDataA, playerDataB,…; 一个处理Player通知的Controller会有很多OnPlayerDidA,OnPlayerDidB,…. 我们想要减小代码体积并且去掉player和OnPlayer前缀. 因为只用数据理解起来很简单,所以我们用一个Model类来做例子. 在写代码时,我通常先用一个单个的Model类包含游戏中的所有数据. 12345678910111213141516171819// Model.csclass Model&#123; public float playerHealth; public int playerLives; public GameObject playerGunPrefabA; public int playerGunAmmoA; public GameObject playerGunPrefabB; public int playerGunAmmoB; // Ops Gun[C D E ...] will appear... /* ... */ public float gameSpeed; public int gameLevel;&#125; 很容易看出,游戏越复杂,变量数会更多.当它够复杂时,我们可能会以一个庞大的包含了model.playerABCDFoo的类来告终.嵌套的元素会简化代码完成,并且使数据有变种的空间. 1234567// Model.csclass Model&#123; public PlayerModel player; // Player数据的容器 public GameModel game; // Game数据的容器&#125; 1234567// GameModel.csclass GameModel&#123; public float speed; // 游戏运行速度 (影响游戏难度) public int level; // 当前载入的游戏关卡/阶段&#125; 12345678// PlayerModel.csclass PlayerModel&#123; public float health; // Player 血量 (在0.0 和 1.0之间) public int lives; // Player 死后"retry"的次数. public GunModel[] guns; // 当前Player在游戏中可切换的枪的数组&#125; 123456789// GunModel.csclass GunModel&#123; public GunType type; // 列举枪的类型 public GameObject prefab; // 枪的3D Asset模板 public int ammo; // 当前子弹数 public int clips; // 可能的再装填弹药的次数&#125; 有了这些类的配置,开发者可以在某时直观地操纵源码中的一个概念.让我们假设一个武器和它们的配置非常多的FPS游戏.GunModel实际上被包含在一个类中,这个类也可以从一系列Prefabs中为各个种类创建实例并将其存储起来方便以后用到. 相比之下,如果所有的枪的信息都包含在一个单独的GunModel中,如gun0Ammo,gun1Ammo,gun0Clips等等,然后当用户需要存储Gun数据的时候,将要需要存储整个Model,即便它还包含了不需要的Player数据.在这种情况下,很明显用一个新的GunModel类会比较好. 就像所有事物都会有优缺点一样.有时人会不必要地过分划分并且增加代码复杂度.只有经验能磨炼你的为你的项目寻找MVC分类的技能. 解锁新的游戏开发特殊能力: 在Unity游戏中使用MVC模式 结论 除此之外还有大量的软件设计模式.在这篇文章中,我尝试着展示了在过去的项目中对我帮助最大的一个.开发者应该一直在吸收新的知识的同时一直保持怀疑.我希望这篇教程能帮助你学习新的东西,并与此同时,成为一个你形成自己的开发风格的跳板. 同时,我真的希望你去多多查找其他的模式来找到最适合你的那个.一个好的出发点是这篇wikipedia文章,里面有出色的模式列表和他们的特征. 如果你喜欢AMVCC模式并且想要尝试它,不要忘了尝试下我的库,Unity MVC,这里包含了所有的,创建AMVCC应用的核心类. 关于作者 https://www.toptal.com/resume/eduardo-dias-da-costa 关于译者 https://blog.ggemo.com/]]></content>
      <tags>
        <tag>unity</tag>
        <tag>设计模式</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lua-study]]></title>
    <url>%2Flua-study%2F</url>
    <content type="text"><![CDATA[Lua语法基础 Lua令牌标记 Lua程序由各种标记组成,标记可是关键字,标识符,常量,字符串或符号. 1io.write("Hello World, from",_VERSION,"\n") 注释 Lua的注释以—开头结尾 12--- 这里是注释print("23333") Lua变量 根据变量范围,Lua变量有三种类型: 全局变量 所有变量被声明为全局变量,除非明确声明为局域变量 局域变量 当变量指定类型为local时,其单位受函数范围的限制 表字段 这是一种特殊类型的变量,可以保存nil之外的任何对象 Lua变量声明和定义 变量定义告诉解释器为变量创建存储的位置和数量,变量具有可选类型,并且包含该类型一个活多个变量的列表(吐槽: 要跟python列表弄混了) 1type variable_list 这里,type是可选的本地或全局类型.而variable_list可以包含一个或多个由逗号分隔的标识符名称. 123local i,jlocal ilocal a,c 变量可以在声明时初始化: 1234567local a, b = 0, 1c, d = 2, 3e,f = 4print(e,f)--- 4 nil--- 注意这里只赋给了e,没有赋给f Lua可以像py那样平行赋值 12345a = 0b = 1a, b = b, aprint(a, b)--- 1 0 Lua数据类型 Lua是一种动态类型语言,即 变量没有类型,只有值有类型 数据类型: 值类型 描述 nil 用于区分值与某些数据或没有数据(类似js里的null或py里的None?) boolean boolean number 表示实数(双精度浮点)数字 string 表示字符数组 function 表示用C语言或Lua编写的方法 userdata 表示任意C语言数据 thread 表示独立的执行线程,用于实现协同程序 table 表示普通数组,符号表,集合,记录,图形,树等,并实现关联数组.它可以保存任何nil以外的值 type函数 12print(type(0))---number 默认情况下,在分配值或初始化之前,所有变量都指向nil. Lua字符串 Lua字符串可以用三种形式初始化 单引号之间的字符串 1'lua' 双引号之间的字符串 1"lua" [[和]]之间的字符串 12[[lua hhhhhhhhaaaaaaa]] [[和]]之间的字符串可以换行,类似py的三个引号的字符串 字符串操作 方法 作用 string.upper(“Some String”) 返回参数的大写表示 string.lower(“Some String”) 返回参数的小写表示 string.gsub(“Some String”, “S”, “啊”) 类似py的replace string.find(“Some String”, “S”) 返回mainStr中,findStr的起始位置和结束位置.我佛辣,这个lua怎么索引都是从1开始的 string.reverse(“Some String”) 返回参数的倒序字符串 string.format(“Some String %d %s”,12,“ccc”) 格式化字符串 string.char(“Some String”)和string.byte(“Some String”) 不解释 string.len(“Some String”) 返回长度ntm不是有#运算符了么??? string.rep(“Some String”,2) 返回参数字符串重复n次后的结果 … …运算链接两个字符串 Lua数组 1234567array = &#123;"a", "b"&#125;print(array[0])--- nilprint(array[1])--- aprint(array[2])--- b Lua数组的索引是从1开始的… Lua数组接受负数和0索引 1234array = &#123;&#125;array[-1] = 10print(array[-1])--- 10 Lua运算符 算术运算符 以下是Lua语言支持的所有算术运算符.假设变量A=10, B=20 运算符 描述 示例 + 两相加操作数 A + B : 30 - 第一个减去第二个操作数 A - B : -10 * 将两个操作数相乘 A * B : 200 / 第一个操作数除以第二个操作数 A / B : 2 % 模数运算符,去整除后的余数 B % A : 0 ^ 指数运算符,取指数幂值 A ^ 2 : 100 - 一元运算符,充当否定 -A : -10 关系运算符 关系运算符 ==, &gt;, &lt;, &gt;=, &lt;=等,跟其他语言差不多. 注意不等于是~=,而非!= 逻辑运算符 and, or, not,和python用起来差不多,只是lua的not只能用于处理布尔值,没有像python那样的a not == b,只能not a == b 杂项运算符 运算符 描述 示例 … 连接两个字符串.惊了,连接字符串不能用+的,只能用这个… “草草草”…“我饿饿” : 草草草我饿饿 # 返回字符串或表长度的一元运算符 #“abc” : 3 Lua的循环 while循环 1234while(condition)do statement(s)end 1234567a = 10while( a &lt; 20 )do print("value of a:", a) a = a + 1end (惊了,lua不支持a += 1这种) for循环 1234for init, max/min value, incrementdo statement(s)end 上面代码中: init首先执行,只执行一次,此步骤允许声明和初始化任何循环控制变量(什么任何?) 接下来执行max/min.这是循环继续执行的最大值或最小值.它在内部创建条件检查,以比较初始值和最大/最小值 在执行for循环体之后,控制流会跳回increment/decrement语句.此语句用于更新循环控制变量. 再次评估条件.如果为真,则循环执行并且过程自身重复(循环体,然后递增步骤,然后再次调节).条件变为false后,for循环终止 1234for i = 1, 10, 1do print(i)end …这语法…我佛辣 顺便试了一下,lua用不着游标卡尺… repeat…until循环 与在顶部测试循环条件的for和while不同,lua的repeat…until循环在底部检查循环的条件. repeat…until循环类似while循环,但是repeat…until循环保证至少执行一次. 123456x = 100repeat x = x + 1 print(x)until x &gt; 10---101 循环控制声明 有break,好像没有continue Lua流程控制 1234if(boolean)then dosomethingend 123456if(boolean)then dosomethingelse dosomethingend 123456789if(boolean)then dosomgthingelseif(boolean)then dosomethingelse sosomethingend 注意: elseif后面需要then,else后面没有 Lua函数 Lua中编程语言中的方法定义一般形式如下: 1234567optional_function_scope function function_name( argument1, argument2, argument3........, argumentn)function_bodyreturn result_params_comma_separatedend 可选函数范围 使用local关键字来限制函数范围或者忽略该部分,使之成为一个全局函数 函数名称 函数的实体名称 参数 函数主体 返回 示例:max函数 12345678910function max(num1, num2) if (num1 &gt; num2) then result = num1; else result = num2; end return result;endprint(max(1,255)) 可变参数函数 使用…作为参数在lua中创建具有可变参数的函数. 12345678910function average(...) result = 0 local arg = &#123;...&#125; for i,v in ipairs(arg) do result = result + v end return result/#argendprint("The average is",average(0)) Lua迭代器 迭代器泛型 迭代器泛型提供集合中每个元素的键值对. 12345678array = &#123; "a", "b" &#125;for k, v in ipairs(array)do print(k, v)end--- 1 a--- 2 b 上面这个例子使用了Lua提供的默认的ipairs迭代器 在Lua中,使用函数来表示迭代器.基于这些迭代器函数中的状态维护,有两种主要类型: 无状态迭代器 这类迭代器不会保留任何状态. md.这个教程写的什么jb,以后再看 Lua表 表是lua中唯一可用的数据结构.使用表可用创建不同的类型,比如数组和字典. Lua使用关联数组,不仅可用数字编制索引,还可以使用除nil之外的字符串编制索引. 123a = &#123;&#125;a["a"] = 233print(a["a"]) 表示和用法 表称为对象,它既不是值也不是变量.Lua是哟构造函数{}来创建一个空表. 表操作 表连接 使用concat函数连接表 table.concat (table [, sep [, i [, j]]]) 12345678910fruits = &#123; "bbb", "ccc", "ddd" &#125;print(table.concat(fruits))--- bbbcccdddprint(table.concat(fruits, ", "))--- bbb, ccc, dddprint(table.concat(fruits, ", ", 2, 3))--- ccc, ddd 插入和删除 table.insert (table, [pos,] value) table.remove (table [, pos]) 1234567891011121314151617arr = &#123; "bbb", "ccc", "ddd" &#125;table.insert(arr,"aaa")print(table.concat(arr," "))--- bbb ccc ddd aaatable.insert(arr,1,"eee")print(table.concat(arr," "))--- eee bbb ccc ddd aaatable.remove(arr)print(table.concat(arr," "))--- eee bbb ccc dddtable.remove(arr, 3)print(table.concat(arr," "))--- eee bbb ddd 排序 12345arr = &#123; "e", "b", "d", "c", "a" &#125;print(table.concat(arr," "))table.sort(arr)print(table.concat(arr," "))]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs-learning]]></title>
    <url>%2Fcs-learning%2F</url>
    <content type="text"><![CDATA[C#数据类型 值类型 类型 描述 范围 默认值 bool 布尔值 True或False False byte 8位无符号整数 0到255 0 sbyte 8位有符号整数 -128到127 char 16位Unicode字符 U +0000 到U +ffff ‘\0’ decimal 128位精确的十进制值,28~29有效位数 (-7.9 * 10 ^ 28)/10 ^ (0 到 28) 0.0M short ushort int uint double float long ulong 引用类型 Object类型 对象(Object)类型是C#通用类型系统中所有数据类型的终极基类. Object类可以被分配给任何其他类型的值.但是在分配之前,需要先进行类型转换. 当一个值类型转换为对象类型时,被称为装箱,当一个对象类型转换为值类型时,被称为拆箱 12object obj;obj = 100; // 这是装箱 Dynamic类型 动态(Dynamic)类型变量可以存储任何类型 1dynamic a = 20; String类型 字符串(String)类型允许给变量分配任何字符串值. C#的字符串只能是双引号,不能单引号. 字符串前面加@,则该字符串的转义符()将被当做普通字符对待(就像python字符串前面加r似的) 12345Console.WriteLine("a\nb");// a// bConsole.WriteLine(@"a\nb");// a\nb 指针类型 **指针类型(Pointer types)**变量存储另一种类型的内存地址. 当一个代码块使用 unsafe 修饰符标记时，C#允许在函数中使用指针变量。不安全代码或非托管代码是指使用了指针变量的代码块。 1char* cptr; 类型转换 类型转换从根本上说是类型铸造,或者说是把数据从一种类型转换到另一种类型. 在C#中,类型转换有两种形式: 隐式类型转换 这些转换是C#默认的以安全方式进行的转换,不会导致数据的丢失.如,从小的整数转换为大的整数,从派生类转换为基类 显式类型转换 即强制类型转换.需要强制转换运算符,可能会造成数据丢失 类型转换方法 1234int i = 1;bool b = Convert.ToBoolean(i);Console.Write(b);// True 循环 foreach循环 使用foreach可以迭代数组或者一个集合对象 123456int[] i = new int[] &#123;114, 514, 1919, 810&#125;;foreach (var a in i)&#123; Console.Write(a); // 1145141919810&#125; 封装 Public Private Protected 允许子类访问它的基类的成员函数和成员变量. Internal 允许一个类将其成员变量和成员函数暴露给当前函数中的其他函数和对象 方法 定义 1234&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)&#123; Method Body&#125; 参数传递 方式 描述 值参数 复制参数的实际值给函数的形参.实参和形参使用的内存不同.形参值改变时不会影响实参. 引用传递 复制参数内存位置的引用给形参.当形参值改变时,会改变实参 输出参数 这种方式可以返回多个值(?) 按值传递 传参的默认方式. 123456789101112131415161718192021public void swap(int x, int y)&#123; int temp; temp = x; x = y; y = temp;&#125;static void Main(string[] args)&#123; Program program = new Program(); int x = 5, y = 6; Console.WriteLine($"&#123;x&#125;,&#123;y&#125;"); // 5,6 program.swap(x, y); Console.WriteLine($"&#123;x&#125;,&#123;y&#125;"); // 5,6&#125; 按引用传递 在C#中,使用ref关键字声明引用参数. 12345678910111213141516171819202122public void swap(ref int x, ref int y)&#123; int temp; temp = x; x = y; y = temp;&#125;static void Main(string[] args)&#123; Program program = new Program(); int x = 5, y = 6; Console.WriteLine($"&#123;x&#125;,&#123;y&#125;"); // 5,6 program.swap(ref x,ref y); Console.WriteLine($"&#123;x&#125;,&#123;y&#125;"); // 6,5&#125; 按输出传递参数 return语句可用于只从函数中返回一个值.但是,可以使用*输出参数来从函数中返回多个值. 输出参数会把方法输出的数据赋值给自己,其他方面与引用参数类似. 1234567891011121314151617public int divmod(int a, int b, out int c)&#123; int div = (int) (a / b); int mod = a % b; c = mod; return div;&#125;static void Main(string[] args)&#123; Program program = new Program(); int x = 11, y = 3; int div, mod; div = program.divmod(x, y, out mod); Console.WriteLine($"&#123;div&#125;,&#123;mod&#125;"); // 3,2&#125; 可空类型 C#提供了一个特殊的数据类型,nullable类型,可空类型可以表示其基础值正常范围内的值,在加上一个null值. 例如Nullable,读作可空的Int32. 在处理数据库和其他包含可能未赋值的元素的数据类型时,将null赋值给数值类型和布尔型的功能特别有用. 可空类型的声明 可空类型的声明语法如下: 1Int32? x; Null合并运算符 Null合并运算符用于定义可空类型和引用类型的默认值. Null合并运算符为类型转换定义了一个预设值,以防可空类型为Null. Null运算符吧操作数类型隐式转换成另一个可空(或不可空)的值类型的操作数的类型. 如果第一个数为null,则运算符返回第二个操作数的值,否则返回第一个操作数的值. 123456789int? a = 1;int x = a ?? 233;Console.WriteLine(x);// 1int? b = null;int y = b ?? 233;Console.WriteLine(y);// 233 数组 数组声明 1int[] a = new int[10]; 数组赋值 数组声明时赋值 声明时赋值可以省略数组大小. 12int[] a = new int[4] &#123;0, 1, 2, 3&#125;;int[] b = new int[] &#123;0, 1, 2, 3&#125;; 数组引用赋值 12int[] a = new int[4];a[1] = 2; 复制数组 这种情况下,目标和源会指向相同的内存位置. 12int[] a = new int[] &#123;0, 1, 2, 3&#125;;int[] b = a; 遍历数组 12345int[] a = new int[] &#123;0, 1, 2, 3&#125;;foreach (int v in a)&#123; Console.WriteLine(v);&#125; 结构体 12345678910struct A&#123; public int a; public String s; public int func(int x) &#123; return x + a; &#125;&#125;; 枚举 枚举是一组命名整型常量.枚举是使用enum关键字声明的. C#枚举是值类型,即 枚举包含自己的值,且不能继承或传递继承. 123var x = A.a;Console.WriteLine(x);// 0 类 析构函数 在程序结束前执行(大概?) 1234567class A&#123; ~A() &#123; Console.WriteLine("Cancel."); &#125;&#125; 类的静态成员 使用static关键字把类成员定义为静态. 当我们声明一个类成员为静态时,无论多少个类被创建,只会有一个改进静态类成员的副本. 静态变量用于定义常量,他们的值可以通过直接调用类而不需要创建类的实例来获取(无法通过实例来访问,只能通过类访问). 静态变量可以在成员函数或类的定义外部进行初始化,也可以在类的定义内部进行初始化.]]></content>
      <tags>
        <tag>废弃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第12章-屏幕后处理效果]]></title>
    <url>%2Fshader-r-screen-post-processing-effects%2F</url>
    <content type="text"><![CDATA[屏幕后处理效果(screen post-processing effects)是游戏中实现屏幕特效的常见方法. 建立一个基本的屏幕后处理脚本系统 屏幕后处理,指的是在渲染完整个场景得到屏幕图像后,再对这个图像进行一系列操作,实现各种屏幕特效. 这种技术可以为游戏添加很多的艺术效果.,例如景深(Depth of Field), 运动模糊(Motion Blur)等. 因此,想要实现屏幕后处理的基础在于得到渲染后的屏幕图像,即抓取屏幕,而Unity为我们提供了这样一个方便的接口:OnRenderImage函数: MonoBehaviour.OnRenderImage (RenderTexture src, RenderTexture dest) 当我们在脚本中声明此函数后,Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中,通过函数中的一系列操作后,再把目标渲染纹理,即第二个参数对应的渲染纹理显示到屏幕上. 在OnRenderImage函数中,我们通常是利用Graphics.Blit函数来完成对渲染纹理的处理. public static void Blit(Texture src, RenderTexture dest) public static void Blit(Texture src, RenderTexture dest, Material mat, int pass = -1) public static void Blit(Texture src, Material mat, int pass = -1) 其中,src对应了源纹理, 在屏幕后处理技术中,这个参数就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理. 参数dest是目标渲染纹理,如果它的值为null就会直接将结果显示在屏幕上. 参数mat是我们使用的材质,这个材质使用的Unity Shader将会进行各种屏幕后操作,而src纹理将会被传递给Shader中名为_MainTex的纹理属性. 参数pass的默认值为-1, 表示将会依次调用Shader内的所有Pass.否则,只会调用指定索引的Pass. 在默认情况下,OnRenderImage函数会在所有的不透明和透明的Pass执行完毕后被调用,一遍对场景中所有游戏对象产生影响.但有时,我们希望在不透明Pass执行完毕后就立即调用OnRenderImage函数,从而不对透明物体产生任何影响.此时,我们可以在OnRenderImage函数前添加ImageEffectOpaque属性来实现这样的目的.(将在13.4节遇到) 因此,要在Unity中实现屏幕后处理效果,过程通常如下: 首先 我们需要在摄像机中添加一个用于屏幕后处理的脚本. 在这个脚本中,我们会实现OnRenderImage函数来获取当前屏幕的渲染纹理. 然后 再调用Graphics.Blit函数使用特定的UnityShader来对当前图像进行处理,再把返回的渲染纹理显示到屏幕上. 对于一些复杂的屏幕特效,我们可能需要多次调用Graphics.Blit函数来对上一步的输出结果进行下一步处理… 但是,在进行屏幕后处理之前,我们需要检查一系列条件是否满足,例如当前平台是否支持渲染纹理和屏幕特效,是否支持当前使用的Unity Shader等. 为此,我们创建了一个用于屏幕后处理效果的基类,在实现各种屏幕特效时,我们只需要继承自该积累,在实现派生类中不同的操作即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using UnityEngine;using System.Collections;// 使在编辑器状态下也可以执行该脚本来查看效果[ExecuteInEditMode][RequireComponent (typeof(Camera))]public class PostEffectsBase : MonoBehaviour &#123; // 为了提前检查各种资源和条件是否满足,我们在Start函数中调用CheckResource函数 protected void CheckResources() &#123; bool isSupported = CheckSupport(); if (isSupported == false) &#123; NotSupported(); &#125; &#125; // Called in CheckResources to check support on this platform protected bool CheckSupport() &#123; if (SystemInfo.supportsImageEffects == false || SystemInfo.supportsRenderTextures == false) &#123; Debug.LogWarning("This platform does not support image effects or render textures."); return false; &#125; return true; &#125; // Called when the platform doesn't support this effect protected void NotSupported() &#123; enabled = false; &#125; protected void Start() &#123; CheckResources(); &#125; // 一些屏幕特效可能需要更多的设置,例如设置一些默认值等,可以重载Start,CheckResources或CheckSupport函数. // 由于每个品目后处理效果通常需要指定一个Shader来创建一个用于处理渲染纹理的材质,因此基类中也提供了这种方法: // Called when need to create the material used by this effect // CheckShaderAndCreateMaterial函数接受两个参数,第一个参数制定了该特效需要使用的Shader,第二个参数则是用于后期处理的材质. // 该函数首先检查Shader的可用性,检查通过之后就返回一个使用了该Shader的材质,否则返回null protected Material CheckShaderAndCreateMaterial(Shader shader, Material material) &#123; if (shader == null) &#123; return null; &#125; if (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader) return material; if (!shader.isSupported) &#123; return null; &#125; else &#123; material = new Material(shader); material.hideFlags = HideFlags.DontSave; if (material) return material; else return null; &#125; &#125;&#125; 在下面一节我们就会看到如何继承PostEffect.cs来创建一个简单的用于调整屏幕的亮度,饱和度和对比度的特效脚本. 调整屏幕的亮度,饱和度和对比度. 新建一个脚本,名BrightnessSaturationAndContrast.cs 12345678910111213141516171819202122232425262728293031323334353637383940using UnityEngine;using System.Collections;// 首先,继承PostEffectsBase类public class BrightnessSaturationAndContrast : PostEffectsBase &#123; // 声明使用的Shaser,并据此创建相应的材质. public Shader briSatConShader; // 指定的Shader private Material briSatConMaterial; // 创建的材质 public Material material &#123; // material的get函数调用了基类的CheckShaderAndCreateMaterial函数来得到对应的材质 get &#123; briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial); return briSatConMaterial; &#125; &#125; // 调整亮度,饱和度和对比度的参数. [Range(0.0f, 3.0f)] public float brightness = 1.0f; [Range(0.0f, 3.0f)] public float saturation = 1.0f; [Range(0.0f, 3.0f)] public float contrast = 1.0f; // 定义OnRenderImage函数来进行真正的特效处理 void OnRenderImage(RenderTexture src, RenderTexture dest) &#123; if (material != null) &#123; material.SetFloat("_Brightness", brightness); material.SetFloat("_Saturation", saturation); material.SetFloat("_Contrast", contrast); Graphics.Blit(src, dest, material); &#125; else &#123; Graphics.Blit(src, dest); &#125; &#125;&#125; 每当OnrenderI函数被调用时,它会检查材质是否可用.如果可用,就把参数传递给材质,再调用Graphics.Blit进行处理; 否则,直接把原图像显示到屏幕上,不做任何处理. 之后是Shader的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Shader "Unity Shaders Book/Chapter 12/Brightness Saturation And Contrast" &#123; Properties &#123; _MainTex ("Base (RGB)", 2D) = "white" &#123;&#125; // 声明用于调整亮度,饱和度和对比度的属性.这些值将会由脚本传递而得 // 事实上,我们可以省略这些属性声明,因为对于屏幕特效来说,它们使用的材质都是临时创建的,我们不需要在材质面板上调整参数,而是直接从脚本你传递给UnityShader _Brightness ("Brightness", Float) = 1 _Saturation("Saturation", Float) = 1 _Contrast("Contrast", Float) = 1 &#125; SubShader &#123; Pass &#123; // 屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片,为了防止它对其他物体产生影响,我们需要设置相关的渲染状态: // 关闭深度写入,为了防止其挡住在其后面渲染的物体 // 这些状态设置是屏幕后处理的Shader的标配 ZTest Always Cull Off ZWrite Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" sampler2D _MainTex; half _Brightness; half _Saturation; half _Contrast; struct v2f &#123; float4 pos : SV_POSITION; half2 uv: TEXCOORD0; &#125;; // 顶点着色器比较简单,只需进行必要的顶点变换并把正确的纹理传递给片元着色器 // TODO: 疑问:屏幕后渲染不是把模型都渲染到屏幕空间后再进行的么?为什么要把顶点坐标变换到剪裁空间? // 这里的appdata_img是unity内置的结构体,他只包含了图像处理时必须的顶点坐标和纹理坐标等变量. 可以在UnityCG.cginc中找到它的声明 // 抄下来://struct appdata_img//&#123;// float4 vertex : POSITION;// half2 texcoord : TEXCOORD0;// UNITY_VERTEX_INPUT_INSTANCE_ID//&#125;; v2f vert(appdata_img v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed4 renderTex = tex2D(_MainTex, i.uv); // Apply brightness fixed3 finalColor = renderTex.rgb * _Brightness; // Apply saturation fixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b; fixed3 luminanceColor = fixed3(luminance, luminance, luminance); finalColor = lerp(luminanceColor, finalColor, _Saturation); // Apply contrast fixed3 avgColor = fixed3(0.5, 0.5, 0.5); finalColor = lerp(avgColor, finalColor, _Contrast); return fixed4(finalColor, renderTex.a); &#125; ENDCG &#125; &#125; Fallback Off&#125; 边缘检测 边缘检测的原理是利用一些边缘检测算子对图像进行卷积(convolution)操作. 什么是卷积 在图像处理中,卷积指的是使用一个卷积核(kernel)对一张图片中的每个像素进行一些列操作. 卷积核通常是一个四方形网格结构,该区域的每个方格都有一个权重值.当对图像中的某个像素进行卷积时,我们会把卷积核的中心置于该像素上. 如图所示,翻转核之后再以此计算何种每个元素和其覆盖的图像的像素值的乘积并求和,得到的结果就是该位置的新像素值. 这样的操作虽然简单,但可以实现很多常见的图像处理效果,如图像模糊,边缘检测等. 例如,如果我们想多图像进行均值模糊,可以使用一个3x3的卷积核,核内每个元素的值均为1/9. 常见的边缘检测算子 如果相邻像素之间存在差别明显的颜色,亮度,纹理等属性,我们会认为它们之间应该有一条边界. 这种相邻像素之间的插值可以用梯度(gradient)来表示,可以想象得到,边缘处的梯度绝对值会比较大. 基于这样的理解,有几种不同的边缘检测算子(即用于边缘检测的卷积核)被先后提出来. 卷积操作的神奇之处在于卷积核. 它们都包含两个方向的卷积核,分别用于检测水平方向和竖直方向上的边缘信息. 在进行边缘检测时,我们需要对每个像素分别进行一次卷积计算,得到两个方向上的梯度值G(x)和G(y),而整体的梯度可按下面的公式计算而得: G = sqrt(G(x)**2 + G(y)**2) 由于开根号操作比较复杂,出于性能考虑,我们有时候会使用绝对值操作来代替开根号操作: G = |G(x)| + |G(y)| 得到梯度G后,我们就可以据此来判断哪些像素对应了边缘:梯度越大,越有可能是边缘. 实践: Sobel边缘检测算子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Shader "Unity Shaders Book/Chapter 12/Edge Detection" &#123; Properties &#123; _MainTex ("Base (RGB)", 2D) = "white" &#123;&#125; _EdgeOnly ("Edge Only", Float) = 1.0 _EdgeColor ("Edge Color", Color) = (0, 0, 0, 1) _BackgroundColor ("Background Color", Color) = (1, 1, 1, 1) &#125; SubShader &#123; Pass &#123; ZTest Always Cull Off ZWrite Off CGPROGRAM #include "UnityCG.cginc" #pragma vertex vert #pragma fragment frag sampler2D _MainTex; // XXX_TexelSize是Unity为我们提供的访问XXX纹理对应的每个纹素的大小. // 由于卷积需要对相邻区域内的纹理进行采样,因此我们需要利用_MainTex_TexSize来计算各个相邻区域的纹理坐标. uniform half4 _MainTex_TexelSize; fixed _EdgeOnly; fixed4 _EdgeColor; fixed4 _BackgroundColor; struct v2f &#123; float4 pos : SV_POSITION; // 位数为9的纹理数组,对应的是使用Sobel算子采样是需要的9个邻域纹理坐标 half2 uv[9] : TEXCOORD0; &#125;; v2f vert(appdata_img v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); half2 uv = v.texcoord; // _MainTex_TexelSize.xy和移动量相乘之后,才得到真正的坐标(大概这个意思) o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1); o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1); o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1); o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0); o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0); o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0); o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1); o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1); o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1); return o; &#125; // 取亮度值的函数 fixed luminance(fixed4 color) &#123; return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; &#125; // 使用Sobel算子对原图进行边缘检测的函数 half Sobel(v2f i) &#123; // 水平和竖直方向上的卷积核 const half Gx[9] = &#123;-1, 0, 1, -2, 0, 2, -1, 0, 1&#125;; const half Gy[9] = &#123;-1, -2, -1, 0, 0, 0, 1, 2, 1&#125;; half texColor; half edgeX = 0; half edgeY = 0; // 遍历⑨个像素 for (int it = 0; it &lt; 9; it++) &#123; // 采样之后计算亮度值 texColor = luminance(tex2D(_MainTex, i.uv[it])); // 亮度值与卷积核对应的权重相乘,叠加至各自的梯度值上 edgeX += texColor * Gx[it]; edgeY += texColor * Gy[it]; &#125; // edge越小,梯度越大,该点越可能是边缘 half edge = 1 - abs(edgeX) - abs(edgeY); return edge; &#125; fixed4 frag(v2f i) : SV_Target &#123; half edge = Sobel(i); // 混合 fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge); fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge); return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); &#125; ENDCG &#125; &#125; FallBack Off&#125; 需要注意的是,本例中的边缘检测仅仅利用了屏幕的颜色信息,而实际应用中,物体的纹理,阴影等信息均会影响边缘检测的结果,使得结果包含许多非预期的描边. 为了得到更准确的边缘嘻嘻,我们往往会在屏幕的深度纹理和法线纹理上进行边缘检测.(将会在13章实现) 高斯模糊 模糊的实现有许多种方法,例如均值模糊和中值模糊. 均值模糊同样使用了卷积操作,它只用的卷积核的各个元素值都相等,且相加等于1. 也就是说,卷积后得到的像素值是其邻域中的各个像素的平均值. 而中值模糊是选择邻域内对应所有像素排序后的中值替换掉原有的颜色. 一个更高级的模糊方法是高斯模糊. 高斯滤波 高斯模糊同样使用了卷积计算,它使用的卷积核名为高斯核. 高斯核是一个正方形大小的滤波核,其中每个元素的计算都是基于下面的高斯方程: 其中,打不出来的那个是标准方差(一般取值为1),x,y分别对应了当前位置到卷积核中心的整数距离. 要构建一个高斯核,我们只需要计算高斯核中各个位置对应的高斯值. 为了保证滤波后的图像不会变暗,我们需要对高斯核中的权重进行归一化,即让每个权重除以所有权重的和,这样可以保证所有权重的和为1. 因此,高斯函数中e前面的系数实际不会对结果有任何影响. 如图显示的是一个标准方差为1的5x5大小的高斯核 高斯方程很好的模拟了邻域每个像素对当前处理像素的影响程度–距离越近,影响越大. 高斯核维度越高,模糊程度越大.采用一个NxN的高斯核对图像进行卷积滤波,就需要NxNxWxH(W和H分别是图像的宽和高)次纹理采样.当N的大小不断增加时,采样的次数会变得非常巨大. 幸运的是,我们可以吧这个二维高斯函数拆分成两个一维函数.也就是说,我们可以使用两个一维的高斯核进行滤波,它们得到的结果跟直接使用二维高斯核进行滤波是一样的,但采样次数只需要2xNxWxH. 我们可以观察到,两个一维高斯核中包含很多重复的权重,实际上我们只需要计算三个权重即可. 实践: 高斯模糊 我们使用一个5x5的高斯核对原图进行高斯模糊. 我们将先后调用两个Pass,第一个Pass将会使用竖直方向的一维高斯核对图像进行滤波,第二个Pass再使用水平方向的一维高斯核对图像进行滤波,得到最终图像. 我们还将利用图像缩放来进一步提高性能,并通过调整高斯滤波的次数来控制模糊程度(次数越多,图像越模糊) 绑定在摄像头的C#代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using UnityEngine;using System.Collections;public class GaussianBlur : PostEffectsBase &#123; public Shader gaussianBlurShader; private Material gaussianBlurMaterial = null; public Material material &#123; get &#123; gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial); return gaussianBlurMaterial; &#125; &#125; // 迭代次数,次数越多,模糊程度越高 [Range(0, 4)] public int iterations = 3; // 模糊范围和缩放系数 // 这两项是为性能考虑的 // 模糊范围越大,模糊程度越高,但采样数不会受到影响.但过大的模糊范围可能会造成虚影. // 缩放系数越大,需要处理的像素数越少,同时也进一步提高模糊程度,但过大可能会是图像像素化. [Range(0.2f, 3.0f)] public float blurSpread = 0.6f; [Range(1, 8)] public int downSample = 2; void OnRenderImage (RenderTexture src, RenderTexture dest) &#123; if (material != null) &#123; //先利用缩放对图像进行降采样 int rtW = src.width/downSample; int rtH = src.height/downSample; // 与之前不同,这里使用了RenderTexture.GetTemporary函数分配了一块缓冲区. // 这是因为,高斯模糊需要调用两个Pass,我们需要使用一块中间缓存来存储第一个Pass执行完毕后得到的模糊结果. // 缓冲区的宽高为缩放后的宽高 RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0); buffer0.filterMode = FilterMode.Bilinear; Graphics.Blit(src, buffer0); // 迭代多次 for (int i = 0; i &lt; iterations; i++) &#123; material.SetFloat("_BlurSize", 1.0f + i * blurSpread); RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); // 第一个Pass Graphics.Blit(buffer0, buffer1, material, 0); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); // 第二个Pass Graphics.Blit(buffer0, buffer1, material, 1); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; &#125; Graphics.Blit(buffer0, dest); RenderTexture.ReleaseTemporary(buffer0); &#125; else &#123; Graphics.Blit(src, dest); &#125; &#125;&#125; Shader代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103Shader "Unity Shaders Book/Chapter 12/Gaussian Blur" &#123; Properties &#123; _MainTex ("Base (RGB)", 2D) = "white" &#123;&#125; _BlurSize ("Blur Size", Float) = 1.0 &#125; SubShader &#123; // CGINCLUDE和ENDCG定义的代码不需要包含在任何Pass中,在使用时,只需在Pass中指定需要的顶点和片元着色器即可. // 由于高斯模糊需要定义两个Pass,但他们使用的片元着色器的代码是完全相同的,使用CGINCLUDE可以避免我们编写两个完全一样的frag函数 CGINCLUDE #include "UnityCG.cginc" sampler2D _MainTex; half4 _MainTex_TexelSize; float _BlurSize; struct v2f &#123; float4 pos : SV_POSITION; half2 uv[5]: TEXCOORD0; &#125;; // 竖直方向上的顶点着色器代码 v2f vertBlurVertical(appdata_img v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); half2 uv = v.texcoord; o.uv[0] = uv; // 和_BlurSize相乘控制控制采样距离. o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize; o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize; o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize; o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize; return o; &#125; // 水平方向上的顶点着色器代码 v2f vertBlurHorizontal(appdata_img v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); half2 uv = v.texcoord; o.uv[0] = uv; o.uv[1] = uv + float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize; o.uv[2] = uv - float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize; o.uv[3] = uv + float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize; o.uv[4] = uv - float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize; return o; &#125; fixed4 fragBlur(v2f i) : SV_Target &#123; // 我们只需记录3个高斯权重 float weight[3] = &#123;0.4026, 0.2442, 0.0545&#125;; fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0]; for (int it = 1; it &lt; 3; it++) &#123; sum += tex2D(_MainTex, i.uv[it*2-1]).rgb * weight[it]; sum += tex2D(_MainTex, i.uv[it*2]).rgb * weight[it]; &#125; return fixed4(sum, 1.0); &#125; ENDCG ZTest Always Cull Off ZWrite Off Pass &#123; // 为Pass定义名字,可以在其他Shader中直接通过它们的名字来使用该Shader,而不用编写重复的代码 NAME "GAUSSIAN_BLUR_VERTICAL" CGPROGRAM #pragma vertex vertBlurVertical #pragma fragment fragBlur ENDCG &#125; Pass &#123; NAME "GAUSSIAN_BLUR_HORIZONTAL" CGPROGRAM #pragma vertex vertBlurHorizontal #pragma fragment fragBlur ENDCG &#125; &#125; FallBack "Diffuse"&#125; Bloom效果 Bloom是游戏中常见的一种屏幕效果,这种特效可以模拟真实摄像机的一种图像效果,它让画面中较亮的区域&quot;扩散&quot;到周围的区域,造成一种朦胧的感觉. 实现原理: 我们首先根据一个阈值提取出图像中较亮的区域,把他们存储在一张纹理中,再利用高斯模糊对这张渲染纹理进行模糊处理,模拟光线扩散的效果,最后再将其和原图像进行混合,得到最终效果.]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[油管直播转推流到B站]]></title>
    <url>%2Fyoutube-live-2-bili%2F</url>
    <content type="text"><![CDATA[ffmpeg下载地址: http://ffmpeg.zeranoe.com/builds/ youtube-dl下载地址: http://www.youtube-dl.org/ 123456789101112131415161718192021222324252627282930import os,platformdef liveTrans(fromPath, toPath, ffmpegPath, youtubeDlPATH): getRealFromPathCMD = youtubeDlPATH + " -g " + fromPath realFromPath = os.popen(getRealFromPathCMD).read().strip() if platformName[:7] == "Windows": postCMD = ffmpegPath + ' -i "' + realFromPath + '" -vcodec copy -acodec aac -f flv "' + toPath + '"' else: postCMD = ffmpegPath + ' -i "' + realFromPath + '" -c:v copy -c:a aac -b:a 320k -ar 44100 -strict -2 -f flv "' + toPath + '"' os.system(postCMD)if __name__ == '__main__': platformName = platform.platform() if platformName[:7] == "Windows": ffmpegPATH = r"D:\ProgramFiles\ffmpeg\bin\ffmpeg.exe" youtubeDlPATH = r"D:\ProgramFiles\ffmpeg\bin\youtube-dl.exe" else: ffmpegPATH = "ffmpeg" youtubeDlPATH = "youtube-dl" ffmpegPath = "ffmpeg" youtubeDlPath = "youtube-dl" liveTrans(fromPath="frompath here", toPath="toPath here", ffmpegPath=ffmpegPATH, youtubeDlPATH=youtubeDlPATH) emm,结果windows下报错连接不上youtube那个流的链接…新租的centos倒是可以…不知道是windows下的ffmpeg命令错了还是那个流不走代理… centos下安装ffmpeg和youtube-dl: 12345678yum install -y epel-releasesudo rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7sudo rpm –import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rosudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpmyum install -y ffmpegwget http://youtube-dl.org/latest/youtube-dl -O /usr/local/bin/youtube-dlchmod a+x /usr/local/bin/youtube-dl ffmpeg支持多个输出,linux下postCMD改为这个,边推流边保存到本地. 1postCMD = ffmpegPath + &apos; -i &quot;&apos; + realFromPath + &apos;&quot; -c:v copy -c:a aac -b:a 320k -ar 44100 -strict -2 -f flv &quot;&apos; + toPath + &apos;&quot;&apos; + &apos; -c:v copy -c:a aac -b:a 320k -ar 44100 -strict -2 -f flv &quot;./tmp.flv&quot;&apos; 参考: https://www.bilibili.com/read/cv1083415/ 顺便,ffmpeg裁剪视频(指时间上裁剪): 1./ffmpeg -i inputFilePath -ss 05:00 -c copy outputFilePath]]></content>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第11章-让画面动起来]]></title>
    <url>%2Fshader-r-moving%2F</url>
    <content type="text"><![CDATA[Unity Shader中的内置变量(时间篇) 名称 类型 描述 _Time float4 t是自该场景加载开始所经过的时间,4个分量分别是(t/20, t, 2t, 3t) _SinTime float4 t是时间的正弦值,4个分量的值分别是(t/8, t/4, t/2, t) _CosTime float4 t是时间的余弦值,4个分量的值分别是(t/8, t/4, t/2, t) unity_DeltaTime float4 dt是时间增量,4个分量分别是(dt, 1/dt, smoothDt, 1/smoothDt) 纹理动画 纹理动画在游戏中的应用非常广泛.尤其在各种资源都比较局限的移动平台上,我们往往会使用纹理动画来代替复杂的粒子系统等模拟各种动画效果 序列帧动画 最常见的纹理动画之一就是序列帧动画.序列帧动画的原理非常简单,它像放电影一样,依次播放一系列关键帧图像. 它的优点在于灵活性极强,不需要任何物理计算就能得到非常细腻的动画效果. 想要实现序列帧动画,我们先要提供一张包含了关键帧图像的图像. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Shader "Unlit/11.2"&#123; Properties &#123; _Color("Color Tint", Color) = (1, 1, 1, 1) _MainTex ("Image Sequence", 2D) = "white" &#123;&#125; // 水平方向和竖直方向包含的关键帧的个数 _HorizontalAmount ("Horizontal Amount", Float) = 4.0 _VerticalAmount ("Vertical Amount",Float) = 4.0 _Speed("Speed",Range(1, 100)) = 30 &#125; SubShader &#123; Tags &#123; "RenderType"="Transparent" "Queue"="Transparent" "IgnoreProjector"="True" &#125; Pass &#123; Tags &#123;"LightMode"="ForwardBase"&#125; ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; float _HorizontalAmount; float _VerticalAmount; float _Speed; struct a2v &#123; float4 vertex : POSITION; float2 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; &#125;; v2f vert (a2v v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_TARGET &#123; float time = floor(_Time.y * _Speed); float row = floor(time / _HorizontalAmount); float column = time - row * _HorizontalAmount; half2 uv = i.uv + half2(column, -row); uv.x /= _HorizontalAmount; uv.y /= _VerticalAmount; fixed4 c = tex2D(_MainTex, uv); c.rgb *= _Color; return c; &#125; ENDCG &#125; &#125;&#125; 滚动的背景 很多2D游戏都使用了不同的滚动背景来模拟游戏角色在场景中的穿梭.这些背景往往包含了多个层来模拟一种视差效果.而这些背景的实现往往就是利用了纹理动画. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Shader "Unity Shaders Book/Chapter 11/Water" &#123; Properties &#123; // 河流纹理 _MainTex ("Main Tex", 2D) = "white" &#123;&#125; // 主体颜色 _Color ("Color Tint", Color) = (1, 1, 1, 1) // 波动幅度 _Magnitude ("Distortion Magnitude", Float) = 1 // 波动频率 _Frequency ("Distortion Frequency", Float) = 1 // 波长倒数(这个值越大,波长越小) _InvWaveLength ("Distortion Inverse Wave Length", Float) = 10 // 纹理的移动速度 _Speed ("Speed", Float) = 0.5 &#125; SubShader &#123; // 一些SubShader在使用Unity批处理时会出现问题,这是可以通过DisableBatching标签指明是否对该SubShader使用批处理. // 批处理会合并所有相关的模型,而这些模型各自的模型空间就会丢失.而顶点动画需要在物体的模型空间下进行偏移. Tags &#123;"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" "DisableBatching"="True"&#125; Pass &#123; Tags &#123; "LightMode"="ForwardBase" &#125; ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; float _Magnitude; float _Frequency; float _InvWaveLength; float _Speed; struct a2v &#123; float4 vertex : POSITION; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; &#125;; v2f vert(a2v v) &#123; v2f o; float4 offset; offset.yzw = float3(0.0, 0.0, 0.0); offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude; o.pos = UnityObjectToClipPos(v.vertex + offset); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); o.uv += float2(0.0, _Time.y * _Speed); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed4 c = tex2D(_MainTex, i.uv); c.rgb *= _Color.rgb; return c; &#125; ENDCG &#125; &#125; FallBack "Transparent/VertexLit"&#125; 广告牌 另一种常见的顶点动画就是广告牌技术(Billboarding). 广告牌技术会根据视角方向来旋转一个被纹理着色的多边形(通常就是简单的四边形,这个多边形就是广告牌),使得多边形看起来好像总面对着摄像机. 广告牌技术的本质就是构建旋转矩阵,而我们知道一个矩阵需要三个基向量. 广告牌技术使用的基向量通常就是表面法线(normal),指向上的方向以及指向右的方向. 除此之外,我们还需要一个锚点(anchor location),这个锚点在旋转的过程中是固定不变的,以此来确定多边形在空间中的位置. 广告牌技术的难点在于,如何根据需求来构建3个相互正交的基向量. 计算过程通常是,我们首先会通过初始计算得到目标的表面法线(例如视角方向)和指向上的方向,而两者往往是不垂直的.但是,两者其中之一是固定的,例如模拟草丛时,我们希望广告牌的指向上的方向永远是(0, 1, 0),而法线方向应该随视角变化;而当模拟粒子效果时,我们希望广告牌的法线方向是固定的,即总指向视角方向,指向上的方向则可以发生变化. 我们假设法线方向是固定的,首先,我们根据初始的表面法线和指向上的方向来计算目标方向和指向右的方向(通过叉积操作): right = up X normal 对其归一化后,再由法线方向和指向右的方向计算出正交的指向上的方向: up’ = normal X right 如此,我们就可以得到用于旋转的三个正交基了.上图给出了计算过程的演示. 如果指向上的方向是固定的,计算过程也是类似. 实践: 广告牌 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Shader "Unity Shaders Book/Chapter 11/Billboard" &#123; Properties &#123; _MainTex ("Main Tex", 2D) = "white" &#123;&#125; _Color ("Color Tint", Color) = (1, 1, 1, 1) _VerticalBillboarding ("Vertical Restraints", Range(0, 1)) = 1 &#125; SubShader &#123; Tags &#123;"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" "DisableBatching"="True"&#125; Pass &#123; Tags &#123; "LightMode"="ForwardBase" &#125; ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _VerticalBillboarding; struct a2v &#123; float4 vertex : POSITION; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; &#125;; v2f vert (a2v v) &#123; v2f o; float3 center = float3(0, 0, 0); // 获取摄像机位置 float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1)); // 目标法线 float3 normalDir = viewer - center; // _VerticalBillboarding 调整固定法线还是固定指向上 // 当该值为1时,固定法线,为1时,固定向上方向为(0, 1, 0) normalDir.y =normalDir.y * _VerticalBillboarding; normalDir = normalize(normalDir); // 如果目标法线跟向上方向平行,两者的叉积则会出错. // 这里对目标法线的分量y进行了判断,以得到合适的向上方向. float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0); // 求向上方向和目标法线的垂线,即向右向量,并归一化 float3 rightDir = normalize(cross(upDir, normalDir)); // 因为固定了法线,所以重新求得向上向量 upDir = normalize(cross(normalDir, rightDir)); float3 centerOffs = v.vertex.xyz - center; // 这里卡了我好一会儿,以为是内积求投影来着,然而是分量(一个标量)和正交基相乘 float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z; o.pos = UnityObjectToClipPos(float4(localPos, 1)); o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; fixed4 c = tex2D (_MainTex, i.uv); c.rgb *= _Color.rgb; return c; &#125; ENDCG &#125; &#125; FallBack "Transparent/VertexLit"&#125; 注意事项 批处理 之前说的顶点动画必须关闭批处理,然而关闭批处理就会增多Draw Call,降低性能. 因此我们应该尽量避免使用模型空间下一些绝对位置和方向进行计算. 在广告牌的例子中,为了避免显式使用模型空间的中心点作为锚点,可以利用顶点颜色来存储每个顶点到锚点的距离值(smg),这种做法在商业游戏里很常见. 阴影 到时候再看吧. P239]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线动画推特预览]]></title>
    <url>%2Fazurlane-anime-tweet-preview%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>bot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第9章-更复杂的光照]]></title>
    <url>%2Fshader-r-complex-lighting%2F</url>
    <content type="text"><![CDATA[在之前的学习中,我们的场景之中都只有一个光源,且光源类型是平行光. 但在实际的游戏开发中,我们往往需要更多,更复杂的光源.更重要的是,我们要得到阴影. Unity的渲染路径 在Unity里,渲染路径(Rendering Path)决定了光照是如何应用到Unity Shader中的.因此,如果要和光源打交道,我们需要为每个Pass指定它们的渲染路径,只有为Shader正确地选择和设置了需要的渲染路径,该Shader的光照才会被正确执行. TODO: 看到这里,我就觉得跟我想要应聘的公司的工作不怎么搭了,先跳过]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第8章-透明效果]]></title>
    <url>%2Fshader-r-alpha-effect%2F</url>
    <content type="text"><![CDATA[Unity中,有两种方式实现透明效果: 一种是透明度测试(Alpha Test),这种方法无法得到真正的半透明效果;另一种方法是透明度混合(Alpha Blending) 对于不透明物体,不考虑渲染顺序也能得到正确的排序结果,这是由于强大的深度缓冲(depth-buffer,也称z-buffer)的存在. 在实时渲染中,深度缓冲是用于解决可见性问题的,它会解决哪些物体的哪些部分会被渲染在前面,哪些部分会被遮挡. 如果想要实现透明度效果,需要关闭深度写入. 透明度测试和透明度混合的原理如下: 透明度测试 采用一种&quot;极其霸道&quot;的机制,只要一个片元的透明度不满足条件(通常是小于某个阈值),那么它对应的片元就会被舍弃.被舍弃的片元将不会再做任何处理,也不会对颜色缓冲区造成影响.透明度测试是不需要关闭深度写入的,它和其他不透明物体最大的不同在于它会根据透明度舍弃一些片元.虽然简单,但其产生的效果会很极端:要么完全透明,要么不透明. 透明度混合 这种方法可以得到真正的半透明的效果.他会使用当前片元的透明度作为混合因子,与已经存储到颜色缓冲中的颜色进行混合,得到新的颜色.但是,透明度混合需要关闭深度写入,但没有关闭深度测试,这意味着如果使用透明度混合去渲染一个片元的话时,还是会比较它和当前缓冲区中的深度值.也就是说,对于透明度混合来说,深度缓冲是只读的. 渲染顺序 关闭深度写入很重要 使用透明度混合时,如果不关闭深度写入: 如果一个半透明表面背后的表面本是可以透过前面的表面被我妈看到的,但由于深度测试时判断结果是前面的半透明表面距离摄像机更近,导致后面的表面将会被剔除,我们无法透过半透明表面看到后面的物体了. 但是,我们破坏了深度缓冲的工作机制,而这是一个非常非常糟糕的事情,尽管我们不得不这样做: 关闭深度写入导致渲染顺序变得非常重要 不同的渲染顺序会得到的结果 假设场景里有两个物体:A和B,其中A是半透明物体,B是不透明物体,如图所示 第一种情况:先渲染B,再渲染A 由于不透明物体开启了深度测试和深度写入,而因此我们的深度缓存中没有任何有效数据,因此B首先会写入颜色缓冲和深度缓冲.随后我们渲染透明物体A,仍会进行深度测试,而我们发现A比B距离摄像头更近,所以我们会使用A的带透明度颜色和B的颜色进行混合,得到正确的半透明效果 第二种情况:先渲染A,再渲染B 渲染A时,深度缓冲中没有任何有效数据,因此A直接写入颜色缓冲.但不会写入深度缓冲.等渲染B时,进行深度测试的时候,深度缓冲中没有任何有效数据,会直接覆盖A的颜色,从视觉上来看,B出现在了A的前面,而这是错误的. 因此,渲染引擎一般都会对物体进行排序,再渲染.常见方法是: 先渲染所有不透明物体,并对他们开启深度测试和深度写入; 再把半透明物体按它们距离摄像机的远近排序,然后按照从后往前的顺序渲染这些半透明物体,并开启它们的深度测试(但关闭深度写入); 但是,这种方法仍然存在问题: 第二步中的渲染顺序,是依靠距离摄像机的深度判断的,而深度缓冲中的值其实是像素级别的,但是我们需要对物体级别进行排序.如图,会得到3个物体循环的情况. 尽管总有一些情况打乱我们的阵脚,但由于上述方法足够有效且容易实现,因此大多数游戏引擎都选用的这种方法. Unity Shader的渲染顺序 Unity为解决渲染问题提供了渲染队列(render queue)这一方案.我们可以使用Subshader的Queen标签来决定我们的模型将归于哪个渲染队列. Unity在内部使用了一系列整数索引来表示每个渲染队列,索引号越小就越先被渲染.在Unity5中,Unity提前定义了5个渲染队列. 名称 队列索引号 描述 Background 1000 背景 Geometry 2000 默认渲染队列,大多数物体使用这个队列,不透明物体使用这个队列. AlphaTest 2450 需要透明度测试的物体使用这个队列.在Unity5中它从Geometry队列中被单独分出来,这是因为在所有不透明物体轩然之后再渲染它们更高效. Transparent 3000 这个队列中的物体会在所有Geometry和AlphaTest物体渲染后,再按从后往前的顺序进行渲染.任何使用了透明度混合(例如关闭了深度写入的Shader)的物体都应该使用该队列(???) Overlay 4000 该队列用于实现一些叠加效果.任何需要在最后渲染的物体都应该使用该队列 因此,我们想要通过透明度测试实现透明效果,代码中应该包含类似下面的代码: 123456SubShader &#123; Tags&#123;"Queue" = "AlphaTest"&#125; Pass&#123; // ...... &#125;&#125; 如果我们想通过透明度混合来实现透明效果,代码中应该包含类似下面的代码: 1234567SubShader &#123; Tags&#123;"Queue" = "Transparent"&#125; Pass&#123; ZWrite Off // ...... &#125;&#125; 其中,ZWrite Off用于关闭深度写入.我们可以把它写在Pass或SubShader中. 透明度测试 目测用的不多,先不看 透明度混合 会使用当前片元的透明度作为混合因子,与已经存储在颜色缓冲中的颜色进行混合,得到新的颜色. 为了进行混合,我们需要使用Unity提供的混合命令–Blend. Blend是Unity提供的设置混合模式的命令.想要实现半透明效果就要把当前自身的颜色和已经存在于颜色缓冲中的颜色进行混合,混合时使用的函数就是由该指令决定的. 语义 描述 Blend Off 关闭混合 Blend SrcFactor DstFactor 开启混合,并设置混合因子.片元颜色会乘以SrcFactor,而已存在于颜色缓冲区的颜色会乘以DstFactor,然后把两者相加存入缓存. Blend SrcFactor DstFactor, SrcFactorA DstFactorA 和上面几乎一样,只是使用不同因子来混合透明通道 BlendOp BlendOption 并非是把源颜色和目标颜色简单相加后混合,而是使用BlendOption对它们进行其他操作 在本节中我们使用第二种语义来混合,需要注意的是,这个命令在设置混合因子的同时也开启了混合模式. 实践: 透明度混合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'Shader "Custom/8.4"&#123; Properties &#123; _Color ("Color", Color) = (1,1,1,1) _MainTex ("Albedo (RGB)", 2D) = "white" &#123;&#125; // AlphaScale用来控制整体透明度 _AlphaScale("Alpha Scale",Range(0,1)) = 1 &#125; SubShader &#123; // Queue标签指定队列 // RenderType标签设置为Transparent,用来指明该Shader是一个使用了透明度混合的Shader.RenderType标签通常被用于着色器替换功能. // IgnoreProject标签设为True,意味着整个Subshader不受投影器(Projectors)影响. Tags &#123; "Queue"="TransParent" "IgnoreProject"="True" "RenderType"="Transparent" &#125; Pass&#123; // 把LightMode标签设为ForwardBase,是为了让Unity能够按前向渲染路径的方式为我们正确提供各个光照变量. Tags &#123;"LightMode"="ForwardBase"&#125; // 关闭深度写入 ZWrite Off // 设置混合模式 Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float uv : TEXCOORD2; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); // alpha的值 return fixed4(ambient + diffuse,texColor.a * _AlphaScale); &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125; 当模型自身有复杂的遮挡关系或包含了复杂的非凸网格的时候,就会有各种各样因为排序错误而产生的错误的排序效果. 开启深度写入的半透明效果 上面的问题都是由于关闭了深度写入造成的,因为这样我们无法对模型进行像素级别的深度排序. 这是,我们可以想办法重新利用深度写入,让模型可以想半透明物体一样进行淡入淡出(淡入淡出什么鬼???).这就是下面的内容. 对于上面的问题,一种解决方法是使用两个Pass来渲染模型: 一个Pass开启深度写入,但不输出颜色,它的目的仅仅是为了把该模型写入深度缓冲中; 第二个Pass进行正常的透明度混合,由于上一个Pass已经得到了逐像素的正确的深度信息,该Pass就可以按照像素级别的深度排序的结果进行透明渲染. 但这种方法的缺点在于,多使用一个Pass会对性能造成一定的影响. 代码只需要在上面的那份代码中新加一个Pass即可,加在原Pass的上面 1234Pass&#123; ZWrite On ColorMask 0&#125; ColorMask用于设置颜色通道的写掩码(write mask),它的语义如下: ColorMask RGB | A | 0 | 其他任何R, G, B, A的组合 当ColorMask设为0时,意味着该Pass不写入任何颜色通道,即不会输出任何颜色. ShaderLab的混合命令 上面已经用了Blend命令进行混合,实际上混合还有其他很多用处,不仅仅是透明度混合. 混合的原理 当片元着色器产生一个颜色的时候,可以选择与颜色缓存中的颜色进行混合,这样一来,混合就和两个操作数有关:源颜色(source color)和目标颜色(destination color). 源颜色,用S表示,指的是片元着色器产生的颜色值; 目标颜色,用D表示,指的是从颜色缓冲中读取到的颜色值. 对它们进行混合后得到输出颜色,用O表示,它会重新写入到颜色缓存中. 需要注意的是,当我们谈及混合中的源颜色, 目标颜色和输出颜色时,他们都包含了RGBA四个通道,而并非仅仅的RGB通道. 开启混合 在Unity中,当我们使用Blend(Blend Off除外)命令时,除了设置混合状态外也开启的混合. 混合的等式和参数 混合是一个逐片元的操作,而且它是不可编程的,但是是高度可配置的. 我们可以设置混合时使用的运算操作,混合因子等来影响混合. 从源颜色S和目标颜色D得到输出颜色O必须适用一个等式来计算,这个等式叫做混合等式(Blending equation). 当进行混合时,我们需要使用两个混合等式,一个用于混合RGB通道,一个用于混合A通道. 当设置混合状态时,我们实际上设置的是混合等式中的操作和因子 在默认情况下,混合等式使用的操作都是加操作(我们也可以使用其他操作),我们只需要再设置一下混合因子即可. 由于需要两个等式,每个等式有两个因子(一个用于和源颜色相乘,一个用于和目标颜色相乘),因此一共需要4个因子. 下面是ShaderLab中设置混合因子的命令 命令 描述 Blend SrcFactor DstFactor 开启混合,并设置混合因子.源颜色会乘以SrcFactor,而目标颜色会乘以DstFactor,然后将两者相加后存入颜色缓冲中 Blend SrcFactor DstFactor,SrcFactorA DstFactor A 和上面几乎一样,只是使用不同因子来混合透明通道. 第一个命令只提供了两个因子,这意味着使用同样混合因子来混合RGB通道和A通道,即此时SrcFactorA等于SrcFactor, DstFactorA等于DstFactor. 这些混合因子的值可以取以下: 参数 描述 One 因子为1 Zero 因子为0 SrcColor 因子为源颜色值.当用于RGB通道的混合等式时,使用SrcColor的RGB分量作为混合因子;当用于A通道混合等式时,使用SrcColor的A分量作为混合因子. SrcAlpha 因子源颜色的透明度值(A通道) DstColor 因子为目标颜色值.当用于RGB通道的混合等式时,使用DstColor的RGB分量作为混合因子;当用于A通道混合等式时,使用DstColor的A分量作为混合因子. DstAlpha 尹子维目标颜色值的透明度值(A通道) OneMinusSrcColor 1 - SrcColor OneMinusSrcAlpha 1 - SrcAlpha OneMinusDstColor 1 - DstColor OneMinusDstAlpha 1 - DstAlpha 混合操作 可以使用ShaderLab的BlendOp BlendOption命令,来选择不同的混合操作 操作 描述 Add 将混合后的源颜色和目的颜色相加.是默认的混合操作.使用的混合等式是:O(rgb) = SrcFactor * S(rgb) + DstFactor * D(rgb)O(a) = SrcFactor * S(a) + DstFactor * D(a) Sub 用混合后的源颜色减去混合后的目标颜色.使用的混合等式是:O(rgb) = SrcFactor * S(rgb) - DstFactor * D(rgb)O(a) = SrcFactor * S(a) - DstFactor * D(a) RevSub 用混合后的目标颜色减去混合后的源颜色.使用的混合等式是:O(rgb) = DstFactor * D(rgb) - SrcFactor * S(rgb)O(a) = DstFactor * D(a) - SrcFactor * S(a) Min 使用源颜色和目标颜色中的较小值,是逐分量比较的.使用的混合等式是O(rgba) = (min(S®, D®, min(S(g), D(g), min(S(b), D(b), min(S(a), D(a))) Max 使用源颜色和目标颜色中的较大值,是逐分量比较的.使用的混合等式是O(rgba) = (max(S®, D®, max(S(g), D(g), max(S(b), D(b), max(S(a), D(a))) 混合因子命令通常是与混合因子命令一起工作的.但使用Min或Max混合操作时,混合因子实际上是不起任何作用的 常见的混合类型 通过混合操作和混合因子命令的组合,可以得到一些类似PhotoShop混合模式中的混合效果. 操作 效果 Blend SrcAlpha OneMinusSrcAlpha 正常(Normal), 即透明度混合 Blend OneMinusDstColor One 柔和相加(Soft Additive) Blend DstColor Zero 正片叠底(Multiply),即相乘 Blend DstColor SrcColor 两倍相乘(2x Multiply) BlendOp MinBlend One One 变暗(Darking) BlendOp MaxBlend One One 变亮(Lighting) Blend OneMinusDstColor One 滤色(Screen) Blend One OneMinusSrcColor 滤色,等同于上面的 Blend One One 线性减淡(Linear Dodge) 双面渲染的透明效果 现实生活中,如果一个物体是透明的,意味着我们不仅可以透过它看到其它物体的样子,也可以看到它的内部结构. 但在前面实现的透明效果中,我们无法观察到正方体的内部及其背面的形状. 这是因为,默认情况下,渲染引擎剔除了物体背面的渲染图元,而只渲染了物体的正面. 可以使用Cull指令来控制需要剔除哪个面的图元 在Unity中,Cull指令的语法如下: Cull Back | Front | Off 如果设置为Back,则背对摄像机的渲染图元不会被渲染,也就是默认情况下的剔除状态; 如果设为Front,则朝向摄像机的渲染图元不会被渲染; 如果设置为Off,就会关闭剔除功能,所有图元都会被渲染,但由于这时需要渲染的图元数目会成倍增加,因此除非是用于特殊效果(例如这里的透明效果),通常情况下是不会关闭剔除功能的. 实践: 透明度混合的双面渲染 我们想要得到正确的透明效果,渲染顺序是十分重要的,我们要保证图元要从前往后渲染. 对于透明度测试来说,由于我们没有关闭深度写入,所以可以利用深度缓冲按逐像素的细粒度进行深度排序,从而保证渲染的正确性. 然而透明度混合要关闭深度写入…我们就需要小心控制渲染顺序来得到正确的深度关系. 如果我们直接关闭剔除功能,我们就无法保证同一个物体的正面和背面渲染图元的渲染顺序,就有可能得到错误的半透明效果. 为此,我们选择把双面渲染的工作分为两个Pass: 第一个Pass只渲染背面,第二个Pass只渲染正面,由于Unity会顺序执行SubShader中的各个Pass,因此我们可以保证背面总是在正面之前被渲染. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125Shader "Custom/8.4"&#123; Properties &#123; _Color ("Color", Color) = (1,1,1,1) _MainTex ("Albedo (RGB)", 2D) = "white" &#123;&#125; _AlphaScale("Alpha Scale",Range(0,1)) = 1 &#125; SubShader &#123; Tags &#123; "Queue"="TransParent" "IgnoreProject"="True" "RenderType"="Transparent" &#125; Pass&#123; Tags &#123;"LightMode"="ForwardBase"&#125; // 剔除前面 Cull Front // 全是原Pass ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float uv : TEXCOORD2; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); return fixed4(ambient + diffuse,texColor.a * _AlphaScale); &#125; ENDCG &#125; Pass&#123; Tags &#123;"LightMode"="ForwardBase"&#125; // 剔除后面 Cull Back // 原Pass ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float uv : TEXCOORD2; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); return fixed4(ambient + diffuse,texColor.a * _AlphaScale); &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125;]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第7章-基础纹理]]></title>
    <url>%2Fshader-r-standard-texture%2F</url>
    <content type="text"><![CDATA[纹理的最初目的是使用一张图片来控制模型的外观.使用纹理映射(texture mapping)技术,我们可以把一张图片&quot;黏&quot;在模型表面,逐纹素(texel)地控制模型的颜色 在美工人员建模的时候,通常会在建模软件中利用纹理展开技术把纹理映射坐标(texture-mapping coordinates)存储在每个顶点上. 单张纹理 实践 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788Shader "Custom/7.1"&#123; Properties &#123; _Color ("Color Tint", Color) = (1, 1, 1, 1) // 声明一个2D纹理 _MainTex ("Main Tex", 2D) = "white" &#123;&#125; _Specular ("Specular", Color) = (1, 1, 1, 1) _Gloss ("Gloss", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; "LightMode"="ForwardBase" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; // _MainTex的名字不是随意起的,在Unity中我们使用纹理名_ST来声明某个纹理的属性. // 其中ST是缩放(scale)和平移(translation)的缩写. // 可以在材质面板的纹理属性调整这些值控制材质的平移和缩放. float4 _MainTex_ST; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; // 会把第一组纹理存储到该变量中 float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; // 使用纹理缩放和偏移属性对顶点纹理坐标进行变换 o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; // 或使用unity的内置函数 // o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); // 用tex2D对纹理进行采样 // 第一个参数是需要被采样的纹理,第二个参数是float2类型的纹理坐标 // 返回计算得到的纹素值 fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack "Specular"&#125; 纹理的属性 Texture Type 书上讲的TextureType好像过时了,现在是这样的: 这里使用最普通的texture,在后面的法线纹理一节,我们会使用Normal map类型,在后面的章节中,我们还会看到Cubemap等高级纹理类型. 我们之所以要为纹理选择合适的类型,是因为只有这样才会让Unity知道我们的意图,为Unity Shader传递正确的纹理,并在一些情况下让Unity对该纹理进行优化 Alpha Source 如果选择了From Gray Scale,那么透明通道的值将会由每个像素的灰度值生成. 关于透明效果会在第8章讲到 Wrap Mode 当纹理坐标超过[0, 1]返回后将会如何被平铺. Repeat下,纹理将会重复. Clamp下将会对纹理进行截取. Filter Mode 决定了当纹理由于变换而产生拉伸时将会采用哪种滤波模式. Filter Mode支持三种模式: Point, Bilinear, Trilinear.它们得到的图片滤波效果会依次提升,但需要消耗的性能也依次增大 纹理滤波会影响放大或缩小纹理时得到的图片的质量. 纹理的缩小过程比放大更复杂一些.缩小时,原纹理中的多个像素将会对应一个目标像素.纹理缩小更加复杂的原因在于我们往往需要处理抗锯齿问题,一个最常使用的方法就是使用多级渐远纹理(mipmapping)技术. 多级渐远纹理技术将原纹理提前用滤波处理来得到很多更小的图像,形成一个图像金字塔,每一层都是对上一层图像降采样的结果.这样在实时运行时,就可以快速得到结果像素. 例如当摄像机较远的时候,可以直接使用较小的纹理. 缺点是需要使用一定空间用于存储这些多级渐远纹理,通常会多占33%的内存空间. 在Unity中,我们可以在纹理导入面板中,首先将texture type选择成advanced,再勾选Generate Mip Maps即可开启多级渐远纹理技术. 这张图是,从一个倾斜角度观察一个网格结构的地板时,使用不同的Filter Mode(同时也使用了多级渐远纹理技术)得到的效果. 在内部实现上,Point模式使用了最邻近(nearest neighbor)滤波.在放大或缩小时,它的采样像素数目通常只有一个,因此图像看起来可能会有像素风格的效果. 而Bilinear滤波则使用了线性滤波,对于每个像素,它会找到四个临近像素,然后对它们进行线性插值混合后得到最终像素,因此图像看起来模糊了. 而Trilinear滤波几乎是和Bilinear一样的,只是Trilinear还会在多级渐远纹理之间进行了混合.如果一张纹理没有使用多级渐远纹理技术,那么Trilinear得到的结果就和Bilinear的完全一样了. 通常,我们选择Bilinear滤波格式.需要注意的是,有时我们不希望纹理看起来是模糊的,例如一些类似棋盘的纹理,我们希望它是像素风的,这时我们可能会选用Point模式. 纹理的最大尺寸和纹理模式 当我们在不同平台发布游戏时,需要考虑目标平台的纹理尺寸和质量问题.Unity允许我们为不同目标平台选择不同的分辨率. 如果导入的纹理大小超过了Max Texture Size的设置值,那么Unity将会把该纹理缩放为这个最大分辨率. 理想情况下,导入的纹理可以是非正方形的,单长宽应该是2的幂.如果使用了非2的幂的大小的纹理,那么这些纹理往往会占用更多的内存空间,而且CPU读取该纹理的速度也会下降.有一些平台甚至不支持这种NPOT纹理,这时Unity在内部会把它缩放成最近的2的幂大小. 而Format则决定了Unity内部使用哪种格式来存储该纹理.如果我们将Texture Type设置为Advanced,那么会有更多的Format供我们选择. 凹凸映射 凹凸映射的目的是使用一张纹理来修改模型表面的法线,以便模型提供更多的细节. 这种方法不会真的改变顶点位置,只是是模型看起来凹凸不平 高度纹理 使用一张高度图来实现凹凸映射 高度图中存储的是强度值(intensity),它用于表示模型表面局部的海拔高度. 颜色越浅表明该位置的表面越向外凸起,越深表明该位置的表面越向里凹. 这种方法的优点是比较直观.我们可以从高度图明确的知道一个模型表面的凹凸情况. 缺点是计算更加复杂,在实时计算中不能直接得到表面法线,而是由像素的灰度值计算而得.因此需要消耗更多的性能. 法线纹理 法线纹理中存储的是表面的法线方向.由于法线方向的分量范围在[-1, 1],而像素的分量在[0, 1],因此我们需要做一个映射,通常使用的映射是: pixel = (normal + 1)/2 这要求我们在Shader中对法线纹理进行纹理采样后,还需要对结果进行一次反映射的过程,以得到原先的法线方向.反映射的过程实际就是使用上面映射函数的逆函数: normal = pixwl * 2 - 1 由于方向是相对于坐标空间来说的,那么法线纹理存在哪个坐标空间中呢? 模型空间的法线纹理和切线空间的法线纹理 模型空间的法线纹理 object-space normal map 将修改后的模型空间的表面法线存储在一张纹理中. 切线空间的法线纹理 tangent-space normal space 对于模型的每个顶点,他都有一个属于自己的切线空间. 这个切线空间的原点就是顶点本身,而z轴就是顶点的法线方向,x轴是顶点的切线方向,而y轴可由法线和切线的叉积而得,也被称为副切线(bitangent). 映射到纹理上的区别 从图可以看出,模型空间下的法线纹理看起来是五颜六色的,而是因为所有法线所在的坐标空间是同一个坐标空间,即模型空间,而每个点存储的法线方向是各异的. 有的是(0, 1, 0),映射后存储到纹理中就对应了RGB(0.5, 1, 0.5),浅绿色;有的是(0, -1, 0),映射后存储到纹理中对应了RGB(0.5,0,0.5)的紫色. 而切线空间下的法线纹理几乎全部都是浅蓝色.这是因为,每个发现方向所在的坐标空间是不一样的,即表面每点各自的切线空间. 这种法线纹理其实是存储了每个点在各自的切线空间中的法线扰动方向. 也就是说,如果一个点的法线方向不变,那么它在它的切线空间中,新法线方向就是z轴方向,即(0,0,1),经过映射后存储在纹理中就对应了RGB(0.5, 0.5, 1)的浅蓝色. 如何选择 实际上,法线本身存储在哪个空间都是可以的,但问题是,我们的目的是计算光照而非单纯的计算法线. 而选择哪个空间,意味着我们需要把不同的信息转换到相应的坐标系中. 例如,如果选择了切线空间,我们需要把从法线纹理中得到的法线方向从切线空间转换到世界空间或其他空间中. 总体来说,用模型空间来存储法线的优点如下: 实现简单,更佳直观 我们甚至不需要模型原始的法线和切线等信息,也就是说,计算更少.生成它也很简单.而如果要生成切线空间下的法线纹理,由于模型的切线一般是和UV方向相同,因此想要得到效果比较好的法线映射就要求纹理映射也是连续的 边界平滑 在纹理坐标的缝合处和尖锐的边角部分,可见的突变(缝隙)较少.这是因为模型空间下的法线纹理存储的是统一坐标系下的法线信息.因此在边界上通过插值得到的法线可以平滑变换.而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的,可能会在边缘处或尖锐部分造成更多的可见缝合现象 但使用切线空间有更多优点: 自由度很高. 模型空间下的法线纹理记录的是绝对的法线信息,仅可用于创建它时的那个模型,而应用到其他模型上效果就完全错误了.而切线空间下的法线纹理记录的是相对法线信息,即便把该纹理应用到一个完全不同的网格上,也可以得到一个合理的效果. 可进行UV动画. 比如我们可以移动一个纹理的UV坐标来实现一个凹凸移动的效果,但使用模型空间下的法线纹理会得到完全错误的结果.这种UV动画经常在水或者火山熔岩这种类型的物体上会经常用到. 可压缩 由于切线空间下的法线纹理中法线z方向总是正方向,因此我们可以仅存储XY方向,而推导出Z方向.而模型空间下的法线纹理由于每个方向都是可能的,因此必须存储3个方向的值不可压缩. 实践 实践 : 在切线空间下计算光照模型 在片元着色器中通过纹理采样得到切线空间下的法线,然后再与切线空间下的视角,光照方向进行计算,得到最终的光照效果. 为此,我们需要在顶点着色器中把视角方向和光照方向从模型空间变换到切线空间中.即我们需要知道模型空间到切线空间的变换矩阵.这个矩阵的逆矩阵,即从切线空间变换到模型空间的变换矩阵,是很容易求得的: 我们在顶点着色器中按切线(x轴),副切线(y轴),法线(z轴)的顺序按列排列即可得到(数学原理见4.6.2节).在4.6.2节我们已经知道,如果一个变换仅存在旋转和平移变换,那么这个矩阵的转置矩阵就等于它的逆矩阵,而从切线空间到模型空间的变换正是符合这样的要求的变换.因此,我们把切线(x轴),副切线(y轴),法线(z轴)的顺序按行排列(因为转置了),即可得到模型空间到切线空间的变换矩阵. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Shader "Custom/7.1"&#123; Properties &#123; _Color ("Color Tint", Color) = (1, 1, 1, 1) _MainTex ("Main Tex", 2D) = "white" &#123;&#125; // 法线纹理的属性 // "bump"是Unity内置的法线纹理. // Bump Scale用于控制凹凸程度,当它为0时,意味着法线纹理不对光照产生任何影响 _BumpMap ("Normal Map", 2D) = "bump"&#123;&#125; _BumpScale ("Bump Scale", Float) = 1.0 _Specular ("Specular", Color) = (1, 1, 1, 1) _Gloss ("Gloss", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; // 切线方向赋给tangent float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); // uv的xy分量存储_MainTex的纹理坐标 // zw分量存储_BumpMap的纹理坐标 // 在回忆一下,_Name_ST的xy代表的是缩放值,zw代表偏移值 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; // 实际上,_MainTex和_BumpMap使用同一组纹理坐标就行了,可以减少差值寄存器的使用数目. // o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.xy = o.uv.zw; // 计算副切线.后面乘以v.tangent.w是决定副切线的方向 float3 binormal = cross(normalize(v.normal),normalize(v.tangent.xyz)) * v.tangent.w; // 把切线(x轴),副切线(y轴),法线(z轴)的顺序按行排列来得到模型空间到切线空间的变换矩阵rotation float3x3 rotation = float3x3(v.tangent.xyz,binormal,v.normal); // 把光照和视角方向变换到切线空间中 o.lightDir = mul(rotation,ObjSpaceLightDir(v.vertex)).xyz; o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex)).xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target&#123; fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); // 利用tex2D对_BumpMap进行采样 // 法线纹理中存储的是法线经过映射后得到的像素值,因此我们要把它们反映射回来 fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw); fixed3 tangentNormal; tangentNormal = UnpackNormal(packedNormal); // 乘以凹凸度来得到xy分量. tangentNormal.xy *= _BumpScale; // 由xy向量计算z向量 tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy,tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack "Specular"&#125; 实践 : 在世界空间下计算光照模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596Shader "Unity Shaders Book/Chapter 7/Normal Map In World Space" &#123; Properties &#123; _Color ("Color Tint", Color) = (1, 1, 1, 1) _MainTex ("Main Tex", 2D) = "white" &#123;&#125; _BumpMap ("Normal Map", 2D) = "bump" &#123;&#125; _BumpScale ("Bump Scale", Float) = 1.0 _Specular ("Specular", Color) = (1, 1, 1, 1) _Gloss ("Gloss", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; "LightMode"="ForwardBase" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float4 TtoW0 : TEXCOORD1; float4 TtoW1 : TEXCOORD2; float4 TtoW2 : TEXCOORD3; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; fixed3 worldNormal = UnityObjectToWorldNormal(v.normal); fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; // Compute the matrix that transform directions from tangent space to world space // Put the world position in w component for optimization o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; // Get the position in world space float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); // Compute the light and view dir in world space fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos)); fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos)); // Get the normal in tangent space fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); bump.xy *= _BumpScale; bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy))); // Transform the narmal from tangent space to world space bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir)); fixed3 halfDir = normalize(lightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(bump, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack "Specular"&#125; :TODO 好焦躁啊,这些先留着不看… 渐变纹理]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第6章-Unity中的基础光照]]></title>
    <url>%2Fshader-r-standard-lighting%2F</url>
    <content type="text"><![CDATA[光照基础 我们要模拟真实的光照环境来生成一张图像,需要考虑三种物理现象: 首先,光线从光源中被发射出来 然后,光线和场景中的一些物体相交: 一些光线被物体吸收了,而另一些光线被散射到其他方向 最后,摄像机吸收了一些光,产生了一张图像 光源 在光学里,我们用辐照度(irradiance)来量化光. 对于平行光来说,它的辐照度可通过计算在垂直于l的单位面积上单位时间内穿过的量来得到. 吸收和散射 光线由光源发射出来后,就会与一些物体相交,通常,相交的结果有两个:散射(scattering)和吸收(absorption) 散射只改变光线的方向,但不改变光的密度和颜色.而吸收只改变光线的密度和颜色,而不改变光线的方向. 光线在物体表面经过散射后,有两种方向: 一种将会散射到物体内部,这种现象被称为折射(refraction)或透射(transmission); 另一种将会散射到外部,这种现象被称为反射(reflection). 对于不透明物体,折射进入物体内部的光线还会继续与内部颗粒进行相交,其中一部分光线最后会重新发射出物体表面.而另一些则会被物体吸收.那些从物体表面重新发射出的光线将具有和入射光线不同的分布和颜色. 为了区分这两种不同的散射方向,我们在光照模型中使用了不同的部分来计算它们: 高光反射(specular)部分表示物体表面是如何反射光线的 漫反射(diffuse)部分则表示有多少光线会被折射,吸收和散射出表面. 根据入射光线的数量和方向,我们可以计算出射光线的数量和方向,我们常用出射度(exitance)来描述它. 辐照度和出射度之间只满足先行关系的,而他们之间的比值就是材质的漫反射和高光反射属性 着色 着色(shading)是指,根据材质属性(如漫反射属性等),光源信息(如光源方向,辐照度等),使用一个等式去计算沿某个观察方向的出射度的过程.我们也把这个等式称为光照模型(Lighting Model). 不同光照模型有不同的目的.例如一些用于描述粗糙的物体表面,一些用于描述金属表面等. BRDF光照模型 我们已经了解了光线在和物体表面相交时会发生那些现象. 当已知光源位置和方向,视角方向时,我们就需要知道一个表面是如何和光照进行交互的. 而BRDF(Bidirectional Reflection Distribution Function)就是用来回答这些问题的. 当给定模型的一个点时,BRDF包含了对该点外观的完整的描述.在图形学中,BRDF大多使用同一个数学公式来表示,并且提供了一些参数来调整材质属性. 通俗来讲,当给定入射光线和辐照度后,BRDF可以给出在某个方向上的光照能量分布. 本章设计BRDF都是对真实场景进行理想化和简化后的模型.它们并不能真实地反映物体和光照之间的交互,这些光照模型被称为是经验模型. 标准光照模型 标准光照模型只关心直接光照(direct light),也就是那些从光源发射出来照射到物体表面后,经过物体表面的一次反射直接进入摄像机光线. 它的基本方法是,把进入摄像机内的光线分为4部分,每个部分使用一种方法来计算它的贡献度. 自发光(emissive) 这个部分用于描述当给定一个方向时,一个表面本身会向该方向发射多少辐射量.如果没有全局光照(global illuminiation)技术,这些自发光的表面并不会真的照亮物体,只是它本身看起来更亮了而已. 高光反射(specular) 这个部分用于描述当光线从光源照射到模型表面时,该表面会在完全镜面反射方向散射出多少辐射量. 漫反射(diffuse) 这个部分用于描述,当光线从光源照射到物体表面时,该表面会向每个方向散射多少辐射量. 环境光(ambient) 用于描述其他所有间接光照 环境光 虽然标准光照模型的重点在于直接光照,但在真实世界中,物体也可以被间接光照(indirect light)所照亮. 间接光照是指,光线通常会在多个物体之间反射,最后进入摄像机. 在标准光照模型中,我们使用环境光来近似模拟间接光照. 环境光的计算非常简单,它通常是一个全局变量,场景中的所有物体都使用这个环境光 自发光 光线可以直接由光源发射进入摄像机,而不需要经过其他物体的反射.标准光照模型使用自发光来计算这个部分的贡献度. 它的计算也很简单,就是直接使用了材质的自发光颜色. 通常在实时渲染中,自发光的表面往往并不会照亮周围的表面,也就是说,这个物体并不会被当做是一个光源. Unity 5引入的全局光照则可以模拟这类自发光物体对周围物体的影响(详见18章) 漫反射 漫反射光照是用于对那些被物体表面完全随机散射到各个方向的辐射度进行建模的. 在漫反射中,视角的位置是不重要的,因为反射是完全随机的,因此可以认为在任何反射方向上的分布都是一样的. 但是入射光线的角度很重要. 漫反射光照符合兰伯特定律(Lambert’s law): 反射光线的强度与表面法线和光源方向之间的夹角的余弦值成正比 高光反射 这里的高光反射是一种经验模型,也就是说,它并不完全符合真实世界中的高光反射现象.他可以用于计算那些沿着完全镜面反射方向被反射的光线,这可以让物体看上去是有光泽的,例如金属材质 计算高光反射需要知道的信息比较多,如表面法线,视角方向,光源方向,反射方向等. 高光反射的数学表达式太多了,还是看书吧,书上p124 逐像素还是逐顶点 在片元着色器中计算光照模型,被称作逐像素光照(per-pixel lighting) 在顶点着色器中计算光照模型,被称作逐顶点光照(per-vertex lighting) 逐像素光照 在逐像素光照中,我们会以每个像素为基础,得到它的法线(可以通过对顶点法线的插值得到,也可以从法线纹理中采样得到),然后进行光照模拟的计算. 这种在面片之间对顶点法线进行插值的技术被称为Phone 着色(Phone Shader),也被称为Phone插值或法线插值着色技术,这不同于之前的Phone模型. 逐顶点光照 也被称为高洛德着色(Gouraud Shading). 在逐顶点光照中,我们在每个顶点上计算光照,然后在渲染图元内部进行线性插值,最后输出成颜色. 因为顶点数目往往远小于像素数目,因此逐顶点光照的计算量往往要小于逐像素光照. 但是,由于逐顶点光照依赖于线性插值来得到像素光照,因此,当光照模型中有非线性计算(入计算高光反射)时,逐顶点光照就会出问题. 而且,由于逐顶点光照会在渲染图元内部对顶点颜色进行插值,这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值.这在某些情况下会产生明显的棱角, 总结 标准光照模型并不完全符合真实世界中的光照现象,但由于它的易用性,计算速度和得到的效果都比较好,因此仍在被广泛使用. 标准光照模型也被称为Phone光照模型或Blinn-Phong光照模型. 但这种模型也有很多局限性. 首先,很多重要的物理现象无法用该光照模型表现出来,例如菲涅尔反射(Fresenel reflection). 其次,该模型是各项同性(isotropic)的,也就是说,当我们固定视角和光源方向,旋转这个表面时,反射不会发生任何改变.但有些表面是各向异性(anisotropic)的,如拉丝金属,毛发等. Unity中的环境光和自发光 在Shader中,我们只需通过UNITY_LIGHTMODEL_AMBIENT就可以得到环境光的颜色和强度信息. 计算自发光只需要在片元着色器输出最后的颜色之前,把材质的自发光颜色添加到输出颜色上即可. 漫反射光照模型 实践: 逐顶点漫反射光照 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse",Color) = (1, 1, 1, 1) &#125; Subshader&#123; Pass&#123; // 使用Tags指明该Pass的光照模式 // 只有定义了正确的LightMode,我们才能得到一些Unity的内置光照变量,如后面的_LightColor0 Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag // 需要使用UNity中的内置光照变量,如后面的_lightColor0,还需包含Unity的内置文件Lighting.cginc #include "Lighting.cginc" fixed4 _Diffuse; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : POSITION; float3 color : COLOR; &#125;; v2f vert(a2v v)&#123; v2f o; // 将顶点坐标从模型空间变换到剪裁空间中 o.pos = UnityObjectToClipPos(v.vertex); // 通过UNITY_LIGHTMODEL_AMBIENT获得环境光部分 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; // 将法线变换至世界坐标空间下,并进行归一化 fixed3 worldNormal = normalize(mul(v.normal,(float3x3)unity_WorldToObject)); // 光源方向由_WorldSpaceLightPos0得到,并进行归一化 float3 worldLight = normalize(_WorldSpaceLightPos0.xyz); // 通过_LightColor0访问光源的颜色和强度信息 // saturate是Cg提供的一种函数,它的作用是把参数截取到[0, 1]的范围内. // 将 法线 与 光源方向 的 点积 与 光源的颜色 和 强度 以及 材质的漫反射颜色 相乘 得到 最终的漫反射光照部分 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight)); // 将环境光与漫反射光部分相加,得到最终的光照结果 o.color = ambient + diffuse; return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125; 顶点着色器部分解释: 在第一行,我们首先定义了返回值o.我们已经重复过很多次,顶点着色器最基本的任务就是把顶点位置从模型空间转换到剪裁空间中. 书上比较过时的方法是 使用Unity内置的 模型世界投影矩阵 UNITY_MATRIX_MVP 来完成这样的坐标变换.实际打代码的时候,编辑器顶部出现了一行 1// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' ,然后对应部分的代码也被改了. 接下来是真正计算漫反射光照的部分.回忆一下,为了计算漫反射我们需要知道4个参数. 在前面的步骤中,我们已经知道了材质的漫反射颜色_Diffuse以及顶点法线v.normal.还需要知道光源的颜色和强度信息以及光源方向. 通过Unity提供的内置变量 _LightColor0 来访问该Pass处理光源的颜色和强度信息 通过Unity提供的内置变量 _WorldSpaceLightPos0 得到光源方向 需要注意的是,这里对光源方向的计算不具有通用性.当前场景下,我们假设只有一个光源且其类型是平行光. 如果场景下有多个光源并且类型是点光源等其他类型,直接使用_WorldSpaceLightPos0就不能得到正确的结果. 计算光源方向与法线的点积时,只有两者处于统一坐标空间下,他们的点积才有意义. 于是在这里我们选用世界空间. 在得到世界空间下的法线和光源方向后,我们需要对它们进行归一化操作; 在得到它们的点积的结果后,我们需要防止这个结果为负值.为此,我们选用saturate函数. saturate函数是Cg提供的一种函数,它的作用是可以把参数截取到[0, 1]范围内. 再将 法线 与 光源方向 的 点积 与 光源的颜色 和 强度 以及 材质的漫反射颜色 相乘 得到 最终的漫反射光照部分 最后,将环境光与漫反射光部分相加,得到最终的光照结果 思考:法线 与 光源方向 的 点积 与 光源的颜色 和 强度 以及 材质的漫反射颜色 相乘 的意义 我的理解: 法线 与 光源方向 的 点积 的结果,应该就是光源方向在法线方向上的投影值. 这个投影值的意义是漫反射的强度.顶点法线正对入射光线,漫反射效果最强.顶点法线与入射光线的夹角大于90度,则完全没有漫反射效果.之后再以强度与光源颜色和材质颜色相乘,得到漫反射颜色. 对于细分度较高的模型,逐顶点光照已经可以得到比较好的光照效果了.但对于一些细分程度较低的模型,逐顶点光照就会出现一些视觉问题. 例如这里就有点锯齿 实践: 逐像素漫反射光照 相较于上个人逐顶点光照,把对光照的计算从vert函数转到了frag函数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse",Color) = (1, 1, 1, 1) &#125; Subshader&#123; Pass&#123; Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Diffuse; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; &#125;; v2f vert(a2v v)&#123; // vert函数中仅传递光照方向及法线方向 v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = mul(v.normal,(float3x3)unity_WorldToObject); return o; &#125; fixed4 frag(v2f i) : SV_TARGET&#123; // 计算在frag函数中进行 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); fixed3 color = ambient + diffuse; return fixed4(color, 1); &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125; 逐像素光照更佳平滑 但是,即使用了逐像素漫反射光照,有一个问题仍然存在:在光照无法到达的区域,模型外观通常是黑的,没有任何明暗变化,这会使模型的背光区域看起来就像一个平面一样,失去模型细节表现. 实际上我们可以通过添加环境光来得到非全黑的效果,但即便这样也无法解决背光面明暗一样的缺点.为此,有一种改善技术被提出来,这就是半兰伯特(Half Lambert)光照模型 半兰伯特光照模型 在上面的光照实例中使用的光照模型也被称为兰伯特光照模型,因为它符合兰伯特定于----在平面某点漫反射光强与该反射点的法向量和入射角的余弦值成正比. 半兰伯特光照模型是在原兰伯特光照模型上修改的. 与原兰伯特模型相比,版兰伯特光照模型没有使用saturate函数截取法向量和光照方向的点积,而是使点积结果乘以一个值再加上一个值.通常情况下.这两个值都为0.5,通过这种方式就能把法向量和光照方向的点积的结果范围从[-1, 1]映射到[0, 1]范围内. 对于模型的背光面,原兰伯特模型中点积结果将映射到同一个值,即0处;而半兰伯特模型中,背光面也会有明暗变化. 需要注意的是,半兰伯特光照模型是没有任何物理依据的,仅仅是一个视觉加强. 球的背光面在两种光照模型下的表现: 原兰伯特光照模型 半兰伯特光照模型 高光反射光照模型 基本光照模型中高光反射部分的计算公式: 计算高光反射需要四个参数:入射光线的颜色和强度,材质的高光反射系数,视角方向以及反射方向.其中,反射方向可以由表面法线和光源方向计算而得. 上述计算很简单,更幸运的是,Cg提供了计算反射方向的函数:reflect. 函数: reflect(i,n) 参数: i: 入射方向;n:法线.可以是float,float2,float3等. 实践: 逐顶点高光反射光照 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse", Color) = (1, 1, 1, 1) // 材质的高光反射颜色 _Specular("Specular", Color) = (1, 1, 1, 1) // 高光区域的大小 _Gloss("Gloss",range(8.0,256)) = 20 &#125; Subshader&#123; Pass&#123; Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; fixed3 color : COLOR; &#125;; v2f vert(a2v v)&#123; v2f o; // 漫反射部分 o.pos = UnityObjectToClipPos(v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject)); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); // 入射光线关于法线的反射方向. // 由于Cg的reflect函数的入射方向要求是由光源指向交点处的,因此我们要把worldLightDir取反后再传给reflect函数 fixed3 reflectDir = normalize(reflect(-worldLightDir,worldNormal)); // 世界空间下的 摄像机坐标与顶点坐标相减,得到视角方向 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld,v.vertex).xyz); // 根据公式和所有的四个参数,带入公式得到高光反射的光照部分. fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir,viewDir)),_Gloss); o.color = ambient + diffuse + specular; return o; &#125;; fixed4 frag(v2f i) : SV_TARGET&#123; return fixed4(i.color,1.0); &#125;; ENDCG &#125; &#125; // fallback调成Specular FallBack "Specular"&#125; 使用逐顶点的方法得到的高光效果,高光部分及其不平滑:因为高光部分的计算是非线性的,而在顶点着色器中在进行插值的过程是线性的,破坏了原计算的非线性关系. 实践: 逐片元高光反射光照 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse", Color) = (1, 1, 1, 1) // 材质的高光反射颜色 _Specular("Specular", Color) = (1, 1, 1, 1) // 高光区域的大小 _Gloss("Gloss",range(8.0,256)) = 20 &#125; Subshader&#123; Pass&#123; Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz; return o; &#125;; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir,worldNormal)); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir,viewDir)),_Gloss); return fixed4((ambient + diffuse + specular),1.0); &#125;; ENDCG &#125; &#125; // fallback调成Specular FallBack "Specular"&#125; 将计算转移到了frag函数中. Blinn-Phong光照模型 上面是Phong光照模型的实现. 而Blinn模型没有使用反射方向,而是引入了一个新的矢量 而Blinn模型计算高光反射的公式是 理解:理解个尖儿,貌似也是个没有物理根据的经验模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Shader "Custom/6.4"&#123; Properties &#123; _Diffuse("Diffuse", Color) = (1, 1, 1, 1) _Specular("Specular", Color) = (1, 1, 1, 1) _Gloss("Gloss",range(8.0,256)) = 20 &#125; Subshader&#123; Pass&#123; Tags&#123;"LightMode" = "ForwardBase"&#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "Lighting.cginc" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v&#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; &#125;; v2f vert(a2v v)&#123; v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz; return o; &#125;; fixed4 frag(v2f i) : SV_TARGET&#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); // 新增 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); // 新增 fixed3 halfDir = normalize(worldLightDir + viewDir); // 公式 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal,halfDir)),_Gloss); return fixed4((ambient + diffuse + specular),1.0); &#125;; ENDCG &#125; &#125; FallBack "Specular"&#125; 效果: 谔谔,总感觉区别不大…高光范围比上面大了点…]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第5章-开始Unity Shader学习之旅]]></title>
    <url>%2Fshader-r-start%2F</url>
    <content type="text"><![CDATA[最简单的顶点/片元着色器 顶点/片元着色器的基本结构 12345678910111213141516171819202122232425262728293031323334Shader "MyShaderName"&#123; Properties&#123; // 属性 &#125; SubShader&#123; // 针对显卡A的SubShader Pass&#123; // 设置渲染状态和标签 // 开始Cg代码片段 CGPROGRAM // 该代码片段的编译指令 #pragma vertex vert #pragma fragment frag // Cg代码写在这里 // 结束Cg代码段 ENDCG // 其他设置 &#125; // 其他需要的Pass &#125; SubShader&#123; // 针对显卡B的SubShader &#125; // 上面的SubShader都失败后用于回调的Unity Shader Fallback "VertexLit"&#125; 其中最重要的是Pass语义块.我们绝大多数的代码都是写在Pass语义块中的. 下面是一个实际的最简单的顶点/片段着色器 12345678910111213141516171819202122Shader "Custom/myShader"&#123; SubShader&#123; Pass&#123; CGPROGRAM // 告诉unity,vert函数包含了顶点着色器代码,frag函数包含了片段着色器代码. #pragma vertex vert #pragma fragment frag float4 vert(float4 v : POSITION) : SV_POSITION &#123; return mul(UNITY_MATRIX_MVP, v); // MVP矩阵是: 当前的模型矩阵·观察矩阵·投影矩阵,用于将顶点/方向矢量从模型空间变换到剪裁空间 &#125; fixed4 frag() : SV_Target&#123; return fixed4(1.0, 1.0, 1.0, 1.0); &#125; ENDCG &#125; &#125;&#125; vert函数里的POSITION和SV_POSITION都是Cg/HLSL中的语义(semantics),是不可省略的,它们告诉系统用户需要哪些输入值,以及用户的输出是什么.例如这里: POSITION告诉Unity,把模型顶点坐标填充到参数v SV_POSITION告诉Unity,顶点着色器的输出是剪裁空间中的顶点坐标 如果没有这些语义来限定输入和输出参数的话,渲染器就完全不知道用户的输入和输出是什么,因此会得到错误的结果. 本例中的frag函数没有任何输入,它的输出是一个fixed4类型的变量,并且使用了SV_Target语音进行限定. SV_Targrt也是HLSL中的一个系统语义,它等同于告诉渲染器,把用户的输出颜色存储到一个渲染目标(render target)中,这里将输出到默认的帧缓存中. 模型数据从哪来 如想要得到更多的模型数据(如顶点的纹理坐标和法线方向),我们需要为顶点着色器定义一个结构体作为输入参数. 1234567891011121314151617181920212223242526272829303132333435Shader "Custom/MyShader"&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag // 使用一个结构体来定义顶点着色器的输入 struct a2v&#123; // POSITION语义告诉Unity, 用模型空间的顶点坐标填充vertex变量 float4 vertex : POSITION; // NORMAL语义告诉Unity, 用模型空间的法线方向填充normal变量 float3 normal : NORMAL; // TEXCOORD0语义告诉Unity, 用模型的第一套纹理坐标填充texcoord变量 float4 texcoord : TEXCOORD0; &#125;; float4 vert(a2v v) : SV_POSITION&#123; // 使用v.vertex来访问模型空间的顶点坐标 return mul(UNITY_MATRIX_MVP, v.vertex); &#125; fixed4 frag() : SV_Target&#123; return fixed4(1.0, 1.0, 1.0, 1.0); &#125; ENDCG &#125; &#125;&#125; 在上面的代码中,我们声明了一个新的结构体a2v,它包含了顶点着色器需要的模型数据. 对于顶点着色器的输入,Unity支持的语义有: POSITION, TANGENT, NORMAL, TEXCOORD0, TEXCOORD1, TEXCOORD2, TEXCOORD3, COLOR 等. 为了新建一个结构体, 我们必须使用如下格式来定义它: 12345struct StructName&#123; Type Name : Semantic; Type Name : Semantic; ......&#125; 然后,我们又修改了vert函数的输入类型为a2v. a表示应用(application),v表示顶点着色器(vertex shader),a2v的意思就是把数据从应用阶段传递到顶点着色器中. 顶点着色器和片元着色器的通信 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Shader "Custom/Myshader"&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; // 使用一个结构体来定义顶点着色器的输出 struct v2f &#123; // SV_POSITION语义告诉Unity, pos里包含了顶点在剪裁空间中的位置信息 float4 pos : SV_POSITION; // COLOR0语义可以用于存储颜色信息 fixed3 color : COLOR0; &#125; v2f vert(a2v v)&#123; // 声明输出的结构 v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); // v.normal包含了顶点的法线方向, 其分量在[-1.0, 1.0] // 下面的代码将分量范围映射到了[0.0, 1.0] // 存储到o.color中传递给片元着色器 o.color = v.normal * 0.5 + float3(0.5, 0.5, 0.5); return o; &#125; fixed4 frag(v2f i) : SV_Target&#123; // 将插值后的i.color显示到屏幕上 return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125;&#125; 在上面代码中,我们定义了一个v2f结构体在顶点着色器和片元着色器之间传递信息. 顶点着色器的输出结构中,必须包含一个语义为SV_POSITION的变量,否则渲染器会无法得到剪裁空间中的顶点坐标,也就无法将颜色渲染到屏幕上. 至此,我们完成了顶点着色器和片元着色器之间的通信. 需要注意的是,顶点着色器是逐顶点调用的,而片元着色器是逐片元调用的,所以片元着色器的输入实际上是把顶点着色器的输出进行插值得到的结果. 如何使用属性 通过材质,我们可以方便地调节Unity Shader中的参数,从而随时调整材质的效果. 这些参数需要卸载Properties语义块中. 123456789101112131415161718192021222324252627282930313233343536373839404142Shader "Custom/Myshader"&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag // 在Cg代码中,我们需要定义一个与属性的名称和类型都匹配的变量 fixed4 _Color; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; fixed3 color : COLOR0; &#125; v2f vert(a2v v)&#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.color = v.normal * 0.5 + float3(0.5, 0.5, 0.5); return o; &#125; fixed4 frag(v2f i) : SV_Target&#123; float3 c = i.color; // 使用-Color属性控制输出颜色 c *= _Color.rgb; return fixed4(c, 1.0); &#125; ENDCG &#125; &#125;&#125; 在上面的代码中,我们首先添加了Properties语义块,并在其中声明了一个属性_Color,它的类型是Color,初始值是(1.0, 1.0, 1.0, 1.0). 为了在Cg代码中使用,我们还需要在Cg代码片段中提前定义一个新的变量,这个变量的名称和类型必须与Properties中的属性定义相匹配 ShaderLab属性类型 Cg变量类型 Color, Vector float4, half4, fixed4 Range, Float float, half, fixed 2D sampler2D Cube samplerCube 3D sampler3D 有时会遇到uniform 1uniform fixed4 _Color; uniform关键词是Cg中修饰变量和参数的一种修饰词,它仅仅用于提供一些关于该变量的初始值是如何指定和存储的相关信息. 在Unity Shader中,uniform关键词是可以省略的 (所以uniform到底是个啥啊草) Unity内置文件和变量 为了方便开发者的编码过程,Unity提供了很多内置文件,这些文件包含了很多提前定义的变量,函数和宏等. 内置的包含文件 包含文件(include file),是类似于C++头文件的一种文件.在Unity中,它们的文件后缀是.cginc. 在编写shader时,我们可以用#include把这些文件包含进来,这样我们就可以使用Unity为我们提供的一些非常有用的变量和帮助函数.例如: 1234CDPROGRAM// ...#include "UnityCG.cginc"// ... unity\Editor\Data\CGIncludes文件夹包含了一些内置组件或功能需要的UnityShader. CDIncludes中主要的包含文件及它们的用处: 文件名 描述 UnityCG.cginc 包含了最常使用的帮助函数,宏和结构体等 UnityShaderVriables.cginc 在编译Unity Shader时,会被自动包含进来.包含了许多内置的全局变量,如UNITY_MATRIX_MVP等 Lighting.cginc 包含了各种内置的关照模型,如果包含的是表面着色器的话会自动包含进来 HLSLSupport.cginc 在编译Unity Shader时,会被自动包含进来.声明了许多跨平台编译的宏和定义 除这些之外,Unity5引入了许多新的重要的包含文件,如UnityShaderVariables.cginc, UnityStandardCore.cginc等,这些包含文件用于实现基于物理的渲染,我们会在18章再次遇到它们 UnityCG.cginc是我们最常接触的一个包含文件.它提供了很多结构体和函数方便我们编写Shader.例如,我们可以直接使用UnityCG.cginc中预定义的结构体作为顶点着色器的输入和输出. 名称 描述 包含的变量 appdata_base 可用于顶点着色器的输入 顶点位置,顶点法线,第一组纹理坐标 appdata_tan 可用于顶点着色器的输入 顶点位置,顶点切线,顶点法线,第一组纹理坐标 appdata_full 可用于顶点着色器的输入 顶点位置,顶点切线,顶点法线,四组(或更多)纹理坐标 appdata_img 可用于顶点着色器的输入 顶点位置,第一组纹理坐标 v2f_img 可用于顶点着色器的输出 裁剪空间中的位置 除了结构体外,UnityCG.cginc也提供了一些常用的帮助函数 函数名 描述 float3 WorldSpaceViewDir(float4 v) 输入一个模型空间中的顶点位置,返回世界空间中从该点到摄像机的观察方向 float3 ObjSpaceViewDir(float4 v) 输入一个模型空间中的顶点位置,返回模型空间中该点到摄像机的观察方向 float3 WorldSpaceLightDir(float4 v) 仅可用于前向渲染中.输入一个模型空间中的顶点位置,返回世界空间中从该点到光源的光照方向.没有被归一化 float3 ObjSpaceLightDir(float4 v) 仅可用于前向渲染中.输入一个模型空间中的顶点位置,返回模型空间中从该点到光源的光照方向.没有被归一化 float3 UnityObjectToWorldNormal(float3 norm) 把法线方向从模型空间变换到世界空间中 float3 UnityObjectToWorldDir(float3 dir) 把方向矢量从模型空间变换到世界空间中 float3 UnityWordToObjectDir(float3 dir) 把方向矢量从世界空间变换到模型空间中 内置的变量 Unity还提供了用于访问时间,光照,雾效和环境光等目的的变量. 这些内置变量大多位于UnityShaderVariables.cginc中,与光照有关的内置变量还会位于Lighting.cginc, AutoLighting.cginc等文件中. 后面遇到再详细讲解 Unity提供的Cg/HLSL语义 语义 语义就是一个赋给Shader的输入和输出的字符串,这个字符串表达了这个参数的含义.通俗地讲,这些语义可以让Shader知道从哪里读取数据,并把数据输出到哪里. 语义在Cg/HLSL的Shader流水线中是不可或缺的.需要注意的是,Unity并没有支持所有语义. 通常情况下,这些输入输出变量并不需要有特别的意义.也就是说,我们可以自行决定这些变量的用途. 在DX 10之后,有一种新的语义类型,就是系统数值语义(system-value semantics).这类语义是以SV开头的,SV代表的含义就是系统数值(system-value).这些语义在渲染流水线中有特殊的含义.例如我们用SV_POSITION语义去修饰顶点着色器的输出变量pos,那么就表示pos包含了可用于光栅化的变换后的顶点坐标. 这些语义修饰的变量时不可以随意赋值的,因为流水线需要使用它们来完成特定的目的.例如渲染引擎会把用SV_POSITION修饰的变量经过光栅化后显示在屏幕上. 有时会看到同一个变量在不同的Shader里面使用了不同的语义修饰.例如,一些Shader会使用POSITION而非SV_POSITION来修饰顶点着色器的输出.SV_POSITION是DirectX 10中新引入的系统数值语义,在绝大多数平台上,它和POSITION是等价的,但在某些平台(例如索尼PS4)上必须使用SV_POSITION来修饰顶点着色器的输出.否则无法让Shader正常工作. 因此,对于这些有特殊含义的变量我们最好使用SV开头的语义进行修饰. Unity支持的语义 从应用阶段传递模型数据给顶点着色器时Unity支持的常用语义 语义 描述 POSITION 模型空间中的顶点位置,通常是float4类型 NORMAL 顶点法线,通常是float3类型 TANGENT 顶点切线,通常是float4类型 TEXCOORDn 该顶点的纹理坐标.通常是float2或float4类型 COLOR 顶点颜色,通常是fixed4或者float4类型 其中TEXCOORDn是指TEXCOORD0,TEXCOORD1…其中n的数目是和Shader Model有关的,例如一般在Shader Model2(即Unity默认编译到的Shader Model版本)和Shader Model3中,n等于8,而在Shader Model5中,n等于16. 通常情况下,一个模型的纹理坐标数一般不超过2,我们往往只使用TEXCOORD0和TEXCOORD1. 在Unity中内置的数据结构体appdata_full中,它最多使用了6个纹理坐标 从顶点着色器传递数据给片元着色器时Unity使用的常用语义 语义 描述 SV_POSITION 裁剪空间中的顶点坐标,结构体中必须包含一个用该语义修饰的变量. COLOR0 通常用于输出第一组颜色信息,但不是必须的 COLOR1 通常用于输出第二组颜色信息,但不是必须的 TEXCOORD0~TEXCOORD7 通常用于输出纹理坐标,但不是必须的 上面的语义中,除了SV_POSITION是有特殊的含义外,其他语义对变量的含义没有明确的要求.也就是说,我们可以存储任意值到这些语义描述变量中. 通常,如果我们需要把一些自定义的数据从顶点着色器传递给片元着色器,一般选用TEXTURE0等 片元着色器输出时Unity支持的常用语义 语义 描述 SV_Target 输出值将会存储到渲染目标(render target)中 如何定义复杂的变量类型 上面提到的语义绝大部分用于描述标量或矢量类型的变量 下面的代码给出了一个使用语义来修饰不同类型的变量的例子: 1234567struct v2f&#123; float4 pos : SV_POSITION; fixed3 color0 : COLOR0; fixed4 color1 : COLOR1; half value0 : TEXCOORD0; float2 value1 : TEXCOORD1;&#125;; 关于何时使用哪些变量类型,我们会在5.7.1节给出一些建议.但需要注意的是,一个语义可以使用的寄存器只能处理4个浮点值. 因此,如果我们想要定义矩阵类型,如float3X4等变量就需要使用更多的空间.一种方法是,将这些变量拆分成多个变量,例如对于float4X4的矩阵类型,我们可以拆分成4个float类型的变量,每个变量存储了矩阵中的一行数据. Debug 书上P111 渲染平台的差异 书上p115 Shader整洁 float, half还是fixed 类型 精度 float 最高精度浮点值,通常使用32位来存储 half 中等精度浮点值,通常使用16位来存储,精度是-60,000 ~ 60,000 fixed 最低精度浮点值,通常使用11位来存储,精度是-2.0~2.0 上面的精度范围并不是绝对正确的,尤其是在不同平台和GPU上,他们的实际精度可能和上面给出的范围不一致.通常来讲. 大多数现代的桌面GPU会把所有计算都按最高的浮点精度进行计算.也就是说,float,half,fixed在这些平台上实际是等价的.这意味着我们在PC上很难看出因为half和fixed精度不同而带来的不同. 但在移动平台的GPU上,它们的确会有不同的精度范围.而且不用精度的浮点值的运算速度也会有差异.因此,我们应该确保在真正的移动平台上试验我们的Shader fixed精度实际上只在一些较旧的移动平台上有用,大多数现代GPU上,它们内部把fixed和half当成同样精度来对待. 尽管有上面的不同,单一个基本建议是,尽可能使用精度较低的类型,因为这可以优化Shader的性能,这一点在移动平台上尤其重要.从它们的大体的值域范围来看,我们可以使用 fixed类型来存储颜色和单位矢量 half存储更大的数据 最差的情况再使用float 如果我们的目标是移动平台,一定要确保在真实的手机上测试我们的Shader. 关于移动平台的优化技术,更多内容见16章 规范语法 在5.6.2节,我们提到了DirectX平台对Shader的语义有更加严格的要求.这意味着,如果我们要发布到DirectX平台上就需要使用更严格的语法. 例如,使用和变量类型相匹配的参数数目来对变量进行初始化. 避免不必要的计算 如果我们毫无节制地在Shader(尤其是片元着色器)中进行了大量计算,那么我们可能很快就会收到Unity的错误提示: temporary register limit of 8 exceeded 或 Arithmetic instruction limit of 64 exceeded; 65 arithmetic instructions needed to compileprogram 这样的错误太多是因为我们在Shader中进行了大量的运算,使得需要的临时寄存器数目或指令数目超过了当前可支持的数目. 不同的Shader Target,不同的着色器阶段,我们可使用的临时寄存器和指令数目都是不同的. 通常,我们可以通过指定更高级的Shader Target来消除这些错误. 指令 描述 #pragma target2.0 默认的Shader Target等级,相当于Direct3D上的Shader Model2.0,不支持对顶点纹理的采样,不支持显式的LOD纹理采样等 #pragma target3.0 相当于Direct3D 9 上的Shader Model 3.0, 支持对顶点纹理的采样等 #pragma target4.0 相当于Direct3D 10 上的Shader Model 4.0,支持几何着色器等 #pragma target5.0 相当于Direct3D11上的Shader Model 5.0 Shader Model是由微软提出的一套规范,通俗地理解就是它们决定了Shader中各个特性和能力.这些特性和能力体现在Shader能使用的运算指令数目,寄存器个数等各个方面.Shader等级越高,Shader的能力就越大. 虽然更高级的Shader Target可以让我们使用更多的临时寄存器和运算指令,但一个更好的方法是尽可能减少Shader中的运算,或者通过预计算的方式来提供更多的数据. 慎用分支和循环语句 if-else,for,while这些流程控制指令在GPU上的实现和在CPU上大不相同.在最坏的情况下,我们花在一个分支语句的时间相当于运行所有分支语句的时间.因此不提倡在Shader中使用流程控制语句. 如果我们的Shader中使用了大量的流程控制语句,那么这个Shader的性能可能会成倍下降. 一个解决方法是,我们应尽量把计算向流水线上端移动.例如把片段着色器中的计算放到顶点着色器中,或者直接在CPU中进行预计算,再把结果传递给Shader. 实在要用到分支语句时: 分支判断语句中使用的条件变量最好是常数,即在Shader运行过程中不会发生变化. 每个分支中包含的操作指令尽可能少 分支嵌套层数尽可能少 不要除以0 Shader中,除以0不会报错.注意.]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第3章-Unity Shader 基础]]></title>
    <url>%2Fshader-r-unity-shader%2F</url>
    <content type="text"><![CDATA[UnityShader概述 unity中的shader Standard Surface Shader 会产生一个包含了标准光照模型(使用了Unity5中新添加的基于物理的渲染方法,详见第18章)的表面着色器模板 Unlit Shader 会产生一个不含光照(单包含雾化效果)的基本顶点/片段着色器 ImageEffect Shader 为我们实现各种屏幕文件.这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算,而不在这本书的讨论范围内(草) UnityShader的结构 SubShader Subshader中定义了一系列的Pass一级可选的状态和标签的设置. 每个Pass定义了一次完整的渲染流程,但如果pass的数目过多,往往会造成渲染性能的下降.因此,我们应尽量使用小数目的Pass. 状态和标签同样可以在Pass声明.不同的是,SubShader中的一些标签设定是特定的.也就是说,这些标签设置和Pass中使用的标签是不一样的.而对于状态设置来说,其使用的语法是相同的.但是,如果我们在SubShader中进行了这些设置,那么将会用于所有Pass 状态设置 ShaderLab提供了一系列渲染状态的设置指令,这些指令可以设置显卡的各种状态.例如是否开启混合/深度测试等. 状态名称 设置指令 解释 Cull Cull Back/Front/Off 设置剔除模式.剔除背面/正面/关闭剔除 ZTest ZTest Less Greater/LEqual/GEqual/NotEqual/Always 设置深度测试时使用的函数 Zwrite ZWrite On/Off 开启/关闭深度测试 Blend Blend SrcFactor DstFactor 开启并设置混合模式 当在SubShader块中设置了这些渲染状态时,将会应用到所有Pass,如果我们不想这样,可以在Pass语义块中单独进行上面的设置. SubShader标签 SubShader的标签是一个键值对,他的键和值都是字符串类型. 标签结构如下: 1Tags &#123; &quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; &#125; 标签类型 说明 例子 Queue 控制渲染顺序,指定该物体属于哪一个渲染队列,通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染(详见第8章).我们也可以自定义使用的渲染队列来控制物体的渲染顺序 Tags { “Queue” = “Transparent” } RenderType 对着色器进行分类,例如这是一个不透明的着色器,或是一个透明的着色器.这可以用于着色器替换功能(啥玩意) Tags { “RenderType” = “Opaque” } DisableBatching 一些SubShader在使用Unity批处理功能时会出现问题,例如使用了模型空间下的坐标进行顶点动画(详见第11.3节).这时可以通过该标签来指明是否对该SubShader使用批处理. Tags { “DisableBatching” = “True” } ForceNoShadowCasting 控制使用该SubShader的物体是否会投射阴影(详见8.4)节 Tags { “ForceNoShadowCasting” = “True” } IgnoreProjector 如果该标签设置为True,那么使用该SubShader的物体不会受到projector的影响.通常用于半透明物体. Tags { “IgnoreProjector” = “True” } CanUseSpriteAtlas 当该SubShader是用于精灵时,将该标签设为False Tags { “CanUseSpriteAtlas” = “False” } PreviewType 指名材质面板将如何预览该材质.默认情况下,材质将显示为一个球形.我们可以通过将该标签的值设为&quot;Plane&quot; &quot;SkyBox&quot;来改变预览类型. Tags { “PreviewType” = “Plane” } Pass语义块 Pass语义块包含的语义如下 12345Pass &#123; [Name] [Tags] // Other Code&#125; 首先,我们可以在Pass中定义该Pass的名称,例如 1Name &quot;MyPassName&quot; 通过这个名称,我们可以使用Shader的UsePass命令来直接使用其他UnityShader中的Pass.例如: 1UsePass &quot;MyShader/MYPASSNAME&quot; 这样可以提高代码的复用性.需要注意的是,由于Unity内部会把所有Pass的名字转换成大写字母的表示,因此在使用UsePass命令时必须使用大写的名字. Pass同样可以设置标签,但它的标签不同于SubShader标签.这些标签也是告诉渲染引擎我们希望怎么来渲染该物体. 标签类型 说明 例子 LightMode 定义该Pass在Unity的渲染管线中的角色 Tags { “LightMode” = “ForwardBase” } RequiresOptions 用于指定当满足某些条件时才渲染该Pass,它的值是一个由空格分隔的字符串.目前,Unity支持的选项有: SoftVegetation. 在后面的版本中,可能会增加更多的选项. Tags{ “RequireOption” = “SoftVegetation” } 除了上面的普通Pass定义外,Unity Shader还支持一些特殊的Pass, 以便进行代码复用或实现更复杂的效果. UsePass 如之前所说,可以引入其他Unity Shader中的Pass. GrabPass 负责抓取屏幕并将结果存储在一张纹理中,以用于后续的Pass处理(详见10.2.2节) FallBack 1234FallBack &quot;name&quot;FallBack OffFallBack &quot;VertexLit&quot; 事实上,FallBack还会影响阴影的投射.在渲染阴影纹理时,Unity会在每个UnityShader中寻找一个阴影投射的Pass.通常情况下,我们不用自己专门实现一个阴影投射的Pass,这是因为FallBack使用内置Shader中包含了这样一个通用Pass. 因此,为每个UnityShader设置正确的FallBack是非常重要的. UnityShader的形式 尽管UnityShader可以做的事情非常多(如设置渲染状态等),但其最重要的任务还是指定各种着色器所需的代码.这些着色器代码可以写在Shader语义块中(表面着色器的做法),也可以写在Pass语义块中(顶点/片元着色器和固定函数着色器的做法). 表面着色器 Surface Shader 是Unity自己创造的一种着色器代码类型.它需要的代码量很少,Unity在背后做了很多工作,单渲染代价比较大.当给Unity提供一个表面着色器的时候,它在背后仍旧会将它转换成对应飞顶点/片元着色器. 它存在的价值在于,Unity为我们处理了很多光照细节,使得我们不需要再操心这些烦人的事情. 一个非常简单的表面着色器示例代码: 12345678910111213141516Shader &quot;Custom/sur&quot;&#123; SubShader&#123; Tags &#123;&quot;RenderType&quot; = &quot;Opaque&quot;&#125; CGPROGRAM #pragma surface surf Lambert struct Input &#123; float4 color:COLOR; &#125;; void surf(Input In, inout SurfaceOutput o) &#123; o.Albedo = 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 上述程序可以看出,表面着色器被定义在SubShader语义块(而非Pass语义块)中的CGPROGRAM和ENDCG之间.原因是,表面着色器不需要关心开发者使用多少个Pass,每个Pass如何渲染等问题,Unity会在背后去帮我们做好这些事情.我们要做的只是告诉它,“用这些纹理去填充颜色,用这个法线纹理去填充法线,使用Lambert光照模型” CGPROGRAM和ENDCG之间的代码是使用Cg/HLSL编写的,也就是说,我们需要把Cg/HLSL语言嵌套在ShaderLab中.值得注意的是,这里的Cg/HLSL是Unity经过封装后提供的,它的标准语法和标准的Cg/HLSL几乎一样,但还是有细微不同.例如有些原生的函数和用法Unity并没有提供支持. 顶点/片元着色器 Vertex/Fragment Shader 更加复杂,但灵活性更高. 123456789101112131415161718192021Shader &quot;Custom/vertexfragment&quot;&#123; SubShader&#123; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v : position) : SV_POSITION&#123; return mul(UNITY_MATRIX_MVP, v); &#125; float4 frag() : SV_Target&#123; return fixed4(1.0,0.0,0.0,1.0); &#125; ENDCG &#125; &#125;&#125; 和表面着色器类似,顶点/片元着色器的代码也需要定义在CGPROGRAM和ENDCG中间.但不同的是,顶点/片元着色器是写在Pass语义块中的,而非SubShader语义块内.原因是我们需要自己定义每个Pass需要使用的Shader代码.虽然我们可能需要编写更多的代码,但带来的好处是灵活性很高.更重要的是,我们可以控制渲染的实现细节. 固定函数着色器 Fixed Function Shader 弃子,现在不怎么用的着色器 上面两种着色器都是用了可编程管线.而对于一些较旧的设备,它们不支持可编程管线着色器,因此,我们就需要使用固定函数着色器. 这些着色器往往只能完成一些非常简单的效果]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第2章-渲染流水线]]></title>
    <url>%2Fshader-r-lsx%2F</url>
    <content type="text"><![CDATA[看完数学部分后再来写的 CPU流水线 将数据加载到显存中 把渲染所需所有数据从硬盘加载到系统内存中 网格和纹理等数据又被加载到显存中 设置渲染状态 这些状态定义了场景中的网格是怎么被渲染的 例如,使用哪个顶点着色器/片元着色器,光源属性,材质等. 如果我们没有设置渲染状态,那么所有网格都将使用同一种渲染状态 调用DrawCall Draw Call是一个命令,发起方是CPU,接收方是GPU. 这个命令仅仅会指向一个需要被渲染的图元的列表,而不再包含任何材质信息–因为已经在上个阶段完成了. 当给定一个Draw Call时,GPU会根据渲染状态(材质,纹理,着色器等)和所有输入的顶点数据来进行计算,最终输出到屏幕 GPU流水线 顶点数据 -&gt; 顶点着色器 -&gt; 曲面细分着色器 -&gt; 几何着色器 -&gt; 裁剪 -&gt; 屏幕映射 -&gt; 三角形设置 -&gt; 三角形遍历 -&gt; 片元着色器 -&gt; 逐片元操作 -&gt; 屏幕图像 顶点着色器 顶点无法销毁或创建顶点,也不可以获得顶点之间的联系.例如,我们无法判断两个顶点是否处于同一个网格.正是因为这样的相互独立性,GPU可以利用本身的特性并行化处理每一个顶点,这意味着这一阶段的处理速度会更快. 顶点着色器需要完成的主要工作有:坐标变换和逐顶点光照 当然除了这两个主要任务外,顶点着色器还可以输出后续阶段所需的数据. 坐标变换 把顶点坐标从模型空间变换到齐次剪裁空间 剪裁 摄像机的视野范围内很有可能不会覆盖场景中的所有物体.不在摄像机视野范围内的物体不需要处理.剪裁就是为了完成这个目标而被提出来的. 我们无法通过编程来控制剪裁的过程,而是硬件上的固定操作,但我们可以自定义一个剪裁操作来对这一步进行配置. 屏幕映射 屏幕映射的任务是把每个图元的x,y坐标转换到屏幕坐标系. 三角形设置 从这一步开始进入光栅化阶段. 从上一个阶段输出的信息是屏幕坐标系下的顶点位置以及它们的额外信息,如深度值(z坐标),法线方向,视角方向等. 光栅化阶段有两个最重要的目标:计算每个图元覆盖了哪些像素,以及为这些像素计算它们的颜色. 三角形设置阶段会计算光栅化一个三角网格所需的信息.具体来说,上个阶段输出的都是三角网格顶点.但如果要得到整个三角网格对像素覆盖的情况,我们就必须计算每条边上的像素坐标. 为了能够计算边界像素的坐标信息,我们就需要得到三角形边界的表达方式.这样一个计算三角形网格表示数据的过程就叫做三角形设置.它的输出是为了给下一步做准备. 三角形遍历 三角形遍历阶段会检查每个像素是否被一个三角网格所覆盖. 如果被覆盖的话,就生成一个片元 而这个找到哪些像素被三角网格覆盖的过程就是三角形遍历,这个阶段也被称为扫描变换. 三角形遍历会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素,并使用三角网格三个顶点的顶点信息对整个覆盖区域的像素进行插值. 这一步的输出就是得到一个片元序列. 需要注意的是,一个片元并不是真正意义上的像素,而是包含了很多状态的集合,这些状态用于计算每个像素的最终颜色 这些状态包括了(但不限于)它的屏幕坐标,深度信息,以及其他从几何阶段输出的顶点信息,如法线,纹理坐标等. 片元着色器 前面的光栅化操作并不会影响屏幕上每个像素的颜色值,而是会产生一系列的数据信息,来描述一个三角网格是怎样覆盖每个像素的.而片元就是负责存储这样一系列数据. 真正会对像素产生影响的是下一个阶段–逐片元操作 片元着色器的输入是上一个阶段对顶点信息插值得到的结果. 更具体来说,是根据那些从顶点着色器中输出的数据差值得到的. 它的输出是一个或多个颜色值. 这一阶段可以完成很多重要的渲染技术,其中最重要的技术之一是纹理采样. 为了在片元着色器中进行纹理采样,我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标 然后经过光栅化阶段对三角形网格的三个顶点对应的纹理坐标进行插值后,就可以得到其覆盖片元的纹理坐标了. 片元着色器的局限在于,它仅可影响单个片元. 也就是说,在执行片元着色器时,它不可以将自己的任何结果发送给它的邻居们. 有一个情况例外,就是片元着色器可以访问到导数信息(扩展阅读)(smjb) 逐片元操作 也被称为输出合并阶段 这一阶段的几个重要任务: 决定每个片元的可见性. 这涉及很多测试工作,如深度测试,模板测试等 合并 如果一个片元通过了所以测试,就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行混合 逐片元操作是高度可配置的.即我们可以设置每一步的操作细节.]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bili-api]]></title>
    <url>%2Fbili-api%2F</url>
    <content type="text"><![CDATA[url 描述 https://api.bilibili.com/x/relation/stat?vmid={uid} up粉丝数 https://api.bilibili.com/x/space/upstat?mid={uid} 观看量 https://api.bilibili.com/x/space/navnum?mid={uid} 投稿数量 https://api.bilibili.com/x/space/acc/info?mid={uid} 基本信息 https://api.bilibili.com/x/space/masterpiece?vmid={uid} 代表作]]></content>
  </entry>
  <entry>
    <title><![CDATA[《shader入门精要》笔记-第4章-数学基础]]></title>
    <url>%2Fshader-r-math%2F</url>
    <content type="text"><![CDATA[《shader入门精要》免费的第四章pdf 点和矢量 点积(内积)和叉积(外积) 内积 Shader代码中使用dot(a,b)来进行矢量的点积运算. 1a·b = (a x , a y , a z ) ·(b x , b y , b z ) = a x b x + a y b y + a z b z 满足交换律和结合律. 使用: 投影 单位矢量a,和一个长度不限制的矢量b,dot(a,b)得到b在a方向上带有符号的投影 外积 外积的结果时矢量,并非标量. 1a X b = (a x , a y , a z ) X (b x , b y , b z ) = (a y b z - a z b y , a z b x - a x b z , a x b y - a y b x ) 例如: (1, 2, 3) X (−2, −1, 4) = ((2)(4) − (3)(−1), (3)(−2) − (1)(4), (1)(−1) − (2)(−2)) = (8 − (−3), (−6) − 4, (−1) − (−4)) = (11, −10, 3) 外积不满足交换律,即a X b不等于b X a. 然而外积满足反交换律,即a X b = -(b X a) 外积不满足结合律. 矩阵(matrix) 矩阵运算 矩阵乘法 矩阵乘法不满足交换律 AB不等于BA 矩阵乘法满足结合律 (AB)C = A(BC) shader中主要使用4x4矩阵来运算. 特殊矩阵 方块矩阵(方阵) 行和列数目相等的矩阵. 三维渲染里,用的最多的是3x3和4x4的方阵 单位矩阵 用In来表示.比如I3是3x3的单位矩阵. 转置矩阵 transposed matrix 转置矩阵实际是对原矩阵的一种运算,即转置运算.给定一个rXc的矩阵M,他的转置可以表示为MT(T为上标)(辣鸡MD).数学公式是: 例如: 转置矩阵性质: 转置矩阵的转置等于原矩阵(废话) 矩阵的串接转置等于反向串接各个矩阵的转置 即: 逆矩阵 给定一个矩阵M,用M-1(-1为上标)表示M的逆矩阵. MM-1为单位矩阵 矩阵可逆的条件: 矩阵为方块矩阵 矩阵的行列式不为零 虽说在学数学…但是也是shader开发里的数学…还是不去回忆具体怎么求逆矩阵了,交给程序去做=v= 逆矩阵的性质 逆矩阵的逆矩阵等于原矩阵 单位矩阵的逆矩阵是其本身 转置矩阵的逆矩阵等于逆矩阵的转置 即: 矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵 即: 正交矩阵 蒸饺正交是矩阵的一种属性.如果一个方阵M和它的转置矩阵的乘积是单位矩阵的话,我们说这个矩阵是正交的 即: 行矩阵or列矩阵? 书上p64 这里不说过程了. 结论是,unity中习惯把矢量转换成列矩阵,并放在矩阵的右侧进行计算. 矩阵的几何意义: 变换 变换的类型 线性变换 可以保留矢量加和标量乘的变换.用数学公式表达即是: 上面的式子很抽象. 缩放就是一种线性变换.如f(x) = 2x,可以表示一个大小为2的统一缩放. 旋转也是一种线性变换 对于线性变换来说,仅仅使用3X3矩阵可以表示三维坐标下的所有线性变换. 线性变换除了包括旋转和缩放外,还包括错切,镜像,正交投影等. 仿射变换 仅有线性变换是不够的,要考虑平移交换.如,f(x) = x + (1,0,0)这个变换就不是一个线性变换. 三维坐标下,我们不能用一个3x3的矩阵来表示一个平移变换. 这样,就有了仿射变换. 仿射变换是合并了线性变换和平移变换的变换类型.三维空间下的仿射变换可以用一个4x4的矩阵来表示.为此,我们需要把矢量扩展到四维空间下,这就是齐 次 坐 标 空 间(homogeneous space). 不知道是什么鸡儿玩意单好像以后有用的表 齐次坐标 因为3X3矩阵不能表示平移,所以我们用4x4矩阵.为此,我们还需要把原来的三维矢量转换成四维矢量,也就是齐次坐标(homogeneous coordinate). 对于一个点,从三维坐标转换为齐次坐标是将其w分量设为1,而对于方向矢量而言,需要把其w分量设为0. 这样的设置会导致,用一个4x4矩阵对一个点进行变换的时候,平移,缩放,旋转都会被施加于该点.但是如果用于变换一个方向矢量,平移的效果就会被忽略. 分解基础变换矩阵 我们可以把一个基础变换矩阵分解成4个组成部分. 其中,左上角的M是一个用于旋转和缩放的三维矩阵. t表示平移. 最后一行是固定的[0 0 0 1] 平移矩阵 M为单位矩阵时,整个4x4矩阵只代表平移. 平移矩阵的逆矩阵就是反向平移的矩阵. 缩放矩阵 如果缩放系数kx = ky = kz,我们把这样的缩放称为统一缩放否则称为非统一缩放. 直观上看,统一缩放就是等比缩放模型,而非统一缩放会拉伸或挤压模型. 统一缩放不会改变角度和比例信息,非统一缩放会改变模型相关的角度和比例. 在进行法线变换时,如果存在非统一缩放,直接用于变换顶点的变换矩阵的话,就会得到错误的结果.(正确的方法见4.7节(还没发货哦草)) 旋转矩阵 按x轴旋转: 按y轴旋转 按z轴旋转 复合变换 我们可以把平移,旋转,缩放结合起来,组成一个复杂的变换过程. 例如,可以对一个模型先进行大小为(2, 2, 2)的缩放,再绕y轴旋转30度,最后向z轴平移4个单位. 复合矩阵可以通过矩阵的串联来实现. 如: 需要注意的是,因为矩阵的乘法不满足交换律,变换的结果是依赖于变换顺序的. 绝大多数情况下,我们约定变换的顺序是,先缩放,再旋转,最后平移. 坐标空间 模型空间 也称对象空间或局部空间. 世界空间 最外层的坐标空间 观察空间 也称为摄像机空间 Unity中观察空间的+x轴指右方,+y轴指向上方,+z轴指向摄像机的后方----Unity在模型空间和世界空间选用的是左手坐标系,而观察者空间选用右手坐标系. 观察空间和屏幕空间是不同的.观察空间是一个三维空间,而屏幕空间是一个二维空间.从观察空间到屏幕空间需要一个投影(projection)转换. 顶点变换的第二步,就是将顶点坐标从世界空间变换到观察空间.这个变换通常叫做观察变换. 剪裁空间 顶点接下来要从观察者空间转换到剪裁空间(clip space,也被称为齐次裁剪空间)中,这个用于变换的举证叫做裁剪矩阵(clip matrix),也被称为投影矩阵(projection matrix). 剪裁空间的目标是能够方便地对渲染图元进行裁剪.完全位于这块空间内部的图元将会被保留,完全处于这块空间外部的图元将会被剔除,而与这块空间边界相交的图元就会被裁剪.这块空间是由视锥体(view frustum)决定的. 视锥体指的是空间中的一块区域,这块区域决定了摄像机可以看到的空间.视锥体由留个平面包围而成,这些平面被称为裁剪平面(clip planes). 视锥体有两种类型,这涉及两种投影类型----一种是正交投影(orthographic projection),一种是透视投影(perspective projection) 透视投影会有远小近大. 在视锥体的6块裁剪平面中,有两块裁剪平面比较特殊,分别是近剪裁平面(near clip plane)和远剪裁平面(far clip plane).它们决定了摄像机可以看到的深度范围. 我们通过一种通用,简洁的方式进行剪裁工作,这种方式是通过一个投影矩阵把顶点转换到一个剪裁空间中. 投影矩阵有两个目的: 首先是为投影做准备.这是个迷惑点,虽然投影矩阵包含了投影二字,但是它并没有进行真正的投影工作,而是在为投影做准备.真正的投影发生在后面的齐次排除法(homogeneous division)过程中.而经过投影矩阵变换后,顶点的w分量将会具有特殊意义. 其次是对x,y,z分量进行缩放.经过投影矩阵的缩放以后,我们可以直接使用w分量作为一个范围值,如x,y,z都在这个范围内,就说明该顶点位于剪裁空间内. 1.透视投影 视锥体的六个剪裁平面是由Camera组件中的参数和Game视图的横纵比共同决定的. 如图所示,我们可以通过Camera组件的Field of View(简称FOV)属性来改变视锥体竖直张开的角度,而Cliping Planes中的Near和Far属性可以控制视锥体的近剪裁平面和远剪裁平面距离摄像机的远近.这样,我们可以求出视锥体近剪裁平面和远剪裁平面的高度. 一个摄像机的横纵比由Game视图的横纵比和Viewport Rect中的W和H属性共同决定.假设,当前摄像机的横纵比是Aspect: 现在,我们可以根据已知的Near,Far,FOV和Aspect的值来确定透视投影的投影矩阵. 推导见本章的扩展阅读部分 一个顶点和上面的投影矩阵相乘后,可以由观察者空间变换到剪裁空间. 从结果可以看出来,投影矩阵的本质是对x,y,z分量做了不同的缩放(z分量还做了一个平移).缩放的目的是为了方便裁剪. 可以注意到,此时顶点的w分量不再是1,而是原先z分量的取反.现在,我们就可以按如下不等式判断一个变换后的顶点是否位于视锥体内.如果一个顶点在视锥体内,那么它变换后的坐标必须满足: -w &lt;= x &lt;= w -w &lt;= y &lt;= w -w &lt;= z &lt;= w 任何不满足上述条件的图元都需要被剔除或者裁剪. 通过此图还可以注意到,剪裁矩阵会改变空间的旋向性:空间从右手坐标系变换到了左手坐标系. 2. 正交投影 和透视投影类似,在unity中,正交投影的六个人裁剪平面是由Camera组件中的参数和Game视图的横纵比共同决定的. 由图看出,我们可以通过Camera组件的Size属性来改变视锥体竖直方向上的高度的一半,而Clipping Planes中的Near和Far参数可以控制视锥体的近剪裁平面和远剪裁平面距离摄像机的远近.这样,我们可以求出视锥体近剪裁平面和远剪裁平面的高度.即: 同样,我们可以通过摄像机的横纵比得到横向信息.假设当前摄像机的横纵比为Aspect: 现在我们根据已知的Near,Far,Size和Aspect的值来确定正交投影的裁剪矩阵.如下: 推导见本章的扩展阅读 一个顶点和上述投影矩阵相乘后的结果如下: 注意到,和透视投影不同,使用正交投影的投影矩阵对顶点变换后,其分量w依然为1.本质是因为投影矩阵最后一行的不同,透视投影的投影矩阵的最后一行是[0 0 -1 0],而正交投影的投影矩阵最后一行是[0 0 0 1].这样选择是为了为齐次除法做准备(具体在下面讲到) 判断一个变换后的顶点是否位于视锥体内使用的不等式和透视投影的一样. 同样,裁剪矩阵改变了空间的旋向性.可以注意到,经过正交投影变换后的顶点实际已经位于一个立方体内了. 屏幕空间 经过了投影矩阵的变换后,我们可以进行剪裁工作.当完成了所有的剪裁工作后,就需要进行真正的投影了.也就是说,我们需要把视锥体投影到屏幕空间(screen space)中.经过这一步变换,我们会得到真正的像素位置,二非虚拟的三维坐标. 屏幕空间是一个二维空间,因此我们需要把顶点从剪裁空间投影到屏幕空间,来生成对应的2D坐标.这个过程分为两个步骤 首先,我们要进行标准齐次除法(homogeneous division),也被称为透视除法(perspective division).虽然这个步骤听起来陌生,但它实际上非常简单,就是用齐次坐标系的w分量去除以x,y,z分量.在OpenGL中,我们把这一步得到的坐标叫做归一化的设备坐标(Normalized Device Coordinate, NDC).经过这一步,我们可以把坐标从齐次剪裁坐标空间转换到NDC中.经过透视投影变换后的剪裁空间,经过齐次除法后会变换到一个立方体内. 对于透视投影 对于正交投影 经过齐次除法后,透视投影的剪裁空间会变换到一个立方体 对于正交投影来说,它的剪裁空间实际已经是一个立方体了,而且由于经过正交投影矩阵变换后的顶点的w分量是1,因此齐次除法并不会对顶点的x,y,z坐标产生影响 经过齐次除法后,透视投影和正交投影的视锥体都变换到一个相同的立方体内.现在,我们可以根据变换后的x,y坐标来映射输出窗口的对应像素坐标. 这个映射的过程是一个缩放的过程. 齐次除法和屏幕映射的过程可以用下面的公式总结: 上面式子对x和y分量进行了处理,而z分量会被用于深度缓冲.一个传统的方式是把clip z / clip w的值直接存进深度缓冲中,但这不是必须的.通常驱动的生产商会根据硬件来选择最好的存储格式. 此时clip w也并未抛弃,虽然它已经完成了它的主要工作–在齐次除法中作为分母来得到NDC,但它仍然会在后续的一些工作中起到重要作用.例如进行透视矫正差值(草,这又是什么玩意) 在Unity中,从剪裁空间到屏幕空间的转换是底层帮我们完成的.我们的顶点着色器只需要把顶点转换到剪裁空间即可. 总结 以上就是一个顶点如何从模型空间最终转换到屏幕空间的全过程. 顶点着色器的最基本的任务是把顶点坐标从模型空间转换到剪裁空间中.这对应了上图中的前三个顶点变换过程.而在片元着色器中,我们通常也可以得到该片元在屏幕空间的像素信息.我们会在4.9.3节中看到如何得到这些像素位置. 在Unity中,坐标系的旋向性也随着发生了改变. 只有在观察空间使用了右手坐标系. 需要注意的是,这里仅仅给出的是一些最重要的坐标空间.还有一些空间在实际开发中也会遇到,如切线空间(tangent space).切线空间通常用于法线映射. 法线变换 法线(normal),也被称为法矢量(normal vector). 在游戏中,模型的一个顶点往往会携带额外的信息,而顶点法线就是其中的一种信息. 当我们变换一个模型的时候,不仅要变换它的顶点,还需要变换它的法线,以便在后续的处理(如片元着色器)中计算光照等. 玛德这块数学公式太多了md不要表达,反正本来的这块内容就没多少去书上看吧. Unity Shader的内置变量(数学篇) 变换矩阵 这里是Unity5.2版本提供的所有内置变换矩阵.所有矩阵都是float4x4的. 变量名 描述 _Object2World 当前的模型矩阵,用于将顶点/方向矢量从模型空间变换到世界空间 _World2Object _Object2World的逆矩阵.用于将顶点/方向矢量从世界空间变换到模型空间 UNITY_MATRIX_V 当前的观察矩阵,用于将顶点/方向矢量从世界空间变换到观察空间 UNITY_MATRIX_P 当前的投影矩阵,用于将顶点/方向矢量从观察空间变换到剪裁空间 UNITY_MATRIX_MV 当前的模型矩阵·观察矩阵,用于将顶点/方向矢量从模型空间变换到观察空间 UNITY_MATRIX_VP 当前的观察矩阵·投影矩阵,用于将顶点/方向矢量从世界空间转换到剪裁空间 UNITY_MATRIX_MVP 当前的模型矩阵·观察矩阵·投影矩阵,用于将顶点/方向矢量从模型空间变换到剪裁空间 UNITY_MATRIX_T_MV UNITY_MATRIX_MV的转置矩阵 UNITY_MATRIX_IT_MV UNITY_MATRIX_MV的逆转置矩阵,用于将法线从模型空间变换到世界观察空间,也可用于得到UNITY_MATRIX_MV的逆矩阵 UNITY_MATRIX_T_MV这个矩阵比较特殊. 对于正交矩阵来说,它的逆矩阵就是转置矩阵.因此,如果UNITY_MATRIX_MV是一个正交矩阵的话,那么UNITY_MATRIX_T_MV就是它的逆矩阵,也就是说,我们可以使用UNITY_MATRIX_T_MV将顶点/方向矢量从观察空间变换到模型空间 UNITY_MATRIX_IT_MV这个矩阵也要特殊说明一下. 法线的变换需要使用原变换矩阵的逆转矩阵,因此UNITY_MATRIX_IT_MV可以把发现从模型空间变换到观察者空间.而且,只需要对它进行转置,就可以得到UNITY_MATRIX_MV的逆矩阵因此,为了把顶点或法线矢量从观察者空间变换到模型空间,我们可以使用以下代码: 12345// 方法一: 使用transpose函数对UNITY_MATRIX_IT_MV进行转置,得到UNITY_MATRIX_MV的逆矩阵,然后进行列矩阵乘法,把观察空间中的点或方向矢量变换到模型空间中 float4 modelPos = mul(transpose(UNITY_MATRIX_IT_MV), viewPos);// 方法二: 不直接使用转置函数transpose, 而是交换mul参数的位置,使用行矩阵乘法. 本质是一样的.float4 modelPos = mul(viewPos, UNITY_MATRIX_IT_MV); 摄像机和屏幕参数 Unity提供了一些内置变量来让我们访问当前正在渲染的摄像机的参数信息.这些参数对应了摄像机上的Camera组件中的属性值. 变量名 类型 描述 _WorldSpaceCameraPos float3 该摄像机在世界空间中的位置 _ProjectionParams float4 x = 1.0(或-1.0, 如果正在使用一个翻转的投影矩阵进行渲染), y = Near, z = Far, w = 1.0 + 1.0/Far _ScreenParams float4 x = wodth, y = height, z = 1.0 + 1.0/width, w = 1.0 + 1.0/height _ZBufferParams float4 x = 1 - Far/Near, y = Far/Near, z = x/Far, w = y/Far, 该变量用于线性化Z缓存中的深度值(可参考13.1节) unity_OrthoParams float4 x = width, y = height,z没有定义,w = 1.0(该摄像机是正交摄像机),或w = 0.0(该摄像机是透视摄像机) unity_CameraProjectio float4x4 该摄像机的投影矩阵 unity_CameraInvProjection float4x4 该摄像机的投影矩阵的逆矩阵 unity_CameraWorldClipPlanes[6] float4 该摄像机的6个裁剪平面在世界空间下是等式.按如下顺序:左,右,下,上,近,远裁剪平面]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>《shader入门精要》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10-Insider-Preview]]></title>
    <url>%2Fwin10-Insider-Preview%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[博客上放上live2d]]></title>
    <url>%2Fblog-live2d%2F</url>
    <content type="text"><![CDATA[很久前就看到在网站上挂个live2d,也有想法了,然而从昨晚才开始折腾.想在博客上放个舰b的live2d,结果试了好久,版本二到版本三,从民间到官方的web sdk都试了,就没有支持舰b的live2d的T_T 最后妥协了下,选了有前车之鉴的药水制作师的live2d.最喜欢之前拿红宝石买来的樱花校服装了. 阿黑颜pio 参考: 猫与向日葵的博客 Cubism WebGL SDK]]></content>
      <tags>
        <tag>live2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shader学习]]></title>
    <url>%2Fshader-learning%2F</url>
    <content type="text"><![CDATA[资料 Shader编程教程-蛮牛 Unity User Manual 第一课 图形硬件简史与可编程管线 课时总结 2003年开始正式进入可编程GPU阶段 GPU的并行处理能力强于CPU 目前GPU无法代替CPU 第二课 shader和渲染管线 GPU前段模块-&gt;图源装配: 过去只有集成在硬件当中的顶点着色器,现在可编程 光栅化: 把计算机显卡当中运算的数据进行一个细分用于适配屏幕上具体的每一个像素的显示 像素运算: 光栅化不等同于像素运算.像素运算最终反映的是颜色,光栅化过后得到的结果是帧缓存.这个过程中可以加入片段着色器. Vertex Processor 顶点处理程序,运算的结果将会交给像素处理器 Frame Buffer 帧缓冲中容纳了是计算机依次显示所要使用的数据,但不只是屏幕上用语显示的颜色的信息,可能还有其他的附加信息.比如深度值 Transform, TexGen, Lighting Transform 模型的空间变换(针对顶点的空间几何变换) Texture Generator 纹理坐标的生成,主要用于在顶点当中取得纹理坐标,纹理坐标转化为uv取值的范围 Lighting 光照 Vertex Shader 改变上个模块的光照,变换,纹理生成等 Culling Depth Test Culling 裁剪.物体在镜头面前展示,背对摄像头的面看不到,可能就会被裁剪,不处理看不到的面的顶点数据. Depth Test 深度测试.范围超过摄像头最近或最远的渲染范围之后,也会被剔除 Texturing Fog 纹理采样.进入光栅化阶段.从纹理当中找到纹理中对应的一个点 Fragmen Shader 远处的物体可能需要雾化处理.处于片段shader的可编程范围 Alpha Test 绘制半透明或全透明物体 Blending 混合最终的图像 可编程能力是两个部分,一部分是变换和光照,使用顶点shader编写顶点着色器 如何采样,计算颜色以及雾化处理等等,这部分放到片段着色器 unity当中,优化主要部分是减少游戏调用gpu渲染的调度次数.CPU搜集数据,产生GPU调度数据.这个过程是昂贵的. shader和材质,贴图的关系 shader实际上是一小段程序.负责将输入的顶点数据以指定的方式和输入的贴图或者颜色组合起来然后输出. 绘图单元可以依据这个输出将图像绘制到屏幕上. 输入的贴图或者颜色等,加上对应的shader,以及对shader]d特定的参数设置,将这些内容(shader及输入参数)打包存储在一起.得到的就是一个Material(材质).之后我们便可以将材质赋予三维物体来渲染(输出)了. 材质好比引擎最终的商品,shader是生产这种商品的加工方法,而贴图是原材料. 课时总结 Shader是图形可编程方案的程序片段 渲染管线是一种计算机从数据到最终图形成像的形象描述 材质是商品,shader是方法,贴图是材料 第三课 shader的三大主流高级编程语言 HLSL 基于DirectX的High Level Shading Language GLSL 基于OpenGL的OpenGL Shading Language CG NVIDIA公司的C for Graphic 第四课 Unity Shader的组织形式 surface shader unity推荐和鼓励的shader.图形管线能够用于识别的,就是vertex and fragment shader.surface shader是对vertex and fragment shader的一种包装.unity最终会把surface shader编译成能被硬件识别和调用的vertex and fragment shader vertex and fragment shader fixed function shaders 固定管线的shader. Shaderlab 语法基本结构 12345678910111213141516Shader &quot;MyShader&quot; &#123; Properties &#123; _MyTexture (&quot;My Texture&quot;, 2D) = &quot;white&quot; &#123; &#125; // place other properties here, such as colors or vectors. &#125; SubShader &#123; // place the shader code here for your: // - surface shader, // - vertex and program shader, or // - fixed function shader &#125; SubShader &#123; // a simpler version of the subshader above goes here. // this version is for supporting older graphics cards. &#125;&#125; unity自带shader Unlit 不发光 VertexLit 顶点光照 Diffuse 漫反射.不仅仅在顶点上进行光照计算,在片段上进行光照计算 Normal Mapped 法线贴图.用的比较多.通过一张贴图进行采样.贴图是关于法向量存储的贴图.把这张图采样出的数据作为法向量再进行光照计算.主要目的是当几何模型面片数量,顶点数量不太多,为表达丰富的细节. Specular 高光.玻璃等 Normal Mapped Specular 高光法线贴图.较昂贵 Parallax Normal mapped 视差法线贴图 Parallax Normal mapped Specular 高光视差法线贴图 Fixed function shader 固定功能的shader.功能有限但是性能很好 Surface Shader Surface Shader无需编写pass通道]]></content>
      <categories>
        <category>作废归档</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[夏目友人帐观影]]></title>
    <url>%2Fnazume-film%2F</url>
    <content type="text"><![CDATA[听说到容莉枝不管好事还是坏事都要去那个祠堂参拜的时候,就心想着那是个树洞,结果还真是个真实树洞233 前半那个笹田演讲的时候放的BGM就是那首熟悉的ふるさとの匂い,直接掉泪 容莉枝阿姨在儿子死后的八年间没有很痛苦是很好的,穗之影做得好.真正可怜的是穗之影啊草. 看之前的剧情以为名取对夏目图谋不轨来着,这次看名取的心理活动,还是个好人.]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习unity]]></title>
    <url>%2Funity-learning%2F</url>
    <content type="text"><![CDATA[unity官方教程https://unity3d.com/cn/learn/tutorials 现在在看一个beagining教程roll a ball material初探 新建material,选择颜色后,将material拖到gameObject上,gameObject就会变成对应的颜色 Update方法 Update方法 Update方法在渲染每帧前被调用 FixedUpdate FixedUpdate方法只有在执行有关物理计算之前才被调用 LateUpdate LateUpdate方法在所有Update方法执行完执行完之后执行 静态和动态GameObject 静态碰撞体 unity会计算场景内所有静态碰撞体的体积,并将信息保存在缓存内.因为静态碰撞体不需要移动,可以避免每帧重新计算这些信息,所以这是对的 每当静态碰撞体移动 旋转或缩放时,unity会重新计算这些静态碰撞体,然后更新静态碰撞体的缓存数据 动态碰撞体 重新计算缓存会耗费系统资源,但我们可以随意移动移动,旋转或缩放动态碰撞体,而且unity不会缓存他们的数据.unity会预测动态碰撞体的移动,所以在移动碰撞体之前,需要告诉unity它们是动态的.可以使用刚体组件来实现这种效果. 任何带有碰撞体和刚体组件的GameObject都会被认为是动态的.任何带有碰撞体却没有刚体组件的GameObject则被视为是静态的. 刚体选中&quot;Is Kinematic&quot;可以将刚体变成仅受脚本控制的刚体.kinematic刚体不受无力作用力的影响,但可以播放动画或通过Transform组件移动 几何图元绘制顺序 Sorting Layer Sorting Layer序号越大的层越后绘制,因而会覆盖掉前面序号小的层上的几何图元 表示指定层在Tags and Layers视图Sorting Layers中的顺序 各层的绘制顺序是Default -&gt; Background -&gt; Character -&gt; Foreground -&gt; UI Order in layer 在同一层调整几何图元的绘制深度.同样是序号大的覆盖序号小的 spirit Render组件中SortingLayer属性控制的是不同层之间的绘制顺序,而Order in Layer控制的是同层中物体的绘制顺序 spine 可算知道瓜游的小人都是什么了 一开始下的spine3.7,然后 于是又下了3.6. 卸载旧版本插件好像是直接在project里把对应的删掉 目力俾斯麦 蛮好玩的 U!P!D!A!T!E! 写unity程序跟平常写其他程序一个很不一样的思想就是unity的每帧都会执行的update. 平时写程序如果遇到时间相关的,就要考虑sleep,然后就要考虑阻塞,考虑协程或多线程. 而unity不一样.利用unity的update机制可以很轻易的管理时间.]]></content>
      <categories>
        <category>作废归档</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加了几个音乐收藏夹]]></title>
    <url>%2FmusicFavorites%2F</url>
    <content type="text"><![CDATA[想着给把最喜欢,最常听的几首歌按风格分类,造了这么几个歌单 治愈 爱 静谧 朝气蓬勃 优美忧伤 对这些歌写点东西 治愈 urar 很美好. 蝴蝶泉边 同样很美好很温馨,更加了点回忆的感觉 Growing! 就是让人撒娇的歌 爱 Letter 动画HandShaker的BGM中听到的. 前面一段代表书信的常规内容,后面深深的感情喷涌而出. 不像小情侣之间的爱,像是老夫老妻或者亲情的爱 这封Letter不像情书而是像家书 LuvLetter 情书. 写情书和纠结要不要将情书送出去的过程,理解的是纠结着很痛苦然后没能送出去. 中间有纠结的痛苦,也有想象的美好结局. 恋 日推给我的,高潮部分很好听 愛唄 当初看一个高木同学的AMV注意到的,很真情实感 小小恋歌 同样是高木同学ed收录的 当初觉得高桥李依版本的好听,比较甜美来着,后来还是觉得新垣结衣唱的好听,捎带沙哑点的声音很温柔很知性 さよならの夏 啊 静谧 Mountain stream 高中时候学校就经常放的 陽だまり道とれんちょん 悠哉日常大王的BGM ふるさとの匂い 夏目友人帐的BGM 朝气蓬勃 RYDEEN 朝气蓬勃 优美忧伤 おうちに帰りたい ちいさな冒険者 素晴的ed. Arrietty’s Song 借东西的小人阿莉埃蒂的主题曲 春よ、来い 看了一个潮学视频知道的…着实很好听 この感情は使命 island的曲子 さよならの夏 啊]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python多重继承init的问题]]></title>
    <url>%2Fpython-mult-inherit-init%2F</url>
    <content type="text"><![CDATA[继承的时候,init父类时,平时用ide写代码习惯了这样写,因为敲一个super再回车就有了这么一行 1super(C, self).__init__() 12345678910111213141516class A: def __init__(self): self.a = "a" class B: def __init__(self): self.b = "b"class C(A,B): def __init__(self): super(C, self).__init__()if __name__ == '__main__': c = C() print(c.__dict__) # &gt;&gt;&gt; &#123;'a': 'a'&#125; 可以看出问题了,C类只init了A类,并没有init B类 下面是我瞎摸出来的解决方法 1234567891011121314151617181920class A: def __init__(self): self.a = "a"class B: def __init__(self): self.b = "b"class C(A, B): def __init__(self): A.__init__(self) B.__init__(self)if __name__ == '__main__': c = C() print(c.__dict__) # &gt;&gt;&gt; &#123;'a': 'a', 'b': 'b'&#125;]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动玩瓜游连连看的脚本]]></title>
    <url>%2Fazurlane-llk%2F</url>
    <content type="text"><![CDATA[做了个自动玩连连看的脚本. github : https://github.com/HHHHhgqcdxhg/azurlane-linkup 图片整理 将原图整理成以下格式 原图: 整理出: 1234567[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 16. 2. 4. 1. 3. 1. 2. 17. 3. 0.] [ 0. 8. 7. 14. 4. 10. 12. 18. 5. 5. 0.] [ 0. 6. 6. 9. 15. 7. 11. 8. 9. 10. 0.] [ 0. 11. 12. 13. 13. 14. 15. 16. 17. 18. 0.] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] #这个二维数组是抽象的连连看"地图",将原连连看相同的图片换成同样的数字,在在周围填充0表示通路 和 12[[1, 6], [1, 4], [1, 7], [1, 2], [1, 9], [1, 5], [2, 4], [1, 3], [2, 9], [2, 8], [3, 2], [3, 1], [3, 5], [2, 2], [3, 7], [2, 1], [3, 8], [3, 3], [3, 9], [2, 5], [4, 1], [3, 6], [4, 2], [2, 6], [4, 4], [4, 3], [4, 5], [2, 3], [4, 6], [3, 4], [4, 7], [1, 1], [4, 8], [1, 8], [4, 9], [2, 7]]# 这个数组每一项表示一组坐标,并且第 2 * i 个元素代表的图片和第 2 * i + 1 个元素代表的图片相同 求解 算法 广度优先暴搜,搜索所有可以到达的图片块,判断目标是否在其中. 代码在源码中的findLineFetch方法和pointSearch方法,注释还写的蛮详细的,这里不再解释. 实行点击: 跟上次的翻牌游戏脚本差不多 结果 7.80s视频: av45062991 7.80s留了视频,有一个7.27s的没录好… 追求极致的话应该能跑进7秒内,说不定能跑进6秒内,我做不到一定是因为我太菜了 时间浪费 截图耗时 因为开局前截图会有数字遮挡,所以等数字消完,再进行截图.因为有一些IO操作,所以就很慢… 算法耗时 嘛,我这个算法是广度优先暴搜,应该比较慢. 点击间隔不统一 ↑这个形容不是很准确.好像,当两个有效的点被点击时,如果距离比较近,下次可以点击的时间间隔就比较短,反之亦然.只是推测,不太确定.因为试的时候,经常前面好多都没事,最后两三组点的时候出错,怀疑是排到最后的组一般距离比较远导致的结果.]]></content>
      <tags>
        <tag>碧蓝航线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plus Ultra!]]></title>
    <url>%2Fbokuhiro-movie%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>动漫</tag>
        <tag>我的英雄学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线翻牌小游戏复现]]></title>
    <url>%2Fblhx-fanpai%2F</url>
    <content type="text"><![CDATA[git repo:https://github.com/HHHHhgqcdxhg/azurlane-fanpai 已部署在:https://blog.ggemo.com/azurlane-fanpai/dist/index.html 一下午撸出来的web复现的碧蓝航线翻牌小游戏. 一路写下来没遇到坑,但也没考虑性能.]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩游戏 还愿]]></title>
    <url>%2Fdevotion%2F</url>
    <content type="text"><![CDATA[真的吓人…变写博客边玩吧. 游戏过程 小女孩透过墙洞看爸爸撕写的字…想了想,以后写代码错到恼羞成怒了也只注释不删 弹珠迷宫真是绝了 被老婆追杀那里吓坏了.用手挡住屏幕看不到主要画面,然后一直都不知道要转头跑…回头翻了别人的视频才知道要跑… 拔舌头那里真心不敢看…依旧拿手遮屏幕 评价 第一次玩恐怖游戏来着,因为跟风就去玩了,吓得不轻. 还是不喜欢这种,为恐怖而恐怖的游戏.里面的一些价值观也不认同. 凉凉 2019年2月23日更新 自断财路的傻逼玩意]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win32按键码]]></title>
    <url>%2Fvkcode%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147VK_CODE = &#123; 'backspace': 0x08, 'tab': 0x09, 'clear': 0x0C, 'enter': 0x0D, 'shift': 0x10, 'ctrl': 0x11, 'alt': 0x12, 'pause': 0x13, 'caps_lock': 0x14, 'esc': 0x1B, 'spacebar': 0x20, 'page_up': 0x21, 'page_down': 0x22, 'end': 0x23, 'home': 0x24, 'left_arrow': 0x25, 'up_arrow': 0x26, 'right_arrow': 0x27, 'down_arrow': 0x28, 'select': 0x29, 'print': 0x2A, 'execute': 0x2B, 'print_screen': 0x2C, 'ins': 0x2D, 'del': 0x2E, 'help': 0x2F, '0': 0x30, '1': 0x31, '2': 0x32, '3': 0x33, '4': 0x34, '5': 0x35, '6': 0x36, '7': 0x37, '8': 0x38, '9': 0x39, 'a': 0x41, 'b': 0x42, 'c': 0x43, 'd': 0x44, 'e': 0x45, 'f': 0x46, 'g': 0x47, 'h': 0x48, 'i': 0x49, 'j': 0x4A, 'k': 0x4B, 'l': 0x4C, 'm': 0x4D, 'n': 0x4E, 'o': 0x4F, 'p': 0x50, 'q': 0x51, 'r': 0x52, 's': 0x53, 't': 0x54, 'u': 0x55, 'v': 0x56, 'w': 0x57, 'x': 0x58, 'y': 0x59, 'z': 0x5A, 'numpad_0': 0x60, 'numpad_1': 0x61, 'numpad_2': 0x62, 'numpad_3': 0x63, 'numpad_4': 0x64, 'numpad_5': 0x65, 'numpad_6': 0x66, 'numpad_7': 0x67, 'numpad_8': 0x68, 'numpad_9': 0x69, 'multiply_key': 0x6A, 'add_key': 0x6B, 'separator_key': 0x6C, 'subtract_key': 0x6D, 'decimal_key': 0x6E, 'divide_key': 0x6F, 'F1': 0x70, 'F2': 0x71, 'F3': 0x72, 'F4': 0x73, 'F5': 0x74, 'F6': 0x75, 'F7': 0x76, 'F8': 0x77, 'F9': 0x78, 'F10': 0x79, 'F11': 0x7A, 'F12': 0x7B, 'F13': 0x7C, 'F14': 0x7D, 'F15': 0x7E, 'F16': 0x7F, 'F17': 0x80, 'F18': 0x81, 'F19': 0x82, 'F20': 0x83, 'F21': 0x84, 'F22': 0x85, 'F23': 0x86, 'F24': 0x87, 'num_lock': 0x90, 'scroll_lock': 0x91, 'left_shift': 0xA0, 'right_shift ': 0xA1, 'left_control': 0xA2, 'right_control': 0xA3, 'left_menu': 0xA4, 'right_menu': 0xA5, 'browser_back': 0xA6, 'browser_forward': 0xA7, 'browser_refresh': 0xA8, 'browser_stop': 0xA9, 'browser_search': 0xAA, 'browser_favorites': 0xAB, 'browser_start_and_home': 0xAC, 'volume_mute': 0xAD, 'volume_Down': 0xAE, 'volume_up': 0xAF, 'next_track': 0xB0, 'previous_track': 0xB1, 'stop_media': 0xB2, 'play/pause_media': 0xB3, 'start_mail': 0xB4, 'select_media': 0xB5, 'start_application_1': 0xB6, 'start_application_2': 0xB7, 'attn_key': 0xF6, 'crsel_key': 0xF7, 'exsel_key': 0xF8, 'play_key': 0xFA, 'zoom_key': 0xFB, 'clear_key': 0xFE, '+': 0xBB, ',': 0xBC, '-': 0xBD, '.': 0xBE, '/': 0xBF, ';': 0xBA, '[': 0xDB, '\\': 0xDC, ']': 0xDD, "'": 0xDE, "`": 0xC0&#125; win32按键码.留着一份省着每次再找了]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碧蓝航线翻牌游戏脚本]]></title>
    <url>%2Fblhx-fanpai4-45%2F</url>
    <content type="text"><![CDATA[匹配相同的牌时是裁下每张牌后,直接对比每张图片的数组是否相同 翻牌的时候想要同时点两张牌,但是查了下adb好像没有支持mult touch,然后想到在模拟器上给每个牌的位置设置快捷键,翻牌的时候调用win32api点击对应的快捷键来翻牌. 最终成绩4.45秒.b站视频:https://www.bilibili.com/video/av44287472/ 下面是完整代码.其中vkcode.VK_CODE是win32按键码映射表,在这篇博客有 82~89行那些几个sleep的参数是试出来的,再小就容易出错了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#! /usr/bin/env python# -*- coding: utf-8 -*-import timeimport osimport cv2import numpy as npimport win32apiimport win32confrom vkcode import VK_CODEclass Blhx: def __init__(self, adbPATH, sharedPATH): self.adb = adbPATH self.sharedPATH = sharedPATH def getScreen(self, filePath="/sdcard/Pictures/tmp.png"): os.system(f"&#123;self.adb&#125; -e shell screencap -p &#123;filePath&#125;") time.sleep(0.5) return cv2.imread(f"&#123;self.sharedPATH&#125;\\tmp.png") def tap(self, X, Y): os.system(f"&#123;self.adb&#125; -e shell input tap &#123;X&#125; &#123;Y&#125;") def cutEvery(self, img): ims = [] matched = [] for y in range(3): for x in range(6): startX = 148 * x + 238 startY = 162 * y + 179 endX = startX + 90 endY = startY + 129 im = img[startY:endY, startX:endX, :] thisImInfo = (y, x, im) hasmatch = False for i, imgInfo in enumerate(ims): difference = cv2.subtract(im, imgInfo[2]) result = not np.any(difference) if result: hasmatch = True matched.append(imgInfo[:2]) matched.append(thisImInfo[:2]) del ims[i] continue if not hasmatch: ims.append(thisImInfo) return matchedkeyboardsMap = [ "QWERTY".lower(), "ASDFGH".lower(), "ZXCVBN".lower()]def mian(): blhx = Blhx(r"E:\programfiles\adb\adb.exe", "J:\ldmnqshare") blhx.tap(800, 485) time.sleep(1.1) print("jietu") im = blhx.getScreen() pos = blhx.cutEvery(im) ks = [] for i, p in enumerate(pos): k = keyboardsMap[p[0]][p[1]] ks.append(k) kl = ks.__len__() if not kl == 18: print("没匹配好") return time.sleep(1) for x in range(9): k0 = 2 * x k1 = k0 + 1 kNode0 = ks[k0] kNode1 = ks[k1] win32api.keybd_event(VK_CODE[kNode0], 0, 0, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode1], 0, 0, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode0], 0, win32con.KEYEVENTF_KEYUP, 0) time.sleep(0.04) win32api.keybd_event(VK_CODE[kNode1], 0, win32con.KEYEVENTF_KEYUP, 0) print("tap") time.sleep(0.375)if __name__ == '__main__': mian()]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>碧蓝航线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cuclasses]]></title>
    <url>%2FCuclasses%2F</url>
    <content type="text"><![CDATA[介绍 Cuclasses是我正在写的python库,内容是集合了一些常用的类和方法 项目地址 pypi(少有更新):https://pypi.org/project/cuclasses/ github:https://github.com/HHHHhgqcdxhg/cuclasses 模块 cuclasses.DottableDict 顾名思义,能用 “.” 访问的dict.因为喜欢js访问对象属性的方式,可以用下标,也可以用点. cuclasses.singleton 装饰器. 被装饰的类为单例模式 cuclasses.CallableDict 可以调用的dict,调用时返回自身. cuclasses.StrKeyDict 在查询时把非字符串键转换为字符串的dict cuclasses.headerCopy2Dict 因为在复制chrome开发者工具network里请求的header时很不方便,就弄了这个…把chrome里的headers复制进去,会转换成字典 123456789101112headerStr = """Accept: application/json, text/plain, */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-aliveCookie: l=v; buvid3=08DBF55E-086D-4BE2-9FCB-4B60BFA5F05A140254infocHost: message.bilibili.comOrigin: https://www.bilibili.comReferer: https://www.bilibili.com/video/av9912938/?p=11User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"""a = headerCopy2Dict(headerStr)print(a)#&gt;&gt;&gt; &#123;'Accept': 'application/json, text/plain, */*', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Host': 'message.bilibili.com', 'Origin': 'https://www.bilibili.com', 'Referer': 'https://www.bilibili.com/video/av9912938/?p=11', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125; cuclasses.timePrint 上下文管理器. 带时间戳的print.随时可指定时间格式 12345678910111213141516with timePrint() as print: print(0) # &gt;&gt;&gt; [2019-02-10 16:23:35] 0 print(1, strf="[%Y-%m-%d %H:%M:%S]1") # &gt;&gt;&gt; [2019-02-10 16:23:35]1 1with timePrint("[%Y-%m-%d %H:%M:%S]2") as print: print(2) # &gt;&gt;&gt; [2019-02-10 16:23:35]2 2 print(3, strf="[%Y-%m-%d %H:%M:%S]3") # &gt;&gt;&gt; [2019-02-10 16:23:35]3 3print(4)# &gt;&gt;&gt; 4 cuclasses.timeCount 装饰器.接受两个参数. 被装饰的函数将在执行后打印执行时间 12:param enable: 设为False则不计时,直接执行函数:param method: 可选择的计时所用的获取时间的函数.默认time.perf_counter,或者也可以选填time.time,python3.7可以按需选用time.perf_counter_ns 1234567@timeCount()def bar(): print(&#123;"a": "c"&#125;)bar()#&gt;&gt;&gt; &#123;'a': 'c'&#125;#&gt;&gt;&gt; func bar excuted in : 6.044444444444444e-05 cuclasses.Downloader 下载器. 1234:param directory:下载到的目录:param urls:需要下载的资源目录:param threads:并行下载的线程数:param headers:请求头,默认为&#123;&quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;&#125; with open("xx.json","r") as f: data = json.load(f) d = Downloader(directory=r"E:\ACG\comic\general\どうして私が美術科に",urls=data) d.downloadAll()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站的搭建]]></title>
    <url>%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[依赖 本博客基于Hexo生成,选用Next.Mixins作为主题 正文 主题 不是很喜欢黑黑的颜色,就把css里颜色改了改,改成了蓝色的主题 写作工具 VSC + MPE写md不要太爽(atom,sublime应该一样) 图床 图床用的是七牛云 上传图片至图床的工具是PicGo,同样不要太爽 现在是vs-picgo了,爽上加爽 deploy 不是很清楚hexo clean和hexo generate的关系,索性每次deploy的时候都先hexo clean再hexo g再hexo d.因为很麻烦,就写了段C++做成个exe int main() { system("hexo clean"); system("hexo g"); system("hexo d"); return 0; } 之后就把编译出来的exe命名为d.exe放到项目根目录,之后每次deploy就./d就完事了 评论 之前选用的livere,现在换成了Valine]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[azurlane-painting开发笔记]]></title>
    <url>%2Fazurlane-painting%2F</url>
    <content type="text"><![CDATA[dalao的开发过程 我的开发过程 repo : https://github.com/HHHHhgqcdxhg/azurlane-painting 图片处理过程: 将图片缩小 -&gt; 将图片色彩聚类到16色 -&gt; 将聚类后的16色归到舰b指定的8色 -&gt; 合成画板图片]]></content>
      <categories>
        <category>碧蓝航线</category>
      </categories>
      <tags>
        <tag>碧蓝航线</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bilibili机器人更新日志]]></title>
    <url>%2Fbili-bot-release-log%2F</url>
    <content type="text"><![CDATA[19/06/20 自动搬运youtube视频部署上线 19/05/13 开启广告位招租 19/03/03 重构项目的转推部分 19/02/18 取消对以关键字&quot;【お知らせ&quot;开头的推特的图片打水印(那个图太小了) 19/02/07 取消对以关键字&quot;【接続障害&quot;开头的推特的转推(即日服服务器故障和故障修复的推文) 19/01/27 增加图片水印 18/12/24 修复IOS端点开大图一直正在加载的问题 18/12/21 自动在回复中发送机翻 18/12/20 取消对以关键字&quot;【メンテナンス&quot;开头的推特的转推(即日服维护说明) 18/12/19 䒕黃苽机器人开始运行]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>bot</tag>
        <tag>bilibot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B站碧蓝航线转推姬介绍]]></title>
    <url>%2Fbili-bot%2F</url>
    <content type="text"><![CDATA[简介 这里是䒕黃苽B站机器人的介绍 非碧蓝航线官方.是个机器人.会实时转发碧蓝航线新推特和Youtube上的新视频到B站.qq裙: 881800897 主要活动 转发碧蓝航线日服官推 由自动程序控制 会实时转发碧蓝航线官方推特@azurlane_staff的推文到bilibili动态,并在评论区附上百度翻译得来的译文 转载Youtube碧蓝航线频道的投稿 由自动程序控制 会实时转发碧蓝航线官方Youtube频道@アズールレーン的新视频到bilibili 碧蓝航线直播转播 墙外的直播会进行转播 转播是直接将直播源的媒体流转发,保证与直播源完全一致无任何私货. 直播间: https://live.bilibili.com/21334927 碧蓝航线直播录播 无论墙内还是墙外的直播都会进行录播. 录播同样是对直播源媒体流直接抓流,保证与直播源完全一致无任何私货. 机器人特性 因为是机器人,所以很多方面不可能比得上万物之灵长的人类啦 䒕黃苽机器人会无差别地搬运推特,做不到对优质内容的筛选 有时候主人会调试机器人功能,可能会发一些迷之动态,这时如果看到了无视就好 当然这种一般会在半夜进行,并且尽快删掉 虽说是机器人,主人也会上这个账号,偶尔注入灵魂不要吃惊哦 合作 片源合作 䒕黃苽有着一手瓜游相关的视频和直播的抓流资源,如果烤肉组需要片源可以联系我 想要其他的机器人? 如果你想像本转推姬一样,实时搬运其他的推主的推特或Youtuber的新视频到B站,都可以联系䒕黃苽 需要自备一个拿来转推的B站账号 注意B站限制绑定了手机号的账号才能发动态 联系主人 主人是@蔳莼菂小黃苽. 主人QQ:2894700792 加好友的认证信息请认真填写 也可以通过关于我中的社交平台账号进行联系 其他 更新日志 䒕黃苽B站碧蓝航线转推姬更新日志 䒕黃苽QQ机器人 䒕黃苽除了B站的这个机器人以外,还有QQ机器人,会实时转发碧蓝航线日服官推到QQ群 881800897 具体请见䒕黃苽QQ机器人使用指南 投喂 运行机器人还是有成本在的哦,希望有钱人dalao能帮䒕黃苽分担一下 打赏¥3.00 打赏¥10.00 打赏¥23.33 打赏¥66.66 打赏¥100.00 或前往https://blog.ggemo.com/feed/查看更多打赏渠道]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>bot</tag>
        <tag>bilibot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小黄瓜机器人使用指南]]></title>
    <url>%2Fbot-help%2F</url>
    <content type="text"><![CDATA[介绍 小黄瓜机器人QQ:2482513293 小黄瓜详细功能列表见下文 想要自己的群拥有小黄瓜的话请前往加群准则 所有可能烦人的功能都是可以群管理发送指令开启/关闭的 想要做一个跟小黄瓜类似的机器人,可以跳转至技术相关 加群准则 因为加群太多会使服务器负担太大,所以会控制加群数量. 不乐意加入的群: 人数比较少的群 百十个人及以下的群难以保证管理和群员的素质 䒕黃苽机器人的推特转发需要每发一个群等待0.5秒后发往下一个群,否则容易被腾讯限制.因此人数少的群会使这0.5秒比较浪费 不感兴趣的群 舰b群和kirara fantasia群以外的邀请不出意外应该不会接受 想要自己的群拥有小黄瓜的话需要以下步骤: 通读本文.找到文中藏着的6位暗号,即可证明通读了本文. 确保要拉的裙满足条件(条件并不严格哦) 并加䒕黃苽机器人为好友 加好友后 私聊䒕黃苽机器人告知一声(不用等回复即可进行下一步) 拉䒕黃苽进群 6位暗号的第1, 2, 3位: 啊哈哇 下一处暗号位置: 联系主人功能 功能列表 无指令功能 点击功能跳转到对应位置 功能 机器人需要管理权限 控制开关 转发推特功能 否 !tweetConfig指令 复读机随机禁言功能 是 !fuduBanConfig指令 新人入群提醒功能 否 !welcomeConfig指令 指令功能 指令功能是通过发送以感叹号开始的指令触发的功能,中文或英文感叹号均可,无视大小写. 点击功能跳转到对应位置 指令 功能 机器人需要管理权限 限管理可用 控制开关 !help 帮助功能 否 否 无 !fuck 众裁功能 是 否 指令 !sleep 金质睡眠功能 是 否 指令 !del 定时撤回消息功能 是 否 指令 !recipe 获取一份假的食谱功能 否 否 指令 !build 碧蓝航线建造模拟器 否 否 指令 !tweetConfig 设置转发推特的功能 否 是 无 !enable 开启功能的功能 否 是 无 !disable 关闭功能的功能 否 是 无 !report 联系主人功能 否 是 无 功能详情 新人入群提醒功能 !welcomeConfig指令限管理可用 有新人入群时,小黄瓜机器人将@新人,发送入群提醒 管理可通过发送 !welcomeConfig + 内容 来指定入群提醒内容 如: 12!welcomeConfig欢迎加入善良可爱小海豹保护者协会群!请先阅读群置顶公告哦! 注: 设置的入群提醒不宜太长,避免刷屏.建议提醒阅读群公告,内容写在群公告即可 设置的入群提醒中的图片将被忽略 !welcomeConfig后不跟内容,将取消入群提醒 复读功能 通过指令开/关功能 小黄瓜检测到有人在复读,就会跟着复读 因不堪网络暴力机器人发消息太多会被腾讯制裁,本功能停止使用 复读机随机禁言功能 !fuduBanConfig指令限管理可用 | 机器人需要管理权限 管理可通过发送类似下面的消息,更改禁言复读机配置 1234567!fuduBanConfig&#123; &quot;banLen&quot;: 2, &quot;banMult&quot;: 10, &quot;banRebel&quot;: false, &quot;randMemberMode&quot;: 2, &quot;randTimeMode&quot;: 3&#125; 对配置的解释如下: 字段名描述可选值对应效果banLen触发复读禁言条数>= 2复读条数(算上 被复读的那一条) 大于等于 这个值时,触发复读禁言 banMult禁言力度>= 1控制禁言时长的力度banRebel 是否开启禁言复读机叛徒true此时,如果是参与复读的人打断复读,则不再进行复读机随机抽取,而是直接抽中这名复读机叛徒false正常进行复读机抽取randMemberMode抽取复读机的模式0关闭本功能,不再禁言复读机1随机抽取一名复读机2正态分布随机抽取一名复读机3取倒数第二个复读机randTimeMode抽取禁言时长的模式1经典随机,禁言时间为 (1~本轮复读条数 之间的随机数) * banMult2复读总长相关,禁言时间为 本轮复读条数 * banMult3固定时长,禁言时长为 banMult4按座位,被抽到的复读机在本轮复读中是倒数第n个,时长就为 n * banMult 众裁功能 本功能为指令功能,通过发送 !fuck + @一名群员 触发 通过指令开/关功能 | 机器人需要管理权限 在一人通过该指令开启对一名群员A的众裁之后,将开始三分钟的计时,统计三分钟内通过该指令参与对群员A的众裁的人数,于三分钟后对群员A进行制裁(禁言) 禁言时长: 参与本轮众裁人数 禁言时长(分钟) &lt;= 2 不禁言 3 5 4 10 &gt;= 5 每多一人,时长加2 注: !fuck后面跟上@一名群员,这个@必须是能@到人的,复制粘贴的不管用 不要重复参与众裁,否则会被禁言1分钟 不要再众裁群主管理辣! 不要欺负人哦,拿来制裁海豹正适合 定时撤回消息功能 本功能为指令功能,通过发送 !del + 时长 + 空格 + 消息 触发 通过指令开/关功能 | 机器人需要管理权限 示例: 1!del 10 这条消息将在10秒后被撤回 注: 如 !del 后不加时长,直接跟消息,则默认撤回时长为5秒 如设置时长,记得时长数字和后面消息中间用空格分隔 设置时长最大为600,超过这个值将改为5 本功能为限 非管理群员 使用 金质睡眠功能 本功能为指令功能,通过发送 !sleep 触发 通过指令开/关功能 | 机器人需要管理权限 22:00~次日03:59发送指令,发送者将被禁言6小时 食谱功能 本功能为指令功能,通过发送 !recipe 或 !gbf触发 通过指令开/关功能 | 消耗黄瓜片 : 20 发送一份分享,标题和图片为随机食谱的标题和图片,点开却是granbluefantasy.jp 碧蓝航线建造模拟器 本功能为指令功能,通过发送 !build 触发 通过指令开/关功能 | 消耗黄瓜片 : 40 !build可接受最多两个正整数参数,用逗号分隔(中英文标点均可) 指令 效果 !build 抽取1池10次 !build x 抽取x池10次,x可为1,2,3 !build x,y 抽取x池y次,y为1~10 注: 概率保证按照官方给出的概率 卡池信息来自着迷碧蓝航线wiki建造模拟器 不准备做限时建造的卡池,想玩的请移步着迷碧蓝航线wiki限时建造模拟器 本功能需要生成图片发送图片,对服务器资源消耗过大,不要玩太过分哦 如果!build没有反应,或者只回复文字不显示图片,就代表被腾讯限制了,这时候就要稍后再试 转发推特功能 !tweetConfig指令限管理可用 小黄瓜会实时(Real Time)转发指定推特用户发送的新推特至qq群 新加的群是不会转发推特的,需要经过设置后,可转发指定推特 设置方法:发送类似如下的消息,可添加或修改推特转发: 12345678910111213!tweetConfig&#123; &quot;follow&quot;:&#123; &quot;name&quot;:&quot;@azurlane_staff&quot;, &quot;nickName&quot;:&quot;碧蓝航线日服推特&quot; &#125;, &quot;groupInfo&quot;: &#123; &quot;nickName&quot;: &quot;在这里填写群名&quot;, &quot;trans&quot;: true, &quot;sendRT&quot;: false, &quot;mediaOnly&quot;:false, &quot;follow&quot;: true &#125;&#125; 以下为对上面配置的解释: 12345678910111213!tweetConfig&#123; &quot;follow&quot;:&#123; &quot;name&quot;:&quot;这里填入需要关注的人的推特Id,以@开头&quot;, &quot;nickName&quot;:&quot;这里填入关注的人的称呼&quot; &#125;, &quot;groupInfo&quot;: &#123; &quot;nickName&quot;: &quot;群名&quot;, //在这里填写群名,理论上随便填,主要目的是让作者辨识出是哪个群 &quot;trans&quot;: true, //是否需要发送一遍将经过百度翻译的推文,把true改成false将不翻译 &quot;sendRT&quot;: false, //是否需要发送 转发和回复别人的推特,建议关闭,打开很烦人的,把false改成true打开 &quot;mediaOnly&quot;: false, //将false改成true,将只发有图片内容的推特,纯文字推特将忽略,适合关注画师 &quot;follow&quot;: true //将true改为false,将不转发此人的推特 &#125;&#125; 注意: 这条消息除开头的!tweetConfig以外,全部大小写敏感且必须用半角标点符号(即英文标点) 大括号,冒号,逗号,引号都不能漏 不要将true打成ture,false打成flase… 若出现&quot;查找用户信息失败&quot;提示,请确定关注的人的id以@符号开头,确认无误后稍后再试 小黄瓜机器人定时每周四取消对 只有一个群关注的推特 的关注 附录中给出了些常用推特供参考 开启功能的功能 本功能为指令功能,通过发送 !enable + 其他功能指令 触发 限管理可用 指令 功能 !enable !sleep 开启金质睡眠功能 !enable !fuck 开启众裁功能 !enable !recipe 开启食谱功能 !enable !build 开启碧蓝航线建造模拟器 !enable !del 开启定时撤回消息功能 注:无视所有感叹号全/半角,不区分大小写 关闭功能的功能 本功能为指令功能,通过发送 !disable + 其他功能指令 触发 限管理可用 指令 功能 !disable !sleep 关闭金质睡眠功能 !disable !fuck 关闭众裁功能 !disable !recipe 关闭食谱功能 !disable !build 关闭碧蓝航线建造模拟器 !disable !del 关闭定时撤回消息功能 注:无视所有感叹号全/半角,不区分大小写 联系主人功能 本功能为指令功能,通过发送 !report 触发 !report指令限管理可用 机器人接收到以!report开头的消息,会发送给主人看到 注: 乱玩此功能会打扰到主人的,请不要乱玩 机器人功能相关请先仔细阅读本篇文档对应部分以及Q&amp;A部分 在群里直接@小黄瓜机器人,主人一般情况下看不到的 私聊小黄瓜机器人,主人一般情况下看不到 使用!report指令的消息,主人会看到,并尽量及时回应 按照下面联系方式联系主人,是比较有效的联系方式 有事请直接说事,免掉&quot;在吗&quot;之类的打招呼内容 谢绝无事骚扰 主人QQ:2894700792 加好友的认证信息请认真填写 6位暗号的第4位: 噗 下一处暗号位置: 限管理可用功能 黄瓜片系统 出于目的: 防止功能滥用对小黄瓜服务器造成太大负担 防止某些功能造成刷屏 防止被tx限制 现在实装黄瓜片系统,某些功能需要消耗黄瓜片(黄瓜片就是类似体力的东西啦) 获得黄瓜片 小黄瓜机器人会在每天凌晨04:30,中午13:30,晚上19:30将所有群友的黄瓜片置为40点. 即,黄瓜片不可积攒,每个时间段40点 消耗黄瓜片 消耗黄瓜片的功能 功能 消耗黄瓜片数/次 碧蓝航线建造模拟器 40 食谱功能 20 其他 小黄瓜机器人的管理权限 给小黄瓜管理权限后,机器人并不能马上意识到自己是管理,需要重启插件,这时通过联系主人功能告知重启 限管理可用功能 本文中的&quot;管理&quot;,皆指 管理or群主 把部分功能做成仅限管理可用,目的是过滤掉没素质的人,希望身为管理能意识到自己的一份素质,不要闲来无事report玩,或者凭一己之见关注一些奇怪或无聊的推特 6位暗号的第5位: 嘤 下一处暗号位置: QA idea相关 有觉得好玩的机器人的玩法的想法,可以联系主人哦 技术相关 因为小黄瓜机器人项目中有很多小黄瓜的apikey和OAuth认证信息,开源很麻烦,所以闭源 小黄瓜机器人项目代码是使用python编写,通过richardchien/coolq-http-api和richardchien/python-aiocqhttp控制酷Q实现的, 监听新推特是通过tweepy.StreamListener实现 酷Q只能跑在windows或有图形界面的linux服务器上,本人使用的服务器是阿里云服务器的学生机 其他的䒕黃苽 䒕黃苽bilibili机器人:@碧蓝航线转推姬 会将碧蓝航线新日推转发到B站动态,并在评论区附上翻译 䒕黃苽B站机器人介绍 䒕黃苽微博机器人:@碧蓝航线转推姬(和B站的同名哦) 会将碧蓝航线新日推转发到微博 其他相关 希望群友们素质聊天 投喂 运行机器人还是有成本在的哦,希望有钱人dalao能帮䒕黃苽分担一下 更多打赏渠道: https://blog.ggemo.com/feed/ 打赏¥3.00 打赏¥10.00 打赏¥23.33 打赏¥66.66 打赏¥100.00 QA QA1 Q: 建造模拟器怎么没有限定池? A: 䒕黃苽机器人的建造模拟器数据来源为着迷碧蓝航线wiki建造模拟器.而wiki并没有限定池详细信息,在着迷碧蓝航线wiki限时建造模拟器中,未知角色用问号代替,而䒕黃苽建造模拟器比较在意真实和美观,不乐意用问号这种.想玩的话还请前往着迷碧蓝航线wiki限时建造模拟器. QA2 Q: 建造模拟器概率是不是有问题啊? A: 概率纯粹按照官方给出的概率进行随机抽取,然而实际游戏中可能并非如此(详细可以看下这个视频: bilibili - 揭秘游戏氪金抽卡的“黑幕”【游戏侦查冰】 - 芒果冰OL),故可能感官上和真实游戏中有所不同. QA3 Q: !build经常会没有反应或者只回复文字没有图片,是怎么回事? A: 图片发多了会被腾讯限制,一段时间内发不出图片的,这种时候还请稍候再试 QA4 Q: 为什么我拉䒕黃苽机器人进群或者加好友没有反应? A: 加群准则见本页加群准则.加好友没有反应一定是因为加好友理由是乱填. QA5 Q: 䒕黃苽机器人是有收费的吗? A: 䒕黃苽机器人暂时没有任何付费功能,入群无租金,黄瓜片不可充值.不过如果你钱比较多还喜欢䒕黃苽的话还请通过本页面的投喂进行资助. QA6 Q: 可以 拍/切/剁/用 黄瓜吗? A: 是不可以的. QA7 Q: 䒕黃苽主人是个什么人? A: https://blog.ggemo.com/about/ 6位暗号的第6位: 咕 附录-常用推特id 推特id 备注 @korindo 博丽神主推特 @kirarafantasia 芳文社手游きららファンタジア官推 @azurlane_staff 碧蓝航线日服官推]]></content>
      <categories>
        <category>bot</category>
      </categories>
      <tags>
        <tag>qqbot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python程序打包成exe]]></title>
    <url>%2Fpy2exe%2F</url>
    <content type="text"><![CDATA[前言 用python写了个项目(在这)想发布出去给没有python环境的人用.试了pyinstaller,打包出来不能正常跑…于是心生淫技,将python环境跟项目放到一起,然后拿C写几行程序,通过system call的方式调用python运行项目脚本,再将这个C程序编译成exe… python环境的准备 我首先试了拿虚拟环境,然后发现虚拟环境少了一堆dll…拿自己的python环境吧,一堆这个项目用不着的库,打包进去太大,挑出来太麻烦…索性另外装一个python.我本身环境是3.6.7版本的,又去另外装了个3.7.2版本.安装时注意把什么设置环境变量,向所有用户安装都取消了,留着pip就好,之后拿pip把包都装好,然后把整个python目录拷贝到项目根目录就完事了 准备一个exe 这就比较野蛮…程序入口12345678910111213141516171819202122```C++#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;direct.h&gt; using namespace std;int main(int argc, char * argv[])&#123; string cwd = _getcwd(NULL, 0); string cmd = &quot;\\Python37-32\\python.exe __main__.py&quot;; cmd = cwd + cmd; for (int i = 1; i &lt; argc; i++) &#123; cmd += &quot; &quot;; cmd += argv[i]; &#125; const char *cmd_c_str = cmd.c_str(); // cout &lt;&lt; cmd_c_str&lt;&lt;endl; system(cmd_c_str); //system(&quot;pause&quot;); return 0;&#125; 编译好拿出来放到项目根目录就完事了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桌面追番助手]]></title>
    <url>%2FbangumiDesktopAssistant%2F</url>
    <content type="text"><![CDATA[本项目git仓库:https://dev.tencent.com/u/hhhhhg/p/bangumiDesktopAssistant 尝试了打包成exe却做不到,所以应该只有装了python才能用了XD python版本是3.6.4(因为用到了f前缀字符串,所以大概需要至少3.6版本),操作系统只试了windows 使用: 1234git clone https://git.dev.tencent.com/hhhhhg/bangumiDesktopAssistant.gitcd bangumiDesktopAssistantpip install -r requirements.txtpython __main__.py 在任务栏找到图标(和项目头像是同一张图片),右键可进行追番编辑或者退出程序. 追番编辑工具按要求填入信息,可生成一份番剧信息,保存在src/db/bangumisInfo中,如果填入得当,不发生意外,则可正常使用. 遇到特殊情况(比如番剧停更)则需要手动改对应的json文件中的chapters部分… 有番剧更新时,会播放音频,为src/audio/alarm.wav 透明度,配色等配置存在src/db/config.json中,可以轻易更改 配置好环境后,之后可以运行bangumi.bat来运行本工具,也可在注册表中将bangumi.bat设为开机自启 运行截图: 1080p屏幕下unfocused状态表现 1080p屏幕下focused状态(鼠标悬停在之上时)表现 之前用tkinter写了两天了,察觉有点不好用,又换成了PyQt5. 耗资源方面,平常在后台运行就占用十几二十M内存]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>动漫</tag>
        <tag>gui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投喂]]></title>
    <url>%2Ffeed%2F</url>
    <content type="text"><![CDATA[我很努力(ง •̀_•́)ง 请给我钱 (σ $﹃$)σ 做䒕黃苽机器人还是有些成本在的,请帮帮䒕黃苽回回本吧! 爱发电 ￥ 爱发电 支付宝 打赏¥3.00 打赏¥10.00 打赏¥23.33 打赏¥66.66 打赏¥100.00 微信 打赏¥3.00 打赏¥10.00 打赏¥23.33 打赏¥66.66 打赏¥100.00 请给我钱 我什么都不会做的 .hgImgHolder{width:auto;height:200px;float:left}]]></content>
      <tags>
        <tag>投喂</tag>
      </tags>
  </entry>
</search>
